<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langcode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AccelByte Unreal SDK: AccelByte::Api::CloudSave Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-logo.css" rel="stylesheet" type="text/css"/>
    <style>
        #top-header-logo {
            height: auto;
        }
        #top-header-logo img {
            height: 40px;
            width: auto;
        }
        #searcharea {
            padding-right: 10px;
        }
    </style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="top-header-logo">
        <img alt="AccelByte Unreal SDK" src="../../AccelByte Main Logo - Horizontal.svg"/>
    </div>
    <div id="searcharea">
                <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
    </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('df/dcb/class_accel_byte_1_1_api_1_1_cloud_save.html','../../','d4/df4/class_accel_byte_1_1_api_1_1_cloud_save-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">AccelByte::Api::CloudSave Class Reference<div class="ingroups"><a class="el" href="../../d8/db3/group___client_a_p_i.html">Client API</a> &raquo; <a class="el" href="../../d7/d33/group___cloud_save.html">Cloud Save &amp; Storage</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../df/dcb/class_accel_byte_1_1_api_1_1_cloud_save.html" title="CloudSave API for storing records.">CloudSave</a> API for storing records.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d9/d1c/_accel_byte_cloud_save_api_8h_source.html">AccelByteCloudSaveApi.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Inheritance diagram for AccelByte::Api::CloudSave:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="../../df/dcb/class_accel_byte_1_1_api_1_1_cloud_save.png" usemap="#AccelByte_3A_3AApi_3A_3ACloudSave_map" alt=""/>
  <map id="AccelByte_3A_3AApi_3A_3ACloudSave_map" name="AccelByte_3A_3AApi_3A_3ACloudSave_map">
<area href="../../d3/dd3/class_accel_byte_1_1_f_api_base.html" alt="AccelByte::FApiBase" shape="rect" coords="0,0,335,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5e79f338015cc39663376bcde5920c2a" id="r_a5e79f338015cc39663376bcde5920c2a"><td class="memItemLeft" align="right" valign="top"><a id="a5e79f338015cc39663376bcde5920c2a" name="a5e79f338015cc39663376bcde5920c2a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CloudSave</b> (<a class="el" href="../../d0/d90/class_accel_byte_1_1_credentials.html">Credentials</a> const &amp;InCredentialsRef, <a class="el" href="../../df/db1/class_accel_byte_1_1_settings.html">Settings</a> const &amp;InSettingsRef, <a class="el" href="../../df/d3f/class_accel_byte_1_1_f_http_retry_scheduler_base.html">FHttpRetrySchedulerBase</a> &amp;InHttpRef, TSharedPtr&lt; <a class="el" href="../../d9/d63/class_accel_byte_1_1_f_api_client.html">AccelByte::FApiClient</a>, ESPMode::ThreadSafe &gt; const &amp;InApiClient=nullptr)</td></tr>
<tr class="memitem:a3ec7ab5e55c5e7989ea6f859bc5aab42" id="r_a3ec7ab5e55c5e7989ea6f859bc5aab42"><td class="memItemLeft" align="right" valign="top"><a id="a3ec7ab5e55c5e7989ea6f859bc5aab42" name="a3ec7ab5e55c5e7989ea6f859bc5aab42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CloudSave</b> (<a class="el" href="../../d0/d90/class_accel_byte_1_1_credentials.html">Credentials</a> const &amp;InCredentialsRef, <a class="el" href="../../df/db1/class_accel_byte_1_1_settings.html">Settings</a> const &amp;InSettingsRef, <a class="el" href="../../df/d3f/class_accel_byte_1_1_f_http_retry_scheduler_base.html">FHttpRetrySchedulerBase</a> &amp;InHttpRef, FAccelBytePlatformPtr const &amp;InAccelBytePlatform)</td></tr>
<tr class="memitem:a40df3f82999248b942263e345369373a" id="r_a40df3f82999248b942263e345369373a"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40df3f82999248b942263e345369373a">SaveUserRecord</a> (const FString &amp;Key, bool bSetPublic, const FJsonObject &amp;RecordRequest, const FVoidHandler &amp;OnSuccess, const FErrorHandler &amp;OnError)</td></tr>
<tr class="memdesc:a40df3f82999248b942263e345369373a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a user-level record with Metadata input value.  <br /></td></tr>
<tr class="memitem:a8d5b5119bc48cae4dd33f030d28b4328" id="r_a8d5b5119bc48cae4dd33f030d28b4328"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d5b5119bc48cae4dd33f030d28b4328">SaveUserRecord</a> (FString const &amp;Key, FJsonObject RecordRequest, bool IsPublic, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a8d5b5119bc48cae4dd33f030d28b4328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a user-level record. If the record doesn't exist, it will create and save the record, if already exists, it will append to the existing one.  <br /></td></tr>
<tr class="memitem:a9106ab608494c6bf61f7b84596dc3b41" id="r_a9106ab608494c6bf61f7b84596dc3b41"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9106ab608494c6bf61f7b84596dc3b41">GetUserRecord</a> (FString const &amp;Key, THandler&lt; <a class="el" href="../../d9/d4a/struct_f_accel_byte_models_user_record.html">FAccelByteModelsUserRecord</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a9106ab608494c6bf61f7b84596dc3b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a record (arbitrary JSON data) by its key in user-level.  <br /></td></tr>
<tr class="memitem:ad524b543f564b65327856a7f78225065" id="r_ad524b543f564b65327856a7f78225065"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad524b543f564b65327856a7f78225065">GetPublicUserRecord</a> (FString const &amp;Key, FString const &amp;UserId, THandler&lt; <a class="el" href="../../d9/d4a/struct_f_accel_byte_models_user_record.html">FAccelByteModelsUserRecord</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ad524b543f564b65327856a7f78225065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a public record (arbitrary JSON data) by its key and userId in user-level.  <br /></td></tr>
<tr class="memitem:aa1007f029af8963bc5aa9ae5e482c9ce" id="r_aa1007f029af8963bc5aa9ae5e482c9ce"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1007f029af8963bc5aa9ae5e482c9ce">BulkGetPublicUserRecord</a> (FString const &amp;Key, const TArray&lt; FString &gt; &amp;UserIds, THandler&lt; <a class="el" href="../../d3/d1f/struct_f_list_accel_byte_models_user_record.html">FListAccelByteModelsUserRecord</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:aa1007f029af8963bc5aa9ae5e482c9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a public record (arbitrary JSON data) by its key and userId in user-level.  <br /></td></tr>
<tr class="memitem:ad1ba298cb545992e29052610f1bfdbfc" id="r_ad1ba298cb545992e29052610f1bfdbfc"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1ba298cb545992e29052610f1bfdbfc">BulkGetUserRecords</a> (TArray&lt; FString &gt; const &amp;Keys, THandler&lt; <a class="el" href="../../d3/d1f/struct_f_list_accel_byte_models_user_record.html">FListAccelByteModelsUserRecord</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ad1ba298cb545992e29052610f1bfdbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk get records (arbitrary JSON data) by list of keys.  <br /></td></tr>
<tr class="memitem:aef797789ec84aa593145418b158741bc" id="r_aef797789ec84aa593145418b158741bc"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef797789ec84aa593145418b158741bc">ReplaceUserRecord</a> (const FString &amp;Key, bool bSetPublic, const FJsonObject &amp;RecordRequest, const FVoidHandler &amp;OnSuccess, const FErrorHandler &amp;OnError)</td></tr>
<tr class="memdesc:aef797789ec84aa593145418b158741bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one.  <br /></td></tr>
<tr class="memitem:a3877809323ff5cb935cc31c5ca0d245b" id="r_a3877809323ff5cb935cc31c5ca0d245b"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3877809323ff5cb935cc31c5ca0d245b">ReplaceUserRecord</a> (FString const &amp;Key, FJsonObject RecordRequest, bool IsPublic, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a3877809323ff5cb935cc31c5ca0d245b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one.  <br /></td></tr>
<tr class="memitem:aa0a3d210c18e9c981517904ab8eb5b5b" id="r_aa0a3d210c18e9c981517904ab8eb5b5b"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0a3d210c18e9c981517904ab8eb5b5b">ReplaceUserRecordCheckLatest</a> (FString const &amp;Key, FDateTime const LastUpdated, FJsonObjectWrapper RecordRequest, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:aa0a3d210c18e9c981517904ab8eb5b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one, but will failed if lastUpdated is not up-to-date.  <br /></td></tr>
<tr class="memitem:ae220c0a7de98cb44ab1b77cb9ee221a0" id="r_ae220c0a7de98cb44ab1b77cb9ee221a0"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae220c0a7de98cb44ab1b77cb9ee221a0">ReplaceUserRecordCheckLatest</a> (int TryAttempt, FString const &amp;Key, FJsonObjectWrapper RecordRequest, THandlerPayloadModifier&lt; FJsonObjectWrapper, FJsonObjectWrapper &gt; const &amp;PayloadModifier, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ae220c0a7de98cb44ab1b77cb9ee221a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. Beware: Function will try to get the latest value, put it in the custom modifier and request to replace the record. will retry it again when the record is updated by other user, until exhaust all the attempt.  <br /></td></tr>
<tr class="memitem:a3c299cc6b5c9a3f0cdec563b02934345" id="r_a3c299cc6b5c9a3f0cdec563b02934345"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c299cc6b5c9a3f0cdec563b02934345">ReplaceUserRecordCheckLatest</a> (FString const &amp;Key, FDateTime LastUpdated, FJsonObjectWrapper RecordRequest, THandler&lt; <a class="el" href="../../d3/dc9/struct_f_accel_byte_models_replace_user_record_response.html">FAccelByteModelsReplaceUserRecordResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a3c299cc6b5c9a3f0cdec563b02934345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one, but will failed if lastUpdated is not up-to-date.  <br /></td></tr>
<tr class="memitem:a5e509fb5e4a8965616cfc04b89e53bb8" id="r_a5e509fb5e4a8965616cfc04b89e53bb8"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e509fb5e4a8965616cfc04b89e53bb8">ReplaceUserRecordCheckLatest</a> (int TryAttempt, FString const &amp;Key, FJsonObjectWrapper RecordRequest, THandlerPayloadModifier&lt; FJsonObjectWrapper, FJsonObjectWrapper &gt; const &amp;PayloadModifier, THandler&lt; <a class="el" href="../../d3/dc9/struct_f_accel_byte_models_replace_user_record_response.html">FAccelByteModelsReplaceUserRecordResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a5e509fb5e4a8965616cfc04b89e53bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. Beware: Function will try to get the latest value, put it in the custom modifier and request to replace the record. will retry it again when the record is updated by other user, until exhaust all the attempt.  <br /></td></tr>
<tr class="memitem:a22f3714d7ee816858382c7976b91c60e" id="r_a22f3714d7ee816858382c7976b91c60e"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22f3714d7ee816858382c7976b91c60e">DeleteUserRecord</a> (FString const &amp;Key, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a22f3714d7ee816858382c7976b91c60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a record under the given key in user-level.  <br /></td></tr>
<tr class="memitem:a9908cc394566385e962f271e8f4f156e" id="r_a9908cc394566385e962f271e8f4f156e"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9908cc394566385e962f271e8f4f156e">SaveGameRecord</a> (FString const &amp;Key, FJsonObject RecordRequest, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a9908cc394566385e962f271e8f4f156e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a namespace-level record. If the record doesn't exist, it will create and save the record, if already exists, it will append to the existing one.  <br /></td></tr>
<tr class="memitem:a5f4ccd1fa483b627bc1f13d83975566e" id="r_a5f4ccd1fa483b627bc1f13d83975566e"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f4ccd1fa483b627bc1f13d83975566e">GetGameRecord</a> (FString const &amp;Key, THandler&lt; <a class="el" href="../../d6/d72/struct_f_accel_byte_models_game_record.html">FAccelByteModelsGameRecord</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a5f4ccd1fa483b627bc1f13d83975566e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a record by its key in namespace-level.  <br /></td></tr>
<tr class="memitem:a1a8e006f96fa423205565244d5ddff92" id="r_a1a8e006f96fa423205565244d5ddff92"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a8e006f96fa423205565244d5ddff92">ReplaceGameRecord</a> (FString const &amp;Key, FJsonObject RecordRequest, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a1a8e006f96fa423205565244d5ddff92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in namespace-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one.  <br /></td></tr>
<tr class="memitem:a9872316f5cac56e3e481f7c5b4de8e09" id="r_a9872316f5cac56e3e481f7c5b4de8e09"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9872316f5cac56e3e481f7c5b4de8e09">ReplaceGameRecordCheckLatest</a> (FString const &amp;Key, FDateTime const LastUpdated, FJsonObjectWrapper RecordRequest, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a9872316f5cac56e3e481f7c5b4de8e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in namespace-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one, but will failed if lastUpdated is not up-to-date.  <br /></td></tr>
<tr class="memitem:a5c79775f9765761e270c217d828bfd5e" id="r_a5c79775f9765761e270c217d828bfd5e"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c79775f9765761e270c217d828bfd5e">ReplaceGameRecordCheckLatest</a> (int TryAttempt, FString const &amp;Key, FJsonObjectWrapper RecordRequest, THandlerPayloadModifier&lt; FJsonObjectWrapper, FJsonObjectWrapper &gt; const &amp;PayloadModifier, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a5c79775f9765761e270c217d828bfd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in namespace-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. Beware: Function will try to get the latest value, put it in the custom modifier and request to replace the record. will retry it again when the record is updated by other user, until exhaust all the attempt.  <br /></td></tr>
<tr class="memitem:a0a576e29b343996ad5c95f151b195469" id="r_a0a576e29b343996ad5c95f151b195469"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a576e29b343996ad5c95f151b195469">DeleteGameRecord</a> (FString const &amp;Key, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a0a576e29b343996ad5c95f151b195469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a record under the given key in namespace-level.  <br /></td></tr>
<tr class="memitem:a68022670e426155da7ee8fba6a5600b2" id="r_a68022670e426155da7ee8fba6a5600b2"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68022670e426155da7ee8fba6a5600b2">BulkGetGameRecords</a> (TArray&lt; FString &gt; const &amp;Keys, THandler&lt; <a class="el" href="../../d8/d3a/struct_f_accel_byte_models_list_game_records.html">FAccelByteModelsListGameRecords</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a68022670e426155da7ee8fba6a5600b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk get game records (arbitrary JSON data) by list of keys.  <br /></td></tr>
<tr class="memitem:ad4952d34ba2da5fe259c65a1ea74be17" id="r_ad4952d34ba2da5fe259c65a1ea74be17"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4952d34ba2da5fe259c65a1ea74be17">BulkGetOtherPlayerPublicRecordKeys</a> (FString const &amp;UserId, THandler&lt; <a class="el" href="../../de/dcf/struct_f_accel_byte_models_paginated_bulk_get_public_user_record_keys_response.html">FAccelByteModelsPaginatedBulkGetPublicUserRecordKeysResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 const &amp;Offset=0, int32 const &amp;Limit=20)</td></tr>
<tr class="memdesc:ad4952d34ba2da5fe259c65a1ea74be17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the public key record for a user in bulk.  <br /></td></tr>
<tr class="memitem:ab42a2e2314adb30b83b33595b3639078" id="r_ab42a2e2314adb30b83b33595b3639078"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab42a2e2314adb30b83b33595b3639078">BulkGetCurrentPlayerPublicRecordKeys</a> (THandler&lt; <a class="el" href="../../de/dcf/struct_f_accel_byte_models_paginated_bulk_get_public_user_record_keys_response.html">FAccelByteModelsPaginatedBulkGetPublicUserRecordKeysResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 const &amp;Offset=0, int32 const &amp;Limit=20)</td></tr>
<tr class="memdesc:ab42a2e2314adb30b83b33595b3639078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the public key record for current user in bulk.  <br /></td></tr>
<tr class="memitem:ac29cf8bf5c4c8614fa6e639acd28f128" id="r_ac29cf8bf5c4c8614fa6e639acd28f128"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac29cf8bf5c4c8614fa6e639acd28f128">BulkGetOtherPlayerPublicRecords</a> (FString const &amp;UserId, TArray&lt; FString &gt; const &amp;Keys, THandler&lt; <a class="el" href="../../d3/d1f/struct_f_list_accel_byte_models_user_record.html">FListAccelByteModelsUserRecord</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ac29cf8bf5c4c8614fa6e639acd28f128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the public record for a user in bulk using public keys.  <br /></td></tr>
<tr class="inherit_header pub_methods_class_accel_byte_1_1_f_api_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_accel_byte_1_1_f_api_base')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="../../d3/dd3/class_accel_byte_1_1_f_api_base.html">AccelByte::FApiBase</a></td></tr>
<tr class="memitem:a5b4bfcf158b368358fc0860adece134c inherit pub_methods_class_accel_byte_1_1_f_api_base" id="r_a5b4bfcf158b368358fc0860adece134c"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>FApiBase</b> (<a class="el" href="../../d0/d90/class_accel_byte_1_1_credentials.html">Credentials</a> const &amp;InCredentialsRef, <a class="el" href="../../df/db1/class_accel_byte_1_1_settings.html">Settings</a> const &amp;InSettingsRef, <a class="el" href="../../df/d3f/class_accel_byte_1_1_f_http_retry_scheduler_base.html">FHttpRetrySchedulerBase</a> &amp;InHttpRef, TSharedPtr&lt; <a class="el" href="../../d9/d63/class_accel_byte_1_1_f_api_client.html">AccelByte::FApiClient</a>, ESPMode::ThreadSafe &gt; const &amp;InApiClient)</td></tr>
<tr class="memitem:a7532e689716d93aaa2f96568ab14c233 inherit pub_methods_class_accel_byte_1_1_f_api_base" id="r_a7532e689716d93aaa2f96568ab14c233"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>FApiBase</b> (<a class="el" href="../../d0/d90/class_accel_byte_1_1_credentials.html">Credentials</a> const &amp;InCredentialsRef, <a class="el" href="../../df/db1/class_accel_byte_1_1_settings.html">Settings</a> const &amp;InSettingsRef, <a class="el" href="../../df/d3f/class_accel_byte_1_1_f_http_retry_scheduler_base.html">FHttpRetrySchedulerBase</a> &amp;InHttpRef, FAccelBytePlatformPtr const &amp;InAccelBytePlatform)</td></tr>
<tr class="memitem:ab08541fe9d704af8a9b5bae1b87deb44 inherit pub_methods_class_accel_byte_1_1_f_api_base" id="r_ab08541fe9d704af8a9b5bae1b87deb44"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetApiClient</b> (TSharedPtr&lt; <a class="el" href="../../d9/d63/class_accel_byte_1_1_f_api_client.html">AccelByte::FApiClient</a>, ESPMode::ThreadSafe &gt; const &amp;InApiClient)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-inherited" class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_accel_byte_1_1_f_api_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_class_accel_byte_1_1_f_api_base')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Member Functions inherited from <a class="el" href="../../d3/dd3/class_accel_byte_1_1_f_api_base.html">AccelByte::FApiBase</a></td></tr>
<tr class="memitem:abf73c69f11a74c5d79ed767d7e9de861 inherit pro_methods_class_accel_byte_1_1_f_api_base" id="r_abf73c69f11a74c5d79ed767d7e9de861"><td class="memTemplParams" colspan="2">
template&lt;typename T&gt; </td></tr>
<tr class="memitem:abf73c69f11a74c5d79ed767d7e9de861 inherit pro_methods_class_accel_byte_1_1_f_api_base template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>ValidateAccelByteId</b> (FString const &amp;Id, EAccelByteIdHypensRule HypenRule, FString const &amp;ErrorMessage, T const &amp;OnError)</td></tr>
<tr class="inherit_header pro_attribs_class_accel_byte_1_1_f_api_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_class_accel_byte_1_1_f_api_base')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Attributes inherited from <a class="el" href="../../d3/dd3/class_accel_byte_1_1_f_api_base.html">AccelByte::FApiBase</a></td></tr>
<tr class="memitem:a4ded3338c43197d995d2ce88e3ac85af inherit pro_attribs_class_accel_byte_1_1_f_api_base" id="r_a4ded3338c43197d995d2ce88e3ac85af"><td class="memItemLeft" align="right" valign="top">
TSharedRef&lt; <a class="el" href="../../d0/d90/class_accel_byte_1_1_credentials.html">Credentials</a> const, ESPMode::ThreadSafe &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CredentialsRef</b></td></tr>
<tr class="memitem:ae8ffc36382a4204edb20a6d3430c13ad inherit pro_attribs_class_accel_byte_1_1_f_api_base" id="r_ae8ffc36382a4204edb20a6d3430c13ad"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="../../df/db1/class_accel_byte_1_1_settings.html">Settings</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>SettingsRef</b></td></tr>
<tr class="memitem:a3262dbbbb6404aec16bef79a36480bbf inherit pro_attribs_class_accel_byte_1_1_f_api_base" id="r_a3262dbbbb6404aec16bef79a36480bbf"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="../../df/d3f/class_accel_byte_1_1_f_http_retry_scheduler_base.html">FHttpRetrySchedulerBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>HttpRef</b></td></tr>
<tr class="memitem:afd2ef10eecc71f4d34515276ab6a8fcb inherit pro_attribs_class_accel_byte_1_1_f_api_base" id="r_afd2ef10eecc71f4d34515276ab6a8fcb"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="../../d8/d7e/class_accel_byte_1_1_f_http_client.html">FHttpClient</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HttpClient</b></td></tr>
<tr class="memitem:af48fc7e07daa90601940b0bbaeaca4a9 inherit pro_attribs_class_accel_byte_1_1_f_api_base" id="r_af48fc7e07daa90601940b0bbaeaca4a9"><td class="memItemLeft" align="right" valign="top">
FAccelBytePlatformPtr&#160;</td><td class="memItemRight" valign="bottom"><b>AccelBytePlatformPtr</b></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="../../df/dcb/class_accel_byte_1_1_api_1_1_cloud_save.html" title="CloudSave API for storing records.">CloudSave</a> API for storing records. </p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ab42a2e2314adb30b83b33595b3639078" name="ab42a2e2314adb30b83b33595b3639078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42a2e2314adb30b83b33595b3639078">&#9670;&#160;</a></span>BulkGetCurrentPlayerPublicRecordKeys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::BulkGetCurrentPlayerPublicRecordKeys </td>
          <td>(</td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../de/dcf/struct_f_accel_byte_models_paginated_bulk_get_public_user_record_keys_response.html">FAccelByteModelsPaginatedBulkGetPublicUserRecordKeysResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 const &amp;</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 const &amp;</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the public key record for current user in bulk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="../../de/dcf/struct_f_accel_byte_models_paginated_bulk_get_public_user_record_keys_response.html">FAccelByteModelsPaginatedBulkGetPublicUserRecordKeysResponse</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset of the cloudsave result. Default value is 0. </td></tr>
    <tr><td class="paramname">Limit</td><td>The limit of the cloudsave result. Default value is 20.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a68022670e426155da7ee8fba6a5600b2" name="a68022670e426155da7ee8fba6a5600b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68022670e426155da7ee8fba6a5600b2">&#9670;&#160;</a></span>BulkGetGameRecords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::BulkGetGameRecords </td>
          <td>(</td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d8/d3a/struct_f_accel_byte_models_list_game_records.html">FAccelByteModelsListGameRecords</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bulk get game records (arbitrary JSON data) by list of keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Keys</td><td>List Key of record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="../../d8/d3a/struct_f_accel_byte_models_list_game_records.html">FAccelByteModelsListGameRecords</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ad4952d34ba2da5fe259c65a1ea74be17" name="ad4952d34ba2da5fe259c65a1ea74be17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4952d34ba2da5fe259c65a1ea74be17">&#9670;&#160;</a></span>BulkGetOtherPlayerPublicRecordKeys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::BulkGetOtherPlayerPublicRecordKeys </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../de/dcf/struct_f_accel_byte_models_paginated_bulk_get_public_user_record_keys_response.html">FAccelByteModelsPaginatedBulkGetPublicUserRecordKeysResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 const &amp;</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 const &amp;</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the public key record for a user in bulk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td>UserId of the keys owner. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="../../de/dcf/struct_f_accel_byte_models_paginated_bulk_get_public_user_record_keys_response.html">FAccelByteModelsPaginatedBulkGetPublicUserRecordKeysResponse</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset of the cloudsave result. Default value is 0. </td></tr>
    <tr><td class="paramname">Limit</td><td>The limit of the cloudsave result. Default value is 20.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ac29cf8bf5c4c8614fa6e639acd28f128" name="ac29cf8bf5c4c8614fa6e639acd28f128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29cf8bf5c4c8614fa6e639acd28f128">&#9670;&#160;</a></span>BulkGetOtherPlayerPublicRecords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::BulkGetOtherPlayerPublicRecords </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/d1f/struct_f_list_accel_byte_models_user_record.html">FListAccelByteModelsUserRecord</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the public record for a user in bulk using public keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td>UserId of the keys owner. </td></tr>
    <tr><td class="paramname">Keys</td><td>List Key of record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="../../d3/d1f/struct_f_list_accel_byte_models_user_record.html">FListAccelByteModelsUserRecord</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="aa1007f029af8963bc5aa9ae5e482c9ce" name="aa1007f029af8963bc5aa9ae5e482c9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1007f029af8963bc5aa9ae5e482c9ce">&#9670;&#160;</a></span>BulkGetPublicUserRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::BulkGetPublicUserRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>UserIds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/d1f/struct_f_list_accel_byte_models_user_record.html">FListAccelByteModelsUserRecord</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a public record (arbitrary JSON data) by its key and userId in user-level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">UserIds</td><td>List UserId(s) of the record owner. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="../../d9/d4a/struct_f_accel_byte_models_user_record.html">FAccelByteModelsUserRecord</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ad1ba298cb545992e29052610f1bfdbfc" name="ad1ba298cb545992e29052610f1bfdbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ba298cb545992e29052610f1bfdbfc">&#9670;&#160;</a></span>BulkGetUserRecords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::BulkGetUserRecords </td>
          <td>(</td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Keys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/d1f/struct_f_list_accel_byte_models_user_record.html">FListAccelByteModelsUserRecord</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bulk get records (arbitrary JSON data) by list of keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Keys</td><td>List Key of record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="../../d9/d4a/struct_f_accel_byte_models_user_record.html">FAccelByteModelsUserRecord</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a0a576e29b343996ad5c95f151b195469" name="a0a576e29b343996ad5c95f151b195469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a576e29b343996ad5c95f151b195469">&#9670;&#160;</a></span>DeleteGameRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::DeleteGameRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a record under the given key in namespace-level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a22f3714d7ee816858382c7976b91c60e" name="a22f3714d7ee816858382c7976b91c60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f3714d7ee816858382c7976b91c60e">&#9670;&#160;</a></span>DeleteUserRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::DeleteUserRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a record under the given key in user-level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a5f4ccd1fa483b627bc1f13d83975566e" name="a5f4ccd1fa483b627bc1f13d83975566e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4ccd1fa483b627bc1f13d83975566e">&#9670;&#160;</a></span>GetGameRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::GetGameRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d6/d72/struct_f_accel_byte_models_game_record.html">FAccelByteModelsGameRecord</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a record by its key in namespace-level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="../../d6/d72/struct_f_accel_byte_models_game_record.html">FAccelByteModelsGameRecord</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ad524b543f564b65327856a7f78225065" name="ad524b543f564b65327856a7f78225065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad524b543f564b65327856a7f78225065">&#9670;&#160;</a></span>GetPublicUserRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::GetPublicUserRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d9/d4a/struct_f_accel_byte_models_user_record.html">FAccelByteModelsUserRecord</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a public record (arbitrary JSON data) by its key and userId in user-level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">UserId</td><td>UserId of the record owner. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="../../d9/d4a/struct_f_accel_byte_models_user_record.html">FAccelByteModelsUserRecord</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a9106ab608494c6bf61f7b84596dc3b41" name="a9106ab608494c6bf61f7b84596dc3b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9106ab608494c6bf61f7b84596dc3b41">&#9670;&#160;</a></span>GetUserRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::GetUserRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d9/d4a/struct_f_accel_byte_models_user_record.html">FAccelByteModelsUserRecord</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a record (arbitrary JSON data) by its key in user-level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="../../d9/d4a/struct_f_accel_byte_models_user_record.html">FAccelByteModelsUserRecord</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a1a8e006f96fa423205565244d5ddff92" name="a1a8e006f96fa423205565244d5ddff92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8e006f96fa423205565244d5ddff92">&#9670;&#160;</a></span>ReplaceGameRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::ReplaceGameRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObject</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in namespace-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a9872316f5cac56e3e481f7c5b4de8e09" name="a9872316f5cac56e3e481f7c5b4de8e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9872316f5cac56e3e481f7c5b4de8e09">&#9670;&#160;</a></span>ReplaceGameRecordCheckLatest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::ReplaceGameRecordCheckLatest </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDateTime const</td>          <td class="paramname"><span class="paramname"><em>LastUpdated</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObjectWrapper</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in namespace-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one, but will failed if lastUpdated is not up-to-date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">LastUpdated</td><td>last time the record is updated. Retrieve it from GetGameRecord. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a5c79775f9765761e270c217d828bfd5e" name="a5c79775f9765761e270c217d828bfd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c79775f9765761e270c217d828bfd5e">&#9670;&#160;</a></span>ReplaceGameRecordCheckLatest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::ReplaceGameRecordCheckLatest </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>TryAttempt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObjectWrapper</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandlerPayloadModifier&lt; FJsonObjectWrapper, FJsonObjectWrapper &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>PayloadModifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in namespace-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. Beware: Function will try to get the latest value, put it in the custom modifier and request to replace the record. will retry it again when the record is updated by other user, until exhaust all the attempt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TryAttempt</td><td>Attempt to try to replace the game record. </td></tr>
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">PayloadModifier</td><td>Function to modify the latest record value with your customized modifier. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="aef797789ec84aa593145418b158741bc" name="aef797789ec84aa593145418b158741bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef797789ec84aa593145418b158741bc">&#9670;&#160;</a></span>ReplaceUserRecord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::ReplaceUserRecord </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bSetPublic</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FJsonObject &amp;</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FVoidHandler &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FErrorHandler &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">SetPublic</td><td>Metadata is_public value and set by client </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a3877809323ff5cb935cc31c5ca0d245b" name="a3877809323ff5cb935cc31c5ca0d245b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3877809323ff5cb935cc31c5ca0d245b">&#9670;&#160;</a></span>ReplaceUserRecord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::ReplaceUserRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObject</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>IsPublic</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. </p>
<p>The end point of this method if bIsPublic is true (using suffix /public) will be deprecated in future <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">IsPublic</td><td>Save the record as a public/private record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="aa0a3d210c18e9c981517904ab8eb5b5b" name="aa0a3d210c18e9c981517904ab8eb5b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a3d210c18e9c981517904ab8eb5b5b">&#9670;&#160;</a></span>ReplaceUserRecordCheckLatest() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::ReplaceUserRecordCheckLatest </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDateTime const</td>          <td class="paramname"><span class="paramname"><em>LastUpdated</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObjectWrapper</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one, but will failed if lastUpdated is not up-to-date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">LastUpdated</td><td>last time the record is updated. Retrieve it from GetGameRecord. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a3c299cc6b5c9a3f0cdec563b02934345" name="a3c299cc6b5c9a3f0cdec563b02934345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c299cc6b5c9a3f0cdec563b02934345">&#9670;&#160;</a></span>ReplaceUserRecordCheckLatest() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::ReplaceUserRecordCheckLatest </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDateTime</td>          <td class="paramname"><span class="paramname"><em>LastUpdated</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObjectWrapper</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/dc9/struct_f_accel_byte_models_replace_user_record_response.html">FAccelByteModelsReplaceUserRecordResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one, but will failed if lastUpdated is not up-to-date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">LastUpdated</td><td>last time the record is updated. Retrieve it from GetGameRecord. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="../../d3/dc9/struct_f_accel_byte_models_replace_user_record_response.html">FAccelByteModelsReplaceUserRecordResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ae220c0a7de98cb44ab1b77cb9ee221a0" name="ae220c0a7de98cb44ab1b77cb9ee221a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae220c0a7de98cb44ab1b77cb9ee221a0">&#9670;&#160;</a></span>ReplaceUserRecordCheckLatest() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::ReplaceUserRecordCheckLatest </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>TryAttempt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObjectWrapper</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandlerPayloadModifier&lt; FJsonObjectWrapper, FJsonObjectWrapper &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>PayloadModifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. Beware: Function will try to get the latest value, put it in the custom modifier and request to replace the record. will retry it again when the record is updated by other user, until exhaust all the attempt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TryAttempt</td><td>Attempt to try to replace the game record. </td></tr>
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">PayloadModifier</td><td>Function to modify the latest record value with your customized modifier. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a5e509fb5e4a8965616cfc04b89e53bb8" name="a5e509fb5e4a8965616cfc04b89e53bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e509fb5e4a8965616cfc04b89e53bb8">&#9670;&#160;</a></span>ReplaceUserRecordCheckLatest() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::ReplaceUserRecordCheckLatest </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>TryAttempt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObjectWrapper</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandlerPayloadModifier&lt; FJsonObjectWrapper, FJsonObjectWrapper &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>PayloadModifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/dc9/struct_f_accel_byte_models_replace_user_record_response.html">FAccelByteModelsReplaceUserRecordResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. Beware: Function will try to get the latest value, put it in the custom modifier and request to replace the record. will retry it again when the record is updated by other user, until exhaust all the attempt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TryAttempt</td><td>Attempt to try to replace the game record. </td></tr>
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">PayloadModifier</td><td>Function to modify the latest record value with your customized modifier. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="../../d3/dc9/struct_f_accel_byte_models_replace_user_record_response.html">FAccelByteModelsReplaceUserRecordResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a9908cc394566385e962f271e8f4f156e" name="a9908cc394566385e962f271e8f4f156e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9908cc394566385e962f271e8f4f156e">&#9670;&#160;</a></span>SaveGameRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::SaveGameRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObject</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a namespace-level record. If the record doesn't exist, it will create and save the record, if already exists, it will append to the existing one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a40df3f82999248b942263e345369373a" name="a40df3f82999248b942263e345369373a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40df3f82999248b942263e345369373a">&#9670;&#160;</a></span>SaveUserRecord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::SaveUserRecord </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bSetPublic</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FJsonObject &amp;</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FVoidHandler &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FErrorHandler &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a user-level record with Metadata input value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">SetPublic</td><td>Metadata is_public value and set by client </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a8d5b5119bc48cae4dd33f030d28b4328" name="a8d5b5119bc48cae4dd33f030d28b4328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5b5119bc48cae4dd33f030d28b4328">&#9670;&#160;</a></span>SaveUserRecord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::CloudSave::SaveUserRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObject</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>IsPublic</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a user-level record. If the record doesn't exist, it will create and save the record, if already exists, it will append to the existing one. </p>
<p>The end point of this method if bIsPublic is true (using suffix /public) will be deprecated in future <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">IsPublic</td><td>Save the record as a public/private record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
