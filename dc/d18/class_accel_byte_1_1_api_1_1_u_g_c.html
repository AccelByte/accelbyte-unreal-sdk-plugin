<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langcode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AccelByte Unreal SDK: AccelByte::Api::UGC Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-logo.css" rel="stylesheet" type="text/css"/>
    <style>
        #top-header-logo {
            height: auto;
        }
        #top-header-logo img {
            height: 40px;
            width: auto;
        }
        #searcharea {
            padding-right: 10px;
        }
    </style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="top-header-logo">
        <img alt="AccelByte Unreal SDK" src="../../AccelByte Main Logo - Horizontal.svg"/>
    </div>
    <div id="searcharea">
                <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
    </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dc/d18/class_accel_byte_1_1_api_1_1_u_g_c.html','../../','d0/d81/class_accel_byte_1_1_api_1_1_u_g_c-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">AccelByte::Api::UGC Class Reference<div class="ingroups"><a class="el" href="../../d8/db3/group___client_a_p_i.html">Client API</a> &raquo; <a class="el" href="../../d7/d33/group___cloud_save.html">Cloud Save &amp; Storage</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Provide APIs to access <a class="el" href="../../dc/d18/class_accel_byte_1_1_api_1_1_u_g_c.html" title="Provide APIs to access UGC service.">UGC</a> service.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d4/d7b/_accel_byte_u_g_c_api_8h_source.html">AccelByteUGCApi.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Inheritance diagram for AccelByte::Api::UGC:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="../../dc/d18/class_accel_byte_1_1_api_1_1_u_g_c.png" usemap="#AccelByte_3A_3AApi_3A_3AUGC_map" alt=""/>
  <map id="AccelByte_3A_3AApi_3A_3AUGC_map" name="AccelByte_3A_3AApi_3A_3AUGC_map">
<area href="../../d3/dd3/class_accel_byte_1_1_f_api_base.html" alt="AccelByte::FApiBase" shape="rect" coords="0,0,299,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a86faaef405b04e08cb1388fbfb8f3267" id="r_a86faaef405b04e08cb1388fbfb8f3267"><td class="memItemLeft" align="right" valign="top"><a id="a86faaef405b04e08cb1388fbfb8f3267" name="a86faaef405b04e08cb1388fbfb8f3267"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UGC</b> (<a class="el" href="../../d0/d90/class_accel_byte_1_1_credentials.html">Credentials</a> const &amp;InCredentialsRef, <a class="el" href="../../df/db1/class_accel_byte_1_1_settings.html">Settings</a> const &amp;InSettingsRef, <a class="el" href="../../df/d3f/class_accel_byte_1_1_f_http_retry_scheduler_base.html">FHttpRetrySchedulerBase</a> &amp;InHttpRef, TSharedPtr&lt; <a class="el" href="../../d9/d63/class_accel_byte_1_1_f_api_client.html">AccelByte::FApiClient</a>, ESPMode::ThreadSafe &gt; const &amp;InApiClient=nullptr)</td></tr>
<tr class="memitem:a8f17339d8b258a54af718a5f78741b30" id="r_a8f17339d8b258a54af718a5f78741b30"><td class="memItemLeft" align="right" valign="top"><a id="a8f17339d8b258a54af718a5f78741b30" name="a8f17339d8b258a54af718a5f78741b30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UGC</b> (<a class="el" href="../../d0/d90/class_accel_byte_1_1_credentials.html">Credentials</a> const &amp;InCredentialsRef, <a class="el" href="../../df/db1/class_accel_byte_1_1_settings.html">Settings</a> const &amp;InSettingsRef, <a class="el" href="../../df/d3f/class_accel_byte_1_1_f_http_retry_scheduler_base.html">FHttpRetrySchedulerBase</a> &amp;InHttpRef, FAccelBytePlatformPtr const &amp;InAccelBytePlatform)</td></tr>
<tr class="memitem:a616f403e2b4373ff051a39bf126071ed" id="r_a616f403e2b4373ff051a39bf126071ed"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a616f403e2b4373ff051a39bf126071ed">CreateContent</a> (FString const &amp;ChannelId, <a class="el" href="../../db/d10/struct_f_accel_byte_models_u_g_c_request.html">FAccelByteModelsUGCRequest</a> const &amp;UGCRequest, THandler&lt; <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a616f403e2b4373ff051a39bf126071ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a content with FString preview and get the payload url to upload the content.  <br /></td></tr>
<tr class="memitem:a7753cb83f944423eda883c1a8ccd19cd" id="r_a7753cb83f944423eda883c1a8ccd19cd"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7753cb83f944423eda883c1a8ccd19cd">CreateContent</a> (FString const &amp;ChannelId, FString const &amp;Name, FString const &amp;Type, FString const &amp;SubType, TArray&lt; FString &gt; const &amp;Tags, TArray&lt; uint8 &gt; const &amp;Preview, FString const &amp;FileExtension, THandler&lt; <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, FString const &amp;ContentType=TEXT(&quot;application/octet-stream&quot;))</td></tr>
<tr class="memdesc:a7753cb83f944423eda883c1a8ccd19cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a content with TArray&lt;uint8&gt; Preview parameter and get the payload url to upload the content.  <br /></td></tr>
<tr class="memitem:a3f1b286b162dfbe41e244e8ac10c3230" id="r_a3f1b286b162dfbe41e244e8ac10c3230"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f1b286b162dfbe41e244e8ac10c3230">ModifyContent</a> (FString const &amp;ChannelId, FString const &amp;ContentId, <a class="el" href="../../d4/d26/struct_f_accel_byte_models_u_g_c_update_request.html">FAccelByteModelsUGCUpdateRequest</a> const &amp;ModifyRequest, THandler&lt; <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a3f1b286b162dfbe41e244e8ac10c3230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify existing content to update some information with FString preview.  <br /></td></tr>
<tr class="memitem:ac0609f18c934b75fb2a4984aa927084b" id="r_ac0609f18c934b75fb2a4984aa927084b"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0609f18c934b75fb2a4984aa927084b">ModifyContent</a> (FString const &amp;ChannelId, FString const &amp;ContentId, <a class="el" href="../../db/d10/struct_f_accel_byte_models_u_g_c_request.html">FAccelByteModelsUGCRequest</a> const &amp;UGCRequest, THandler&lt; <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, bool bUpdateContent=false)</td></tr>
<tr class="memdesc:ac0609f18c934b75fb2a4984aa927084b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify existing content to update some information with FString preview.  <br /></td></tr>
<tr class="memitem:a126756cba75ad6d5125687ce08b472d6" id="r_a126756cba75ad6d5125687ce08b472d6"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a126756cba75ad6d5125687ce08b472d6">ModifyContent</a> (FString const &amp;ChannelId, FString const &amp;ContentId, FString const &amp;Name, FString const &amp;Type, FString const &amp;SubType, TArray&lt; FString &gt; const &amp;Tags, TArray&lt; uint8 &gt; const &amp;Preview, FString const &amp;FileExtension, THandler&lt; <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, FString const &amp;ContentType=TEXT(&quot;application/octet-stream&quot;), bool bUpdateContent=false)</td></tr>
<tr class="memdesc:a126756cba75ad6d5125687ce08b472d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify existing content to update some information with TArray&lt;uint8&gt; Preview parameter.  <br /></td></tr>
<tr class="memitem:a50dee08a959c003dd362706d3b208e88" id="r_a50dee08a959c003dd362706d3b208e88"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50dee08a959c003dd362706d3b208e88">DeleteContent</a> (FString const &amp;ChannelId, FString const &amp;ContentId, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a50dee08a959c003dd362706d3b208e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a content based on the its channel id and content id.  <br /></td></tr>
<tr class="memitem:a2c6a6914e1038d8ed4c52646c1367a17" id="r_a2c6a6914e1038d8ed4c52646c1367a17"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c6a6914e1038d8ed4c52646c1367a17">GetContentByContentId</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a2c6a6914e1038d8ed4c52646c1367a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its content id.  <br /></td></tr>
<tr class="memitem:a3069bab96bbd1f5a97cba562c3513dce" id="r_a3069bab96bbd1f5a97cba562c3513dce"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3069bab96bbd1f5a97cba562c3513dce">PublicGetContentByContentId</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a3069bab96bbd1f5a97cba562c3513dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its content id. Can be used without logged in.  <br /></td></tr>
<tr class="memitem:a2d33217bd856b7fcd04fe6a7c5faf879" id="r_a2d33217bd856b7fcd04fe6a7c5faf879"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d33217bd856b7fcd04fe6a7c5faf879">GetContentByShareCode</a> (FString const &amp;ShareCode, THandler&lt; <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a2d33217bd856b7fcd04fe6a7c5faf879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its share code.  <br /></td></tr>
<tr class="memitem:aa3d1c8f8ea4ec222c2deb77fc846f347" id="r_aa3d1c8f8ea4ec222c2deb77fc846f347"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3d1c8f8ea4ec222c2deb77fc846f347">PublicGetContentByShareCode</a> (FString const &amp;ShareCode, THandler&lt; <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:aa3d1c8f8ea4ec222c2deb77fc846f347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its share code. Can be used without logged in.  <br /></td></tr>
<tr class="memitem:a0fb40c37032b411e7a4d3c0cfb2863d9" id="r_a0fb40c37032b411e7a4d3c0cfb2863d9"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fb40c37032b411e7a4d3c0cfb2863d9">GetContentPreview</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="../../dc/dca/struct_f_accel_byte_models_u_g_c_preview.html">FAccelByteModelsUGCPreview</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a0fb40c37032b411e7a4d3c0cfb2863d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get content Preview as <a class="el" href="../../dc/dca/struct_f_accel_byte_models_u_g_c_preview.html">FAccelByteModelsUGCPreview</a>.  <br /></td></tr>
<tr class="memitem:ae94eafa26e0c09af1dd1a37a2d663351" id="r_ae94eafa26e0c09af1dd1a37a2d663351"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae94eafa26e0c09af1dd1a37a2d663351">GetContentPreview</a> (FString const &amp;ContentId, THandler&lt; TArray&lt; uint8 &gt; &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ae94eafa26e0c09af1dd1a37a2d663351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get content preview as TArray&lt;uint8&gt;.  <br /></td></tr>
<tr class="memitem:a5788eaac16bef7471465d5658e8dfb71" id="r_a5788eaac16bef7471465d5658e8dfb71"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5788eaac16bef7471465d5658e8dfb71">GetTags</a> (THandler&lt; <a class="el" href="../../db/dba/struct_f_accel_byte_models_u_g_c_tags_paging_response.html">FAccelByteModelsUGCTagsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:a5788eaac16bef7471465d5658e8dfb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all tags.  <br /></td></tr>
<tr class="memitem:acbeec7e4be7f4279d426ae38ea393d5b" id="r_acbeec7e4be7f4279d426ae38ea393d5b"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbeec7e4be7f4279d426ae38ea393d5b">GetTypes</a> (THandler&lt; <a class="el" href="../../d1/d8e/struct_f_accel_byte_models_u_g_c_types_paging_response.html">FAccelByteModelsUGCTypesPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:acbeec7e4be7f4279d426ae38ea393d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all types and subtypes.  <br /></td></tr>
<tr class="memitem:a5dc2a3b48a47d37c28e9dfeba3282450" id="r_a5dc2a3b48a47d37c28e9dfeba3282450"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dc2a3b48a47d37c28e9dfeba3282450">CreateChannel</a> (FString const &amp;ChannelName, THandler&lt; <a class="el" href="../../d3/dc9/struct_f_accel_byte_models_u_g_c_channel_response.html">FAccelByteModelsUGCChannelResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a5dc2a3b48a47d37c28e9dfeba3282450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a player's channel with specific channel name.  <br /></td></tr>
<tr class="memitem:a1887583a2adc10b741b9280f05219a46" id="r_a1887583a2adc10b741b9280f05219a46"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1887583a2adc10b741b9280f05219a46">UpdateChannel</a> (FString const &amp;ChannelId, FString const &amp;ChannelName, THandler&lt; <a class="el" href="../../d3/dc9/struct_f_accel_byte_models_u_g_c_channel_response.html">FAccelByteModelsUGCChannelResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a1887583a2adc10b741b9280f05219a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a player's channel with specific channel name.  <br /></td></tr>
<tr class="memitem:a697a7df678ae2b04e0a309a0830c04c5" id="r_a697a7df678ae2b04e0a309a0830c04c5"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a697a7df678ae2b04e0a309a0830c04c5">GetChannels</a> (THandler&lt; <a class="el" href="../../d1/d54/struct_f_accel_byte_models_u_g_c_channels_paging_response.html">FAccelByteModelsUGCChannelsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0, FString const &amp;ChannelName=&quot;&quot;)</td></tr>
<tr class="memdesc:a697a7df678ae2b04e0a309a0830c04c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all of the player's channels.  <br /></td></tr>
<tr class="memitem:a2cae34d14d317d01eb1cbdabc774e4ef" id="r_a2cae34d14d317d01eb1cbdabc774e4ef"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cae34d14d317d01eb1cbdabc774e4ef">GetChannels</a> (FString const &amp;UserId, THandler&lt; <a class="el" href="../../d1/d54/struct_f_accel_byte_models_u_g_c_channels_paging_response.html">FAccelByteModelsUGCChannelsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0, FString const &amp;ChannelName=&quot;&quot;)</td></tr>
<tr class="memdesc:a2cae34d14d317d01eb1cbdabc774e4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all of the player's channels.  <br /></td></tr>
<tr class="memitem:a6f66e8b4a6e8a557f25b7ed514b9d818" id="r_a6f66e8b4a6e8a557f25b7ed514b9d818"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f66e8b4a6e8a557f25b7ed514b9d818">DeleteChannel</a> (FString const &amp;ChannelId, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a6f66e8b4a6e8a557f25b7ed514b9d818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a player's channel based on the its channel id.  <br /></td></tr>
<tr class="memitem:ac4d7c841990b76ef6b6445dfe8dc6c1c" id="r_ac4d7c841990b76ef6b6445dfe8dc6c1c"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4d7c841990b76ef6b6445dfe8dc6c1c">SearchContents</a> (FString const &amp;Name, FString const &amp;Creator, FString const &amp;Type, FString const &amp;Subtype, TArray&lt; FString &gt; const &amp;Tags, bool IsOfficial, FString const &amp;UserId, THandler&lt; <a class="el" href="../../d3/d71/struct_f_accel_byte_models_u_g_c_search_contents_paging_response.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, EAccelByteUgcSortBy SortBy=EAccelByteUgcSortBy::DATE, EAccelByteUgcOrderBy OrderBy=EAccelByteUgcOrderBy::DESC, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:ac4d7c841990b76ef6b6445dfe8dc6c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search specific contents based on the given filter.  <br /></td></tr>
<tr class="memitem:a5c01de9f924be5ce5413f3321e22ff59" id="r_a5c01de9f924be5ce5413f3321e22ff59"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c01de9f924be5ce5413f3321e22ff59">SearchContents</a> (<a class="el" href="../../df/de7/struct_f_accel_byte_models_u_g_c_search_contents_request.html">FAccelByteModelsUGCSearchContentsRequest</a> const &amp;Request, THandler&lt; <a class="el" href="../../d3/d71/struct_f_accel_byte_models_u_g_c_search_contents_paging_response.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0)</td></tr>
<tr class="memdesc:a5c01de9f924be5ce5413f3321e22ff59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search specific contents based on the given filter.  <br /></td></tr>
<tr class="memitem:af84e26abd94b7f62627f39faa2da3ae2" id="r_af84e26abd94b7f62627f39faa2da3ae2"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af84e26abd94b7f62627f39faa2da3ae2">PublicSearchContents</a> (FString const &amp;Name, FString const &amp;Creator, FString const &amp;Type, FString const &amp;Subtype, TArray&lt; FString &gt; const &amp;Tags, bool IsOfficial, FString const &amp;UserId, THandler&lt; <a class="el" href="../../d3/d71/struct_f_accel_byte_models_u_g_c_search_contents_paging_response.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, EAccelByteUgcSortBy SortBy=EAccelByteUgcSortBy::DATE, EAccelByteUgcOrderBy OrderBy=EAccelByteUgcOrderBy::DESC, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:af84e26abd94b7f62627f39faa2da3ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search specific contents based on the given filter. Can be used without logged in.  <br /></td></tr>
<tr class="memitem:afd14f87c9ae02b5d6e6ec43e837c919d" id="r_afd14f87c9ae02b5d6e6ec43e837c919d"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd14f87c9ae02b5d6e6ec43e837c919d">PublicSearchContents</a> (<a class="el" href="../../df/de7/struct_f_accel_byte_models_u_g_c_search_contents_request.html">FAccelByteModelsUGCSearchContentsRequest</a> const &amp;Request, THandler&lt; <a class="el" href="../../d3/d71/struct_f_accel_byte_models_u_g_c_search_contents_paging_response.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0)</td></tr>
<tr class="memdesc:afd14f87c9ae02b5d6e6ec43e837c919d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search specific contents based on the given filter. Can be used without logged in.  <br /></td></tr>
<tr class="memitem:a65e9aed5a33a0fe15406abbe1c36651d" id="r_a65e9aed5a33a0fe15406abbe1c36651d"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65e9aed5a33a0fe15406abbe1c36651d">UpdateLikeStatusToContent</a> (FString const &amp;ContentId, bool bLikeStatus, THandler&lt; <a class="el" href="../../d2/d66/struct_f_accel_byte_models_u_g_c_update_like_status_to_content_response.html">FAccelByteModelsUGCUpdateLikeStatusToContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a65e9aed5a33a0fe15406abbe1c36651d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update like/unlike status to a content.  <br /></td></tr>
<tr class="memitem:a457d769a6cfcf29b32c542bec39e6b5d" id="r_a457d769a6cfcf29b32c542bec39e6b5d"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a457d769a6cfcf29b32c542bec39e6b5d">GetListFollowers</a> (FString const &amp;UserId, THandler&lt; <a class="el" href="../../d7/da0/struct_f_accel_byte_models_u_g_c_get_list_followers_paging_response.html">FAccelByteModelsUGCGetListFollowersPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:a457d769a6cfcf29b32c542bec39e6b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of followers.  <br /></td></tr>
<tr class="memitem:a001d433e9001ec490b30d6d5c25d723f" id="r_a001d433e9001ec490b30d6d5c25d723f"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a001d433e9001ec490b30d6d5c25d723f">UpdateFollowStatusToUser</a> (FString const &amp;UserId, bool bFollowStatus, THandler&lt; <a class="el" href="../../d2/dc6/struct_f_accel_byte_models_u_g_c_update_follow_status_to_user_response.html">FAccelByteModelsUGCUpdateFollowStatusToUserResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a001d433e9001ec490b30d6d5c25d723f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update follow/unfollow status to a user.  <br /></td></tr>
<tr class="memitem:a66d04e3e0daee390582322ecd41066fb" id="r_a66d04e3e0daee390582322ecd41066fb"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66d04e3e0daee390582322ecd41066fb">SearchContentsSpecificToChannel</a> (FString const &amp;ChannelId, FString const &amp;Name, FString const &amp;Creator, FString const &amp;Type, FString const &amp;Subtype, TArray&lt; FString &gt; const &amp;Tags, bool IsOfficial, FString const &amp;UserId, THandler&lt; <a class="el" href="../../d3/d71/struct_f_accel_byte_models_u_g_c_search_contents_paging_response.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, EAccelByteUgcSortBy SortBy=EAccelByteUgcSortBy::DATE, EAccelByteUgcOrderBy OrderBy=EAccelByteUgcOrderBy::DESC, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:a66d04e3e0daee390582322ecd41066fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search contents specific to a channel.  <br /></td></tr>
<tr class="memitem:a68e7e5a6bbbc77424c5b198c56ad5d32" id="r_a68e7e5a6bbbc77424c5b198c56ad5d32"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68e7e5a6bbbc77424c5b198c56ad5d32">SearchContentsSpecificToChannel</a> (FString const &amp;ChannelId, <a class="el" href="../../df/de7/struct_f_accel_byte_models_u_g_c_search_contents_request.html">FAccelByteModelsUGCSearchContentsRequest</a> const &amp;Request, THandler&lt; <a class="el" href="../../d3/d71/struct_f_accel_byte_models_u_g_c_search_contents_paging_response.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0)</td></tr>
<tr class="memdesc:a68e7e5a6bbbc77424c5b198c56ad5d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search contents specific to a channel.  <br /></td></tr>
<tr class="memitem:aa787be41f543748528f7f98cab6e0fe2" id="r_aa787be41f543748528f7f98cab6e0fe2"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa787be41f543748528f7f98cab6e0fe2">GetContentBulk</a> (TArray&lt; FString &gt; const &amp;ContentIds, THandler&lt; TArray&lt; <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a> &gt; &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:aa787be41f543748528f7f98cab6e0fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents by content Ids.  <br /></td></tr>
<tr class="memitem:a6e67168f46aee9dd1ced5a6b19b0675e" id="r_a6e67168f46aee9dd1ced5a6b19b0675e"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e67168f46aee9dd1ced5a6b19b0675e">PublicGetContentBulk</a> (TArray&lt; FString &gt; const &amp;ContentIds, THandler&lt; TArray&lt; <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a> &gt; &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a6e67168f46aee9dd1ced5a6b19b0675e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents by content Ids. Can be used without logged in.  <br /></td></tr>
<tr class="memitem:a6ead218bf767e2f7a208bc244d75aba6" id="r_a6ead218bf767e2f7a208bc244d75aba6"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ead218bf767e2f7a208bc244d75aba6">GetUserContent</a> (FString const &amp;UserId, THandler&lt; <a class="el" href="../../d6/dd3/struct_f_accel_byte_models_u_g_c_content_page_response.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:a6ead218bf767e2f7a208bc244d75aba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get user's generated contents.  <br /></td></tr>
<tr class="memitem:abe3b73ce78c6bbc0b4c48a2938bf422c" id="r_abe3b73ce78c6bbc0b4c48a2938bf422c"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe3b73ce78c6bbc0b4c48a2938bf422c">PublicGetUserContent</a> (FString const &amp;UserId, THandler&lt; <a class="el" href="../../d6/dd3/struct_f_accel_byte_models_u_g_c_content_page_response.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:abe3b73ce78c6bbc0b4c48a2938bf422c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get user's generated contents. Can be used without logged in.  <br /></td></tr>
<tr class="memitem:a1c9f502108107d3a53d58b3f18c7e644" id="r_a1c9f502108107d3a53d58b3f18c7e644"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c9f502108107d3a53d58b3f18c7e644">UploadContentScreenshot</a> (FString const &amp;ContentId, FString const &amp;UserId, <a class="el" href="../../d4/dc4/struct_f_accel_byte_models_u_g_c_screenshots_request.html">FAccelByteModelsUGCScreenshotsRequest</a> ScreenshotsRequest, THandler&lt; <a class="el" href="../../dc/d1a/struct_f_accel_byte_models_u_g_c_update_content_screenshot_response.html">FAccelByteModelsUGCUpdateContentScreenshotResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a1c9f502108107d3a53d58b3f18c7e644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload screenshots for content.  <br /></td></tr>
<tr class="memitem:a3516c9236dd35c4257ccc19b48920b8f" id="r_a3516c9236dd35c4257ccc19b48920b8f"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3516c9236dd35c4257ccc19b48920b8f">GetFollowedContent</a> (THandler&lt; <a class="el" href="../../d6/dd3/struct_f_accel_byte_models_u_g_c_content_page_response.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:a3516c9236dd35c4257ccc19b48920b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents from followed creators.  <br /></td></tr>
<tr class="memitem:ad5b708f2ef8b9af6f6221609cf6c6ab6" id="r_ad5b708f2ef8b9af6f6221609cf6c6ab6"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5b708f2ef8b9af6f6221609cf6c6ab6">GetFollowedUsers</a> (THandler&lt; <a class="el" href="../../d5/dbb/struct_f_accel_byte_models_u_g_c_followed_users_response.html">FAccelByteModelsUGCFollowedUsersResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:ad5b708f2ef8b9af6f6221609cf6c6ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get followed creators.  <br /></td></tr>
<tr class="memitem:aeb2a223652dc0cb9d6d4a5caad3023e0" id="r_aeb2a223652dc0cb9d6d4a5caad3023e0"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb2a223652dc0cb9d6d4a5caad3023e0">GetLikedContent</a> (TArray&lt; FString &gt; const &amp;Tags, FString const &amp;Name, FString const &amp;Type, FString const &amp;Subtype, bool IsOfficial, THandler&lt; <a class="el" href="../../d6/dd3/struct_f_accel_byte_models_u_g_c_content_page_response.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0, EAccelByteUgcSortBy SortBy=EAccelByteUgcSortBy::DATE, EAccelByteUgcOrderBy OrderBy=EAccelByteUgcOrderBy::DESC)</td></tr>
<tr class="memdesc:aeb2a223652dc0cb9d6d4a5caad3023e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get liked contents.  <br /></td></tr>
<tr class="memitem:ac01b21c7eeab3e16e484b295072c1154" id="r_ac01b21c7eeab3e16e484b295072c1154"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac01b21c7eeab3e16e484b295072c1154">GetLikedContent</a> (TArray&lt; FString &gt; const &amp;Tags, FString const &amp;Name, FString const &amp;Type, FString const &amp;Subtype, bool IsOfficial, THandler&lt; <a class="el" href="../../d6/dd3/struct_f_accel_byte_models_u_g_c_content_page_response.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0, EAccelByteLikedContentSortBy SortBy=EAccelByteLikedContentSortBy::DATE, EAccelByteUgcOrderBy OrderBy=EAccelByteUgcOrderBy::DESC)</td></tr>
<tr class="memdesc:ac01b21c7eeab3e16e484b295072c1154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get liked contents.  <br /></td></tr>
<tr class="memitem:a81b8dcb07c6dee3d4e7ae89849ac6b32" id="r_a81b8dcb07c6dee3d4e7ae89849ac6b32"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81b8dcb07c6dee3d4e7ae89849ac6b32">GetCreator</a> (FString const &amp;UserId, THandler&lt; <a class="el" href="../../d2/daa/struct_f_accel_byte_models_u_g_c_get_list_followers_response.html">FAccelByteModelsUGCGetListFollowersResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a81b8dcb07c6dee3d4e7ae89849ac6b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get creator stats: number of total like by other user, number of total following and follower user.  <br /></td></tr>
<tr class="memitem:a1b76e95bbe9bc48f75ab39a9998cd184" id="r_a1b76e95bbe9bc48f75ab39a9998cd184"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b76e95bbe9bc48f75ab39a9998cd184">GetGroups</a> (FString const &amp;UserId, THandler&lt; <a class="el" href="../../d3/df8/struct_f_accel_byte_models_u_g_c_get_groups_response.html">FAccelByteModelsUGCGetGroupsResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:a1b76e95bbe9bc48f75ab39a9998cd184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all user groups.  <br /></td></tr>
<tr class="memitem:a35ecd76c49f3a3cc8751d231e932f2ae" id="r_a35ecd76c49f3a3cc8751d231e932f2ae"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35ecd76c49f3a3cc8751d231e932f2ae">BulkGetContentByShareCode</a> (TArray&lt; FString &gt; const &amp;ShareCodes, THandler&lt; TArray&lt; <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a> &gt; &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a35ecd76c49f3a3cc8751d231e932f2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk Get contents by ShareCodes.  <br /></td></tr>
<tr class="memitem:a250a39897cc58a0764b06c8e22fcaeef" id="r_a250a39897cc58a0764b06c8e22fcaeef"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a250a39897cc58a0764b06c8e22fcaeef">SearchContentsSpecificToChannelV2</a> (FString const &amp;ChannelId, THandler&lt; <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteUGCContentUtilitiesSortByV2 SortBy=EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:a250a39897cc58a0764b06c8e22fcaeef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search contents specific to a channel.  <br /></td></tr>
<tr class="memitem:a2825533e3d2f26c108abe05cfd66e709" id="r_a2825533e3d2f26c108abe05cfd66e709"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2825533e3d2f26c108abe05cfd66e709">PublicSearchContentsSpecificToChannelV2</a> (FString const &amp;ChannelId, THandler&lt; <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteUGCContentUtilitiesSortByV2 SortBy=EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:a2825533e3d2f26c108abe05cfd66e709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search contents specific to a channel. Can be used without logged in.  <br /></td></tr>
<tr class="memitem:a852be2138aa2fb3dd112ae844b7ea98a" id="r_a852be2138aa2fb3dd112ae844b7ea98a"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a852be2138aa2fb3dd112ae844b7ea98a">SearchContentsV2</a> (<a class="el" href="../../d9/de2/struct_f_accel_byte_models_u_g_c_filter_request_v2.html">FAccelByteModelsUGCFilterRequestV2</a> const &amp;Filter, THandler&lt; <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteUGCContentSortByV2 SortBy=EAccelByteUGCContentSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:a852be2138aa2fb3dd112ae844b7ea98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all contents in current namespace.  <br /></td></tr>
<tr class="memitem:ac342ee5673f01adad3bdf4adaf27f766" id="r_ac342ee5673f01adad3bdf4adaf27f766"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac342ee5673f01adad3bdf4adaf27f766">PublicSearchContentsV2</a> (<a class="el" href="../../d9/de2/struct_f_accel_byte_models_u_g_c_filter_request_v2.html">FAccelByteModelsUGCFilterRequestV2</a> const &amp;Filter, THandler&lt; <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteUGCContentSortByV2 SortBy=EAccelByteUGCContentSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:ac342ee5673f01adad3bdf4adaf27f766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all contents in current namespace. Can be used without logged in.  <br /></td></tr>
<tr class="memitem:ac61eab66c59a758056d3c8155bdc2641" id="r_ac61eab66c59a758056d3c8155bdc2641"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac61eab66c59a758056d3c8155bdc2641">GetContentBulkByIdsV2</a> (TArray&lt; FString &gt; const &amp;ContentIds, THandler&lt; TArray&lt; <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ac61eab66c59a758056d3c8155bdc2641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents by content Ids.  <br /></td></tr>
<tr class="memitem:a84437d772e65a62cf7b8a651a4e39174" id="r_a84437d772e65a62cf7b8a651a4e39174"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84437d772e65a62cf7b8a651a4e39174">PublicGetContentBulkByIdsV2</a> (TArray&lt; FString &gt; const &amp;ContentIds, THandler&lt; TArray&lt; <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a84437d772e65a62cf7b8a651a4e39174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents by content Ids. Can be used without logged in.  <br /></td></tr>
<tr class="memitem:a30b5e7cd53aeedc176d052fa120a51f3" id="r_a30b5e7cd53aeedc176d052fa120a51f3"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30b5e7cd53aeedc176d052fa120a51f3">GetContentByShareCodeV2</a> (FString const &amp;ShareCode, THandler&lt; <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a30b5e7cd53aeedc176d052fa120a51f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its share code.  <br /></td></tr>
<tr class="memitem:a2d3ac29d46453a415d0e07d0ccc7c3f4" id="r_a2d3ac29d46453a415d0e07d0ccc7c3f4"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d3ac29d46453a415d0e07d0ccc7c3f4">PublicGetContentByShareCodeV2</a> (FString const &amp;ShareCode, THandler&lt; <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a2d3ac29d46453a415d0e07d0ccc7c3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its share code. Can be used without logged in.  <br /></td></tr>
<tr class="memitem:a8fc672b58fd89f85b0b882ef949d6059" id="r_a8fc672b58fd89f85b0b882ef949d6059"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fc672b58fd89f85b0b882ef949d6059">GetContentByContentIdV2</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a8fc672b58fd89f85b0b882ef949d6059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its content id.  <br /></td></tr>
<tr class="memitem:affb2ac2ea0c9dbcde3ff86808f9944c2" id="r_affb2ac2ea0c9dbcde3ff86808f9944c2"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affb2ac2ea0c9dbcde3ff86808f9944c2">PublicGetContentByContentIdV2</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:affb2ac2ea0c9dbcde3ff86808f9944c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its content id. Can be used without logged in.  <br /></td></tr>
<tr class="memitem:acaf566222610a8ffdbfd544df6a339bb" id="r_acaf566222610a8ffdbfd544df6a339bb"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acaf566222610a8ffdbfd544df6a339bb">CreateContentV2</a> (FString const &amp;ChannelId, <a class="el" href="../../d5/d9f/struct_f_accel_byte_models_create_u_g_c_request_v2.html">FAccelByteModelsCreateUGCRequestV2</a> const &amp;CreateRequest, THandler&lt; <a class="el" href="../../d0/dbf/struct_f_accel_byte_models_u_g_c_create_u_g_c_response_v2.html">FAccelByteModelsUGCCreateUGCResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:acaf566222610a8ffdbfd544df6a339bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../dc/d18/class_accel_byte_1_1_api_1_1_u_g_c.html" title="Provide APIs to access UGC service.">UGC</a> content with create content request.  <br /></td></tr>
<tr class="memitem:a8ab7c8c4a2adcb0d0f0de20a4cb32850" id="r_a8ab7c8c4a2adcb0d0f0de20a4cb32850"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ab7c8c4a2adcb0d0f0de20a4cb32850">DeleteContentV2</a> (FString const &amp;ChannelId, FString const &amp;ContentId, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a8ab7c8c4a2adcb0d0f0de20a4cb32850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a content based on the its channel id and content id.  <br /></td></tr>
<tr class="memitem:aa3b87567d7573618bfc6ca5c68ccfd1f" id="r_aa3b87567d7573618bfc6ca5c68ccfd1f"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3b87567d7573618bfc6ca5c68ccfd1f">ModifyContentV2</a> (FString const &amp;ChannelId, FString const &amp;ContentId, <a class="el" href="../../d3/d0e/struct_f_accel_byte_models_modify_u_g_c_request_v2.html">FAccelByteModelsModifyUGCRequestV2</a> const &amp;ModifyRequest, THandler&lt; <a class="el" href="../../d9/de7/struct_f_accel_byte_models_u_g_c_modify_u_g_c_response_v2.html">FAccelByteModelsUGCModifyUGCResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:aa3b87567d7573618bfc6ca5c68ccfd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify existing content to update content metadata.  <br /></td></tr>
<tr class="memitem:a7c459a4ec6de2043c4a1b12e12db77b6" id="r_a7c459a4ec6de2043c4a1b12e12db77b6"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c459a4ec6de2043c4a1b12e12db77b6">GenerateUploadContentURLV2</a> (FString const &amp;ChannelId, FString const &amp;ContentId, <a class="el" href="../../dd/de4/struct_f_accel_byte_models_upload_content_u_r_l_request_v2.html">FAccelByteModelsUploadContentURLRequestV2</a> const &amp;UploadRequest, THandler&lt; <a class="el" href="../../d6/dcf/struct_f_accel_byte_models_u_g_c_upload_content_u_r_l_response_v2.html">FAccelByteModelsUGCUploadContentURLResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a7c459a4ec6de2043c4a1b12e12db77b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Upload URL and Conten File Location.  <br /></td></tr>
<tr class="memitem:a6a4fda93d1d19b299da7b264322a77c9" id="r_a6a4fda93d1d19b299da7b264322a77c9"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a4fda93d1d19b299da7b264322a77c9">UpdateContentFileLocationV2</a> (FString const &amp;ChannelId, FString const &amp;ContentId, FString const &amp;FileExtension, FString const &amp;S3Key, THandler&lt; <a class="el" href="../../d5/d3a/struct_f_accel_byte_models_u_g_c_update_content_file_location_response_v2.html">FAccelByteModelsUGCUpdateContentFileLocationResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a6a4fda93d1d19b299da7b264322a77c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update Content File Location in S3.  <br /></td></tr>
<tr class="memitem:a2cd6ab3ab60a4a1c27cd06d386c96f24" id="r_a2cd6ab3ab60a4a1c27cd06d386c96f24"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cd6ab3ab60a4a1c27cd06d386c96f24">GetUserContentsV2</a> (FString const &amp;UserId, THandler&lt; <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteUGCContentUtilitiesSortByV2 SortBy=EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:a2cd6ab3ab60a4a1c27cd06d386c96f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get user's generated contents.  <br /></td></tr>
<tr class="memitem:a04d27774c71251daa068515368cc568c" id="r_a04d27774c71251daa068515368cc568c"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04d27774c71251daa068515368cc568c">PublicGetUserContentsV2</a> (FString const &amp;UserId, THandler&lt; <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteUGCContentUtilitiesSortByV2 SortBy=EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:a04d27774c71251daa068515368cc568c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get user's generated contents. Can be used without logged in.  <br /></td></tr>
<tr class="memitem:ab92127aa812da38f0d11cc875723d104" id="r_ab92127aa812da38f0d11cc875723d104"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab92127aa812da38f0d11cc875723d104">UpdateContentScreenshotV2</a> (FString const &amp;ContentId, <a class="el" href="../../da/d0d/struct_f_accel_byte_models_u_g_c_update_screenshots_v2.html">FAccelByteModelsUGCUpdateScreenshotsV2</a> const &amp;ScreenshotsRequest, THandler&lt; <a class="el" href="../../da/d0d/struct_f_accel_byte_models_u_g_c_update_screenshots_v2.html">FAccelByteModelsUGCUpdateScreenshotsV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ab92127aa812da38f0d11cc875723d104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update screenshots for content.  <br /></td></tr>
<tr class="memitem:a3f27487a7d06657253a836ccfbaccf58" id="r_a3f27487a7d06657253a836ccfbaccf58"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f27487a7d06657253a836ccfbaccf58">UploadContentScreenshotV2</a> (FString const &amp;ContentId, <a class="el" href="../../dc/d74/struct_f_accel_byte_models_u_g_c_upload_screenshots_request_v2.html">FAccelByteModelsUGCUploadScreenshotsRequestV2</a> const &amp;ScreenshotsRequest, THandler&lt; <a class="el" href="../../dc/d1a/struct_f_accel_byte_models_u_g_c_update_content_screenshot_response.html">FAccelByteModelsUGCUpdateContentScreenshotResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a3f27487a7d06657253a836ccfbaccf58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload screenshots for content.  <br /></td></tr>
<tr class="memitem:a84a9d53ad77e61e53a612e0509fe0520" id="r_a84a9d53ad77e61e53a612e0509fe0520"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84a9d53ad77e61e53a612e0509fe0520">DeleteContentScreenshotV2</a> (FString const &amp;ContentId, FString const &amp;ScreenshotId, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a84a9d53ad77e61e53a612e0509fe0520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete screenshots for content.  <br /></td></tr>
<tr class="memitem:a564c2320ada42ec6c3c918fa33cf2bc6" id="r_a564c2320ada42ec6c3c918fa33cf2bc6"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a564c2320ada42ec6c3c918fa33cf2bc6">ModifyContentByShareCode</a> (FString const &amp;ChannelId, FString const &amp;ShareCode, <a class="el" href="../../d4/d26/struct_f_accel_byte_models_u_g_c_update_request.html">FAccelByteModelsUGCUpdateRequest</a> const &amp;ModifyRequest, THandler&lt; <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a564c2320ada42ec6c3c918fa33cf2bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify existing content to update some information by share code.  <br /></td></tr>
<tr class="memitem:a0a5eefd189ca67972a0797aa1d034f6e" id="r_a0a5eefd189ca67972a0797aa1d034f6e"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a5eefd189ca67972a0797aa1d034f6e">ModifyContentShareCode</a> (FString const &amp;ChannelId, FString const &amp;ContentId, <a class="el" href="../../df/de8/struct_f_accel_byte_models_u_g_c_modify_content_share_code_request.html">FAccelByteModelsUGCModifyContentShareCodeRequest</a> const &amp;ModifyContentShareCodeRequest, THandler&lt; <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a0a5eefd189ca67972a0797aa1d034f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the shareCode of a content.  <br /></td></tr>
<tr class="memitem:a3d2c3e3afe701c42f202327538de6ce9" id="r_a3d2c3e3afe701c42f202327538de6ce9"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d2c3e3afe701c42f202327538de6ce9">DeleteContentByShareCode</a> (FString const &amp;ChannelId, FString const &amp;ShareCode, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a3d2c3e3afe701c42f202327538de6ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a content based on the its channel id and share code.  <br /></td></tr>
<tr class="memitem:af6c58bdb52170ab54406e85c64be9ec7" id="r_af6c58bdb52170ab54406e85c64be9ec7"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6c58bdb52170ab54406e85c64be9ec7">BulkGetContentByShareCodeV2</a> (TArray&lt; FString &gt; const &amp;ShareCodes, THandler&lt; TArray&lt; <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:af6c58bdb52170ab54406e85c64be9ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk Get contents by ShareCodes.  <br /></td></tr>
<tr class="memitem:ad9a0304a384589c42920df152b1c7495" id="r_ad9a0304a384589c42920df152b1c7495"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9a0304a384589c42920df152b1c7495">ModifyContentShareCodeV2</a> (FString const &amp;ChannelId, FString const &amp;ContentId, <a class="el" href="../../df/de8/struct_f_accel_byte_models_u_g_c_modify_content_share_code_request.html">FAccelByteModelsUGCModifyContentShareCodeRequest</a> const &amp;ModifyContentShareCodeRequest, THandler&lt; <a class="el" href="../../d0/dbf/struct_f_accel_byte_models_u_g_c_create_u_g_c_response_v2.html">FAccelByteModelsUGCCreateUGCResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ad9a0304a384589c42920df152b1c7495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the shareCode of a content.  <br /></td></tr>
<tr class="memitem:a7847adf38454e7a8849ebfa5d850140f" id="r_a7847adf38454e7a8849ebfa5d850140f"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7847adf38454e7a8849ebfa5d850140f">AddDownloadContentCountV2</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="../../d3/d8f/struct_f_accel_byte_models_u_g_c_add_download_content_count_response_v2.html">FAccelByteModelsUGCAddDownloadContentCountResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a7847adf38454e7a8849ebfa5d850140f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add download count for a content.  <br /></td></tr>
<tr class="memitem:ad48bf0c08fe3e93a6ade8784b95258dd" id="r_ad48bf0c08fe3e93a6ade8784b95258dd"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad48bf0c08fe3e93a6ade8784b95258dd">GetListContentDownloaderV2</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="../../d4/d29/struct_f_accel_byte_models_u_g_c_get_paginated_content_downloader_response_v2.html">FAccelByteModelsUGCGetPaginatedContentDownloaderResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, FString const &amp;UserId=TEXT(&quot;&quot;), int32 Limit=20, int32 Offset=0, EAccelByteUGCContentUtilitiesSortByV2 SortBy=EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:ad48bf0c08fe3e93a6ade8784b95258dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of <a class="el" href="../../dc/d18/class_accel_byte_1_1_api_1_1_u_g_c.html" title="Provide APIs to access UGC service.">UGC</a> content downloader.  <br /></td></tr>
<tr class="memitem:ad570c7fc0985ed99d7c4b76938205d99" id="r_ad570c7fc0985ed99d7c4b76938205d99"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad570c7fc0985ed99d7c4b76938205d99">GetListContentLikerV2</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="../../d1/d4b/struct_f_accel_byte_models_u_g_c_get_paginated_content_liker_response_v2.html">FAccelByteModelsUGCGetPaginatedContentLikerResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteUGCContentUtilitiesSortByV2 SortBy=EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:ad570c7fc0985ed99d7c4b76938205d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of users who like the content.  <br /></td></tr>
<tr class="memitem:a5b4111c7a5376d256693091dfe44fc45" id="r_a5b4111c7a5376d256693091dfe44fc45"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b4111c7a5376d256693091dfe44fc45">UpdateLikeStatusToContentV2</a> (FString const &amp;ContentId, bool bLikeStatus, THandler&lt; <a class="el" href="../../d2/d66/struct_f_accel_byte_models_u_g_c_update_like_status_to_content_response.html">FAccelByteModelsUGCUpdateLikeStatusToContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a5b4111c7a5376d256693091dfe44fc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update like/unlike status to a content.  <br /></td></tr>
<tr class="memitem:a0cdb50ba29225cd0dfb675786dea2b99" id="r_a0cdb50ba29225cd0dfb675786dea2b99"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cdb50ba29225cd0dfb675786dea2b99">GetStagingContents</a> (EStagingContentRequestStatus Status, THandler&lt; <a class="el" href="../../d0/d68/struct_f_accel_byte_models_u_g_c_paginated_list_staging_content_response.html">FAccelByteModelsUGCPaginatedListStagingContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteStagingContentUtilitiesSortBy SortBy=EAccelByteStagingContentUtilitiesSortBy::NONE)</td></tr>
<tr class="memdesc:a0cdb50ba29225cd0dfb675786dea2b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of staging contents and sort by status.  <br /></td></tr>
<tr class="memitem:af6121ee3d59e4e5784d140c8da02a056" id="r_af6121ee3d59e4e5784d140c8da02a056"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6121ee3d59e4e5784d140c8da02a056">GetStagingContentById</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="../../df/d6f/struct_f_accel_byte_models_u_g_c_staging_content_response.html">FAccelByteModelsUGCStagingContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:af6121ee3d59e4e5784d140c8da02a056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get user staging content.  <br /></td></tr>
<tr class="memitem:ab198ac246549082f223718107f36d949" id="r_ab198ac246549082f223718107f36d949"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab198ac246549082f223718107f36d949">UpdateStagingContent</a> (FString const &amp;ContentId, <a class="el" href="../../da/d41/struct_f_accel_byte_models_u_g_c_update_content_file_location_request_v2.html">FAccelByteModelsUGCUpdateContentFileLocationRequestV2</a> UpdateRequest, THandler&lt; <a class="el" href="../../df/d6f/struct_f_accel_byte_models_u_g_c_staging_content_response.html">FAccelByteModelsUGCStagingContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ab198ac246549082f223718107f36d949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update staging content by content id using update request struct.  <br /></td></tr>
<tr class="memitem:a99a0bf52469a6e73ed1ed9dd8069b57d" id="r_a99a0bf52469a6e73ed1ed9dd8069b57d"><td class="memItemLeft" align="right" valign="top">FAccelByteTaskWPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99a0bf52469a6e73ed1ed9dd8069b57d">DeleteStagingContent</a> (FString const &amp;ContentId, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a99a0bf52469a6e73ed1ed9dd8069b57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete staging content by user id and content id.  <br /></td></tr>
<tr class="inherit_header pub_methods_class_accel_byte_1_1_f_api_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_accel_byte_1_1_f_api_base')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="../../d3/dd3/class_accel_byte_1_1_f_api_base.html">AccelByte::FApiBase</a></td></tr>
<tr class="memitem:a5b4bfcf158b368358fc0860adece134c inherit pub_methods_class_accel_byte_1_1_f_api_base" id="r_a5b4bfcf158b368358fc0860adece134c"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>FApiBase</b> (<a class="el" href="../../d0/d90/class_accel_byte_1_1_credentials.html">Credentials</a> const &amp;InCredentialsRef, <a class="el" href="../../df/db1/class_accel_byte_1_1_settings.html">Settings</a> const &amp;InSettingsRef, <a class="el" href="../../df/d3f/class_accel_byte_1_1_f_http_retry_scheduler_base.html">FHttpRetrySchedulerBase</a> &amp;InHttpRef, TSharedPtr&lt; <a class="el" href="../../d9/d63/class_accel_byte_1_1_f_api_client.html">AccelByte::FApiClient</a>, ESPMode::ThreadSafe &gt; const &amp;InApiClient)</td></tr>
<tr class="memitem:a7532e689716d93aaa2f96568ab14c233 inherit pub_methods_class_accel_byte_1_1_f_api_base" id="r_a7532e689716d93aaa2f96568ab14c233"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>FApiBase</b> (<a class="el" href="../../d0/d90/class_accel_byte_1_1_credentials.html">Credentials</a> const &amp;InCredentialsRef, <a class="el" href="../../df/db1/class_accel_byte_1_1_settings.html">Settings</a> const &amp;InSettingsRef, <a class="el" href="../../df/d3f/class_accel_byte_1_1_f_http_retry_scheduler_base.html">FHttpRetrySchedulerBase</a> &amp;InHttpRef, FAccelBytePlatformPtr const &amp;InAccelBytePlatform)</td></tr>
<tr class="memitem:ab08541fe9d704af8a9b5bae1b87deb44 inherit pub_methods_class_accel_byte_1_1_f_api_base" id="r_ab08541fe9d704af8a9b5bae1b87deb44"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetApiClient</b> (TSharedPtr&lt; <a class="el" href="../../d9/d63/class_accel_byte_1_1_f_api_client.html">AccelByte::FApiClient</a>, ESPMode::ThreadSafe &gt; const &amp;InApiClient)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-inherited" class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_accel_byte_1_1_f_api_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_class_accel_byte_1_1_f_api_base')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Member Functions inherited from <a class="el" href="../../d3/dd3/class_accel_byte_1_1_f_api_base.html">AccelByte::FApiBase</a></td></tr>
<tr class="memitem:abf73c69f11a74c5d79ed767d7e9de861 inherit pro_methods_class_accel_byte_1_1_f_api_base" id="r_abf73c69f11a74c5d79ed767d7e9de861"><td class="memTemplParams" colspan="2">
template&lt;typename T&gt; </td></tr>
<tr class="memitem:abf73c69f11a74c5d79ed767d7e9de861 inherit pro_methods_class_accel_byte_1_1_f_api_base template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><b>ValidateAccelByteId</b> (FString const &amp;Id, EAccelByteIdHypensRule HypenRule, FString const &amp;ErrorMessage, T const &amp;OnError)</td></tr>
<tr class="inherit_header pro_attribs_class_accel_byte_1_1_f_api_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_class_accel_byte_1_1_f_api_base')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Attributes inherited from <a class="el" href="../../d3/dd3/class_accel_byte_1_1_f_api_base.html">AccelByte::FApiBase</a></td></tr>
<tr class="memitem:a4ded3338c43197d995d2ce88e3ac85af inherit pro_attribs_class_accel_byte_1_1_f_api_base" id="r_a4ded3338c43197d995d2ce88e3ac85af"><td class="memItemLeft" align="right" valign="top">
TSharedRef&lt; <a class="el" href="../../d0/d90/class_accel_byte_1_1_credentials.html">Credentials</a> const, ESPMode::ThreadSafe &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CredentialsRef</b></td></tr>
<tr class="memitem:ae8ffc36382a4204edb20a6d3430c13ad inherit pro_attribs_class_accel_byte_1_1_f_api_base" id="r_ae8ffc36382a4204edb20a6d3430c13ad"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="../../df/db1/class_accel_byte_1_1_settings.html">Settings</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>SettingsRef</b></td></tr>
<tr class="memitem:a3262dbbbb6404aec16bef79a36480bbf inherit pro_attribs_class_accel_byte_1_1_f_api_base" id="r_a3262dbbbb6404aec16bef79a36480bbf"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="../../df/d3f/class_accel_byte_1_1_f_http_retry_scheduler_base.html">FHttpRetrySchedulerBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>HttpRef</b></td></tr>
<tr class="memitem:afd2ef10eecc71f4d34515276ab6a8fcb inherit pro_attribs_class_accel_byte_1_1_f_api_base" id="r_afd2ef10eecc71f4d34515276ab6a8fcb"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="../../d8/d7e/class_accel_byte_1_1_f_http_client.html">FHttpClient</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HttpClient</b></td></tr>
<tr class="memitem:af48fc7e07daa90601940b0bbaeaca4a9 inherit pro_attribs_class_accel_byte_1_1_f_api_base" id="r_af48fc7e07daa90601940b0bbaeaca4a9"><td class="memItemLeft" align="right" valign="top">
FAccelBytePlatformPtr&#160;</td><td class="memItemRight" valign="bottom"><b>AccelBytePlatformPtr</b></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provide APIs to access <a class="el" href="../../dc/d18/class_accel_byte_1_1_api_1_1_u_g_c.html" title="Provide APIs to access UGC service.">UGC</a> service. </p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a7847adf38454e7a8849ebfa5d850140f" name="a7847adf38454e7a8849ebfa5d850140f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7847adf38454e7a8849ebfa5d850140f">&#9670;&#160;</a></span>AddDownloadContentCountV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::AddDownloadContentCountV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/d8f/struct_f_accel_byte_models_u_g_c_add_download_content_count_response_v2.html">FAccelByteModelsUGCAddDownloadContentCountResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add download count for a content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the content. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d3/d8f/struct_f_accel_byte_models_u_g_c_add_download_content_count_response_v2.html">FAccelByteModelsUGCAddDownloadContentCountResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a35ecd76c49f3a3cc8751d231e932f2ae" name="a35ecd76c49f3a3cc8751d231e932f2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ecd76c49f3a3cc8751d231e932f2ae">&#9670;&#160;</a></span>BulkGetContentByShareCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::BulkGetContentByShareCode </td>
          <td>(</td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; TArray&lt; <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a> &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bulk Get contents by ShareCodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ShareCodes</td><td>Content ShareCodes Array <br  />
 </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="af6c58bdb52170ab54406e85c64be9ec7" name="af6c58bdb52170ab54406e85c64be9ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c58bdb52170ab54406e85c64be9ec7">&#9670;&#160;</a></span>BulkGetContentByShareCodeV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::BulkGetContentByShareCodeV2 </td>
          <td>(</td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; TArray&lt; <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bulk Get contents by ShareCodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ShareCodes</td><td>Content ShareCodes Array <br  />
 </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a5dc2a3b48a47d37c28e9dfeba3282450" name="a5dc2a3b48a47d37c28e9dfeba3282450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc2a3b48a47d37c28e9dfeba3282450">&#9670;&#160;</a></span>CreateChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::CreateChannel </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/dc9/struct_f_accel_byte_models_u_g_c_channel_response.html">FAccelByteModelsUGCChannelResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a player's channel with specific channel name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelName</td><td>The name of the channel. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d3/dc9/struct_f_accel_byte_models_u_g_c_channel_response.html">FAccelByteModelsUGCChannelResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a616f403e2b4373ff051a39bf126071ed" name="a616f403e2b4373ff051a39bf126071ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616f403e2b4373ff051a39bf126071ed">&#9670;&#160;</a></span>CreateContent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::CreateContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d10/struct_f_accel_byte_models_u_g_c_request.html">FAccelByteModelsUGCRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>UGCRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a content with FString preview and get the payload url to upload the content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">UGCRequest</td><td>Detail information for the content request. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a7753cb83f944423eda883c1a8ccd19cd" name="a7753cb83f944423eda883c1a8ccd19cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7753cb83f944423eda883c1a8ccd19cd">&#9670;&#160;</a></span>CreateContent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::CreateContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>SubType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Tags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; uint8 &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Preview</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>FileExtension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentType</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TEXT(&quot;application/octet-stream&quot;)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a content with TArray&lt;uint8&gt; Preview parameter and get the payload url to upload the content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">Name</td><td>Name of the content. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of the content. </td></tr>
    <tr><td class="paramname">SubType</td><td>SubType of the content. </td></tr>
    <tr><td class="paramname">Tags</td><td>Tags of the content. </td></tr>
    <tr><td class="paramname">Preview</td><td>The TArray&lt;uint8&gt; of the content's Preview </td></tr>
    <tr><td class="paramname">FileExtension</td><td>FileExtension of the content. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">ContentType</td><td>The specific type of the content's created, default value is "application/octet-stream".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="acaf566222610a8ffdbfd544df6a339bb" name="acaf566222610a8ffdbfd544df6a339bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf566222610a8ffdbfd544df6a339bb">&#9670;&#160;</a></span>CreateContentV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::CreateContentV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d9f/struct_f_accel_byte_models_create_u_g_c_request_v2.html">FAccelByteModelsCreateUGCRequestV2</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>CreateRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d0/dbf/struct_f_accel_byte_models_u_g_c_create_u_g_c_response_v2.html">FAccelByteModelsUGCCreateUGCResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../dc/d18/class_accel_byte_1_1_api_1_1_u_g_c.html" title="Provide APIs to access UGC service.">UGC</a> content with create content request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">CreateRequest</td><td>Detail information for the content request. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d0/dbf/struct_f_accel_byte_models_u_g_c_create_u_g_c_response_v2.html">FAccelByteModelsUGCCreateUGCResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a6f66e8b4a6e8a557f25b7ed514b9d818" name="a6f66e8b4a6e8a557f25b7ed514b9d818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f66e8b4a6e8a557f25b7ed514b9d818">&#9670;&#160;</a></span>DeleteChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::DeleteChannel </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a player's channel based on the its channel id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the channel that will be deleted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a50dee08a959c003dd362706d3b208e88" name="a50dee08a959c003dd362706d3b208e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50dee08a959c003dd362706d3b208e88">&#9670;&#160;</a></span>DeleteContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::DeleteContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a content based on the its channel id and content id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be deleted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a3d2c3e3afe701c42f202327538de6ce9" name="a3d2c3e3afe701c42f202327538de6ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2c3e3afe701c42f202327538de6ce9">&#9670;&#160;</a></span>DeleteContentByShareCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::DeleteContentByShareCode </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a content based on the its channel id and share code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ShareCode</td><td>The share code of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a84a9d53ad77e61e53a612e0509fe0520" name="a84a9d53ad77e61e53a612e0509fe0520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a9d53ad77e61e53a612e0509fe0520">&#9670;&#160;</a></span>DeleteContentScreenshotV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::DeleteContentScreenshotV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ScreenshotId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete screenshots for content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>Content Id. </td></tr>
    <tr><td class="paramname">ScreenshotId</td><td>Screenshot Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a8ab7c8c4a2adcb0d0f0de20a4cb32850" name="a8ab7c8c4a2adcb0d0f0de20a4cb32850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab7c8c4a2adcb0d0f0de20a4cb32850">&#9670;&#160;</a></span>DeleteContentV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::DeleteContentV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a content based on the its channel id and content id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be deleted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a99a0bf52469a6e73ed1ed9dd8069b57d" name="a99a0bf52469a6e73ed1ed9dd8069b57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a0bf52469a6e73ed1ed9dd8069b57d">&#9670;&#160;</a></span>DeleteStagingContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::DeleteStagingContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete staging content by user id and content id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>Target content id to update the content </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a7c459a4ec6de2043c4a1b12e12db77b6" name="a7c459a4ec6de2043c4a1b12e12db77b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c459a4ec6de2043c4a1b12e12db77b6">&#9670;&#160;</a></span>GenerateUploadContentURLV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GenerateUploadContentURLV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/de4/struct_f_accel_byte_models_upload_content_u_r_l_request_v2.html">FAccelByteModelsUploadContentURLRequestV2</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>UploadRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d6/dcf/struct_f_accel_byte_models_u_g_c_upload_content_u_r_l_response_v2.html">FAccelByteModelsUGCUploadContentURLResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate Upload URL and Conten File Location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content. </td></tr>
    <tr><td class="paramname">UploadRequest</td><td>Detail information for the upload request. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d6/dcf/struct_f_accel_byte_models_u_g_c_upload_content_u_r_l_response_v2.html">FAccelByteModelsUGCUploadContentURLResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a2cae34d14d317d01eb1cbdabc774e4ef" name="a2cae34d14d317d01eb1cbdabc774e4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cae34d14d317d01eb1cbdabc774e4ef">&#9670;&#160;</a></span>GetChannels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetChannels </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d1/d54/struct_f_accel_byte_models_u_g_c_channels_paging_response.html">FAccelByteModelsUGCChannelsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all of the player's channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td><a class="el" href="../../dc/d3f/class_accel_byte_1_1_api_1_1_user.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d1/d54/struct_f_accel_byte_models_u_g_c_channels_paging_response.html">FAccelByteModelsUGCChannelsPagingResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>The limit of the channel results. Default value is 1000. </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset of the channel results. Default value is 0. </td></tr>
    <tr><td class="paramname">ChannelName</td><td>The name of the channel you want to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a697a7df678ae2b04e0a309a0830c04c5" name="a697a7df678ae2b04e0a309a0830c04c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697a7df678ae2b04e0a309a0830c04c5">&#9670;&#160;</a></span>GetChannels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetChannels </td>
          <td>(</td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d1/d54/struct_f_accel_byte_models_u_g_c_channels_paging_response.html">FAccelByteModelsUGCChannelsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all of the player's channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d1/d54/struct_f_accel_byte_models_u_g_c_channels_paging_response.html">FAccelByteModelsUGCChannelsPagingResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>The limit of the channel results. Default value is 1000. </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset of the channel results. Default value is 0. </td></tr>
    <tr><td class="paramname">ChannelName</td><td>The name of the channel you want to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="aa787be41f543748528f7f98cab6e0fe2" name="aa787be41f543748528f7f98cab6e0fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa787be41f543748528f7f98cab6e0fe2">&#9670;&#160;</a></span>GetContentBulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetContentBulk </td>
          <td>(</td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentIds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; TArray&lt; <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a> &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents by content Ids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentIds</td><td>Content Ids Array <br  />
 </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ac61eab66c59a758056d3c8155bdc2641" name="ac61eab66c59a758056d3c8155bdc2641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61eab66c59a758056d3c8155bdc2641">&#9670;&#160;</a></span>GetContentBulkByIdsV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetContentBulkByIdsV2 </td>
          <td>(</td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentIds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; TArray&lt; <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents by content Ids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentIds</td><td>Content Ids Array </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is TArray&lt;FAccelByteModelsUGCContentResponseV2&gt;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a2c6a6914e1038d8ed4c52646c1367a17" name="a2c6a6914e1038d8ed4c52646c1367a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6a6914e1038d8ed4c52646c1367a17">&#9670;&#160;</a></span>GetContentByContentId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetContentByContentId </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its content id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a8fc672b58fd89f85b0b882ef949d6059" name="a8fc672b58fd89f85b0b882ef949d6059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc672b58fd89f85b0b882ef949d6059">&#9670;&#160;</a></span>GetContentByContentIdV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetContentByContentIdV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its content id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a2d33217bd856b7fcd04fe6a7c5faf879" name="a2d33217bd856b7fcd04fe6a7c5faf879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d33217bd856b7fcd04fe6a7c5faf879">&#9670;&#160;</a></span>GetContentByShareCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetContentByShareCode </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its share code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ShareCode</td><td>The share code of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a30b5e7cd53aeedc176d052fa120a51f3" name="a30b5e7cd53aeedc176d052fa120a51f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b5e7cd53aeedc176d052fa120a51f3">&#9670;&#160;</a></span>GetContentByShareCodeV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetContentByShareCodeV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its share code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ShareCode</td><td>The share code of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a0fb40c37032b411e7a4d3c0cfb2863d9" name="a0fb40c37032b411e7a4d3c0cfb2863d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb40c37032b411e7a4d3c0cfb2863d9">&#9670;&#160;</a></span>GetContentPreview() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetContentPreview </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../dc/dca/struct_f_accel_byte_models_u_g_c_preview.html">FAccelByteModelsUGCPreview</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get content Preview as <a class="el" href="../../dc/dca/struct_f_accel_byte_models_u_g_c_preview.html">FAccelByteModelsUGCPreview</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the Preview's content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../dc/dca/struct_f_accel_byte_models_u_g_c_preview.html">FAccelByteModelsUGCPreview</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ae94eafa26e0c09af1dd1a37a2d663351" name="ae94eafa26e0c09af1dd1a37a2d663351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94eafa26e0c09af1dd1a37a2d663351">&#9670;&#160;</a></span>GetContentPreview() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetContentPreview </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; TArray&lt; uint8 &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get content preview as TArray&lt;uint8&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the Preview's content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is TArray&lt;uint8&gt;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a81b8dcb07c6dee3d4e7ae89849ac6b32" name="a81b8dcb07c6dee3d4e7ae89849ac6b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b8dcb07c6dee3d4e7ae89849ac6b32">&#9670;&#160;</a></span>GetCreator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetCreator </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d2/daa/struct_f_accel_byte_models_u_g_c_get_list_followers_response.html">FAccelByteModelsUGCGetListFollowersResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get creator stats: number of total like by other user, number of total following and follower user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td><a class="el" href="../../dc/d3f/class_accel_byte_1_1_api_1_1_user.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a3516c9236dd35c4257ccc19b48920b8f" name="a3516c9236dd35c4257ccc19b48920b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3516c9236dd35c4257ccc19b48920b8f">&#9670;&#160;</a></span>GetFollowedContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetFollowedContent </td>
          <td>(</td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d6/dd3/struct_f_accel_byte_models_u_g_c_content_page_response.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents from followed creators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ad5b708f2ef8b9af6f6221609cf6c6ab6" name="ad5b708f2ef8b9af6f6221609cf6c6ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b708f2ef8b9af6f6221609cf6c6ab6">&#9670;&#160;</a></span>GetFollowedUsers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetFollowedUsers </td>
          <td>(</td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d5/dbb/struct_f_accel_byte_models_u_g_c_followed_users_response.html">FAccelByteModelsUGCFollowedUsersResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get followed creators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a1b76e95bbe9bc48f75ab39a9998cd184" name="a1b76e95bbe9bc48f75ab39a9998cd184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b76e95bbe9bc48f75ab39a9998cd184">&#9670;&#160;</a></span>GetGroups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetGroups </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/df8/struct_f_accel_byte_models_u_g_c_get_groups_response.html">FAccelByteModelsUGCGetGroupsResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all user groups. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td><a class="el" href="../../dc/d3f/class_accel_byte_1_1_api_1_1_user.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ac01b21c7eeab3e16e484b295072c1154" name="ac01b21c7eeab3e16e484b295072c1154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01b21c7eeab3e16e484b295072c1154">&#9670;&#160;</a></span>GetLikedContent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetLikedContent </td>
          <td>(</td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Tags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Subtype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>IsOfficial</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d6/dd3/struct_f_accel_byte_models_u_g_c_content_page_response.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteLikedContentSortBy</td>          <td class="paramname"><span class="paramname"><em>SortBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteLikedContentSortBy::DATE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcOrderBy</td>          <td class="paramname"><span class="paramname"><em>OrderBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcOrderBy::DESC</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get liked contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Tags</td><td>Content Tags. </td></tr>
    <tr><td class="paramname">Name</td><td>Content Name. </td></tr>
    <tr><td class="paramname">Type</td><td>Content Type. </td></tr>
    <tr><td class="paramname">Subtype</td><td>Content Subtype. </td></tr>
    <tr><td class="paramname">IsOfficial</td><td>Filter only official contents </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria, name,download,like,date. default=date. </td></tr>
    <tr><td class="paramname">OrderBy</td><td>Sorting order: asc, desc. default=desc</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="aeb2a223652dc0cb9d6d4a5caad3023e0" name="aeb2a223652dc0cb9d6d4a5caad3023e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2a223652dc0cb9d6d4a5caad3023e0">&#9670;&#160;</a></span>GetLikedContent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetLikedContent </td>
          <td>(</td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Tags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Subtype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>IsOfficial</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d6/dd3/struct_f_accel_byte_models_u_g_c_content_page_response.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcSortBy</td>          <td class="paramname"><span class="paramname"><em>SortBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcSortBy::DATE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcOrderBy</td>          <td class="paramname"><span class="paramname"><em>OrderBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcOrderBy::DESC</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get liked contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Tags</td><td>Content Tags. </td></tr>
    <tr><td class="paramname">Name</td><td>Content Name. </td></tr>
    <tr><td class="paramname">Type</td><td>Content Type. </td></tr>
    <tr><td class="paramname">Subtype</td><td>Content Subtype. </td></tr>
    <tr><td class="paramname">IsOfficial</td><td>Filter only official contents </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria, name,download,like,date. default=date. </td></tr>
    <tr><td class="paramname">OrderBy</td><td>Sorting order: asc, desc. default=desc <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ad48bf0c08fe3e93a6ade8784b95258dd" name="ad48bf0c08fe3e93a6ade8784b95258dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48bf0c08fe3e93a6ade8784b95258dd">&#9670;&#160;</a></span>GetListContentDownloaderV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetListContentDownloaderV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d4/d29/struct_f_accel_byte_models_u_g_c_get_paginated_content_downloader_response_v2.html">FAccelByteModelsUGCGetPaginatedContentDownloaderResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TEXT(&quot;&quot;)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentUtilitiesSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of <a class="el" href="../../dc/d18/class_accel_byte_1_1_api_1_1_u_g_c.html" title="Provide APIs to access UGC service.">UGC</a> content downloader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the content. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d4/d29/struct_f_accel_byte_models_u_g_c_get_paginated_content_downloader_response_v2.html">FAccelByteModelsUGCGetPaginatedContentDownloaderResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">UserId</td><td>The id of the user who downloaded the content. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria: created time with asc or desc. default = created time and desc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ad570c7fc0985ed99d7c4b76938205d99" name="ad570c7fc0985ed99d7c4b76938205d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad570c7fc0985ed99d7c4b76938205d99">&#9670;&#160;</a></span>GetListContentLikerV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetListContentLikerV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d1/d4b/struct_f_accel_byte_models_u_g_c_get_paginated_content_liker_response_v2.html">FAccelByteModelsUGCGetPaginatedContentLikerResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentUtilitiesSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of users who like the content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the content. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d1/d4b/struct_f_accel_byte_models_u_g_c_get_paginated_content_liker_response_v2.html">FAccelByteModelsUGCGetPaginatedContentLikerResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria: created time with asc or desc. default = created time and desc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a457d769a6cfcf29b32c542bec39e6b5d" name="a457d769a6cfcf29b32c542bec39e6b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457d769a6cfcf29b32c542bec39e6b5d">&#9670;&#160;</a></span>GetListFollowers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetListFollowers </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d7/da0/struct_f_accel_byte_models_u_g_c_get_list_followers_paging_response.html">FAccelByteModelsUGCGetListFollowersPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of followers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td>The id of the user that will be given it's followers. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of user per page, Default value : 1000. </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve, Default value : 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="af6121ee3d59e4e5784d140c8da02a056" name="af6121ee3d59e4e5784d140c8da02a056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6121ee3d59e4e5784d140c8da02a056">&#9670;&#160;</a></span>GetStagingContentById()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetStagingContentById </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../df/d6f/struct_f_accel_byte_models_u_g_c_staging_content_response.html">FAccelByteModelsUGCStagingContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get user staging content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>Target content id to retrieved </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is FAccelByteModelsStagingContentResponse. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a0cdb50ba29225cd0dfb675786dea2b99" name="a0cdb50ba29225cd0dfb675786dea2b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdb50ba29225cd0dfb675786dea2b99">&#9670;&#160;</a></span>GetStagingContents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetStagingContents </td>
          <td>(</td>
          <td class="paramtype">EStagingContentRequestStatus</td>          <td class="paramname"><span class="paramname"><em>Status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d0/d68/struct_f_accel_byte_models_u_g_c_paginated_list_staging_content_response.html">FAccelByteModelsUGCPaginatedListStagingContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteStagingContentUtilitiesSortBy</td>          <td class="paramname"><span class="paramname"><em>SortBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteStagingContentUtilitiesSortBy::NONE</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of staging contents and sort by status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Status</td><td>Sort the response item by status of the staging list contents </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is FAccelByteModelsPaginatedListStagingContentResponse. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria: created time with asc or desc and updated time with asc or desc. default = none.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a5788eaac16bef7471465d5658e8dfb71" name="a5788eaac16bef7471465d5658e8dfb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5788eaac16bef7471465d5658e8dfb71">&#9670;&#160;</a></span>GetTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetTags </td>
          <td>(</td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../db/dba/struct_f_accel_byte_models_u_g_c_tags_paging_response.html">FAccelByteModelsUGCTagsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all tags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../db/dba/struct_f_accel_byte_models_u_g_c_tags_paging_response.html">FAccelByteModelsUGCTagsPagingResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>The limit of the tags results. Default value is 1000. </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset of the tags results. Default value is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="acbeec7e4be7f4279d426ae38ea393d5b" name="acbeec7e4be7f4279d426ae38ea393d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbeec7e4be7f4279d426ae38ea393d5b">&#9670;&#160;</a></span>GetTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetTypes </td>
          <td>(</td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d1/d8e/struct_f_accel_byte_models_u_g_c_types_paging_response.html">FAccelByteModelsUGCTypesPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all types and subtypes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d1/d8e/struct_f_accel_byte_models_u_g_c_types_paging_response.html">FAccelByteModelsUGCTypesPagingResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>The limit of the types and subtypes results. Default value is 1000. </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset of the types and subtypes results. Default value is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a6ead218bf767e2f7a208bc244d75aba6" name="a6ead218bf767e2f7a208bc244d75aba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ead218bf767e2f7a208bc244d75aba6">&#9670;&#160;</a></span>GetUserContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetUserContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d6/dd3/struct_f_accel_byte_models_u_g_c_content_page_response.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get user's generated contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td><a class="el" href="../../dc/d3f/class_accel_byte_1_1_api_1_1_user.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a2cd6ab3ab60a4a1c27cd06d386c96f24" name="a2cd6ab3ab60a4a1c27cd06d386c96f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd6ab3ab60a4a1c27cd06d386c96f24">&#9670;&#160;</a></span>GetUserContentsV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::GetUserContentsV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentUtilitiesSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get user's generated contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td><a class="el" href="../../dc/d3f/class_accel_byte_1_1_api_1_1_user.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ac0609f18c934b75fb2a4984aa927084b" name="ac0609f18c934b75fb2a4984aa927084b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0609f18c934b75fb2a4984aa927084b">&#9670;&#160;</a></span>ModifyContent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::ModifyContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d10/struct_f_accel_byte_models_u_g_c_request.html">FAccelByteModelsUGCRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>UGCRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bUpdateContent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify existing content to update some information with FString preview. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be modified. </td></tr>
    <tr><td class="paramname">UGCRequest</td><td>Detail information for the content request that will be modified. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">bUpdateContent</td><td>This will be used to update the content too or only content information . Default value is false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a3f1b286b162dfbe41e244e8ac10c3230" name="a3f1b286b162dfbe41e244e8ac10c3230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1b286b162dfbe41e244e8ac10c3230">&#9670;&#160;</a></span>ModifyContent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::ModifyContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d26/struct_f_accel_byte_models_u_g_c_update_request.html">FAccelByteModelsUGCUpdateRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>ModifyRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify existing content to update some information with FString preview. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be modified. </td></tr>
    <tr><td class="paramname">ModifyRequest</td><td>Detail information for the content request that will be modified. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a126756cba75ad6d5125687ce08b472d6" name="a126756cba75ad6d5125687ce08b472d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126756cba75ad6d5125687ce08b472d6">&#9670;&#160;</a></span>ModifyContent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::ModifyContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>SubType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Tags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; uint8 &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Preview</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>FileExtension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentType</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TEXT(&quot;application/octet-stream&quot;)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bUpdateContent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify existing content to update some information with TArray&lt;uint8&gt; Preview parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be modified. </td></tr>
    <tr><td class="paramname">Name</td><td>Name of the content. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of the content. </td></tr>
    <tr><td class="paramname">SubType</td><td>SubType of the content. </td></tr>
    <tr><td class="paramname">Tags</td><td>Tags of the content. </td></tr>
    <tr><td class="paramname">Preview</td><td>The TArray&lt;uint8&gt; of the content's Preview </td></tr>
    <tr><td class="paramname">FileExtension</td><td>FileExtension of the content. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">ContentType</td><td>The specific type of the content's modified. Default value is "application/octet-stream". </td></tr>
    <tr><td class="paramname">bUpdateContent</td><td>This will be used to update the content too or only content information . Default value is false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a564c2320ada42ec6c3c918fa33cf2bc6" name="a564c2320ada42ec6c3c918fa33cf2bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564c2320ada42ec6c3c918fa33cf2bc6">&#9670;&#160;</a></span>ModifyContentByShareCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::ModifyContentByShareCode </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d26/struct_f_accel_byte_models_u_g_c_update_request.html">FAccelByteModelsUGCUpdateRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>ModifyRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify existing content to update some information by share code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ShareCode</td><td>The share code of the content that will be fetched. </td></tr>
    <tr><td class="paramname">ModifyRequest</td><td>Detail information for the content request that will be modified. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a0a5eefd189ca67972a0797aa1d034f6e" name="a0a5eefd189ca67972a0797aa1d034f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5eefd189ca67972a0797aa1d034f6e">&#9670;&#160;</a></span>ModifyContentShareCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::ModifyContentShareCode </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/de8/struct_f_accel_byte_models_u_g_c_modify_content_share_code_request.html">FAccelByteModelsUGCModifyContentShareCodeRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>ModifyContentShareCodeRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the shareCode of a content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>Content Id. </td></tr>
    <tr><td class="paramname">ModifyContentShareCodeRequest</td><td>Detail information for the content request that will be modified. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d0/d35/struct_f_accel_byte_models_u_g_c_response.html">FAccelByteModelsUGCResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ad9a0304a384589c42920df152b1c7495" name="ad9a0304a384589c42920df152b1c7495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a0304a384589c42920df152b1c7495">&#9670;&#160;</a></span>ModifyContentShareCodeV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::ModifyContentShareCodeV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/de8/struct_f_accel_byte_models_u_g_c_modify_content_share_code_request.html">FAccelByteModelsUGCModifyContentShareCodeRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>ModifyContentShareCodeRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d0/dbf/struct_f_accel_byte_models_u_g_c_create_u_g_c_response_v2.html">FAccelByteModelsUGCCreateUGCResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the shareCode of a content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>Content Id. </td></tr>
    <tr><td class="paramname">ModifyContentShareCodeRequest</td><td>Detail information for the content request that will be modified. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d0/dbf/struct_f_accel_byte_models_u_g_c_create_u_g_c_response_v2.html">FAccelByteModelsUGCCreateUGCResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="aa3b87567d7573618bfc6ca5c68ccfd1f" name="aa3b87567d7573618bfc6ca5c68ccfd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b87567d7573618bfc6ca5c68ccfd1f">&#9670;&#160;</a></span>ModifyContentV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::ModifyContentV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d0e/struct_f_accel_byte_models_modify_u_g_c_request_v2.html">FAccelByteModelsModifyUGCRequestV2</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>ModifyRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d9/de7/struct_f_accel_byte_models_u_g_c_modify_u_g_c_response_v2.html">FAccelByteModelsUGCModifyUGCResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify existing content to update content metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content. </td></tr>
    <tr><td class="paramname">ModifyRequest</td><td>Detail information for the content request that will be modified. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d9/de7/struct_f_accel_byte_models_u_g_c_modify_u_g_c_response_v2.html">FAccelByteModelsUGCModifyUGCResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a6e67168f46aee9dd1ced5a6b19b0675e" name="a6e67168f46aee9dd1ced5a6b19b0675e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e67168f46aee9dd1ced5a6b19b0675e">&#9670;&#160;</a></span>PublicGetContentBulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::PublicGetContentBulk </td>
          <td>(</td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentIds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; TArray&lt; <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a> &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents by content Ids. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentIds</td><td>Content Ids Array <br  />
 </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a84437d772e65a62cf7b8a651a4e39174" name="a84437d772e65a62cf7b8a651a4e39174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84437d772e65a62cf7b8a651a4e39174">&#9670;&#160;</a></span>PublicGetContentBulkByIdsV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::PublicGetContentBulkByIdsV2 </td>
          <td>(</td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentIds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; TArray&lt; <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents by content Ids. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentIds</td><td>Content Ids Array </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is TArray&lt;FAccelByteModelsUGCContentResponseV2&gt;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a3069bab96bbd1f5a97cba562c3513dce" name="a3069bab96bbd1f5a97cba562c3513dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3069bab96bbd1f5a97cba562c3513dce">&#9670;&#160;</a></span>PublicGetContentByContentId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::PublicGetContentByContentId </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its content id. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="affb2ac2ea0c9dbcde3ff86808f9944c2" name="affb2ac2ea0c9dbcde3ff86808f9944c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb2ac2ea0c9dbcde3ff86808f9944c2">&#9670;&#160;</a></span>PublicGetContentByContentIdV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::PublicGetContentByContentIdV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its content id. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="aa3d1c8f8ea4ec222c2deb77fc846f347" name="aa3d1c8f8ea4ec222c2deb77fc846f347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d1c8f8ea4ec222c2deb77fc846f347">&#9670;&#160;</a></span>PublicGetContentByShareCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::PublicGetContentByShareCode </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its share code. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ShareCode</td><td>The share code of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../df/d7d/struct_f_accel_byte_models_u_g_c_content_response.html">FAccelByteModelsUGCContentResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a2d3ac29d46453a415d0e07d0ccc7c3f4" name="a2d3ac29d46453a415d0e07d0ccc7c3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3ac29d46453a415d0e07d0ccc7c3f4">&#9670;&#160;</a></span>PublicGetContentByShareCodeV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::PublicGetContentByShareCodeV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its share code. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ShareCode</td><td>The share code of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d3/d5b/struct_f_accel_byte_models_u_g_c_content_response_v2.html">FAccelByteModelsUGCContentResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="abe3b73ce78c6bbc0b4c48a2938bf422c" name="abe3b73ce78c6bbc0b4c48a2938bf422c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3b73ce78c6bbc0b4c48a2938bf422c">&#9670;&#160;</a></span>PublicGetUserContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::PublicGetUserContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d6/dd3/struct_f_accel_byte_models_u_g_c_content_page_response.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get user's generated contents. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td><a class="el" href="../../dc/d3f/class_accel_byte_1_1_api_1_1_user.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a04d27774c71251daa068515368cc568c" name="a04d27774c71251daa068515368cc568c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d27774c71251daa068515368cc568c">&#9670;&#160;</a></span>PublicGetUserContentsV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::PublicGetUserContentsV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentUtilitiesSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get user's generated contents. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td><a class="el" href="../../dc/d3f/class_accel_byte_1_1_api_1_1_user.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="afd14f87c9ae02b5d6e6ec43e837c919d" name="afd14f87c9ae02b5d6e6ec43e837c919d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd14f87c9ae02b5d6e6ec43e837c919d">&#9670;&#160;</a></span>PublicSearchContents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::PublicSearchContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/de7/struct_f_accel_byte_models_u_g_c_search_contents_request.html">FAccelByteModelsUGCSearchContentsRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>Request</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/d71/struct_f_accel_byte_models_u_g_c_search_contents_paging_response.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search specific contents based on the given filter. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Request</td><td>Filter request to specify the search result. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="af84e26abd94b7f62627f39faa2da3ae2" name="af84e26abd94b7f62627f39faa2da3ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84e26abd94b7f62627f39faa2da3ae2">&#9670;&#160;</a></span>PublicSearchContents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::PublicSearchContents </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Creator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Subtype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Tags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>IsOfficial</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/d71/struct_f_accel_byte_models_u_g_c_search_contents_paging_response.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcSortBy</td>          <td class="paramname"><span class="paramname"><em>SortBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcSortBy::DATE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcOrderBy</td>          <td class="paramname"><span class="paramname"><em>OrderBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcOrderBy::DESC</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search specific contents based on the given filter. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>Content Name. </td></tr>
    <tr><td class="paramname">Creator</td><td>Creator Name. </td></tr>
    <tr><td class="paramname">Type</td><td>Content Type. </td></tr>
    <tr><td class="paramname">Subtype</td><td>Content Subtype. </td></tr>
    <tr><td class="paramname">Tags</td><td>Content Tags. </td></tr>
    <tr><td class="paramname">IsOfficial</td><td>Filter only official contents </td></tr>
    <tr><td class="paramname">UserId</td><td><a class="el" href="../../dc/d3f/class_accel_byte_1_1_api_1_1_user.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria, name,download,like,date. default=date. </td></tr>
    <tr><td class="paramname">OrderBy</td><td>Sorting order: asc, desc. default=desc </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a2825533e3d2f26c108abe05cfd66e709" name="a2825533e3d2f26c108abe05cfd66e709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2825533e3d2f26c108abe05cfd66e709">&#9670;&#160;</a></span>PublicSearchContentsSpecificToChannelV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::PublicSearchContentsSpecificToChannelV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentUtilitiesSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search contents specific to a channel. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>Channel Id. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria: created time with asc or desc. default = created time and desc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ac342ee5673f01adad3bdf4adaf27f766" name="ac342ee5673f01adad3bdf4adaf27f766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac342ee5673f01adad3bdf4adaf27f766">&#9670;&#160;</a></span>PublicSearchContentsV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::PublicSearchContentsV2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/de2/struct_f_accel_byte_models_u_g_c_filter_request_v2.html">FAccelByteModelsUGCFilterRequestV2</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>Filter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentSortByV2::CREATED_TIME_DESC</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all contents in current namespace. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Filter</td><td>To filter the returned <a class="el" href="../../dc/d18/class_accel_byte_1_1_api_1_1_u_g_c.html" title="Provide APIs to access UGC service.">UGC</a> contets. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria: name, download, like, created time with asc or desc. default = created time and desc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a5c01de9f924be5ce5413f3321e22ff59" name="a5c01de9f924be5ce5413f3321e22ff59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c01de9f924be5ce5413f3321e22ff59">&#9670;&#160;</a></span>SearchContents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::SearchContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/de7/struct_f_accel_byte_models_u_g_c_search_contents_request.html">FAccelByteModelsUGCSearchContentsRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>Request</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/d71/struct_f_accel_byte_models_u_g_c_search_contents_paging_response.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search specific contents based on the given filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Request</td><td>Filter request to specify the search result. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ac4d7c841990b76ef6b6445dfe8dc6c1c" name="ac4d7c841990b76ef6b6445dfe8dc6c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d7c841990b76ef6b6445dfe8dc6c1c">&#9670;&#160;</a></span>SearchContents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::SearchContents </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Creator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Subtype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Tags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>IsOfficial</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/d71/struct_f_accel_byte_models_u_g_c_search_contents_paging_response.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcSortBy</td>          <td class="paramname"><span class="paramname"><em>SortBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcSortBy::DATE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcOrderBy</td>          <td class="paramname"><span class="paramname"><em>OrderBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcOrderBy::DESC</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search specific contents based on the given filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>Content Name. </td></tr>
    <tr><td class="paramname">Creator</td><td>Creator Name. </td></tr>
    <tr><td class="paramname">Type</td><td>Content Type. </td></tr>
    <tr><td class="paramname">Subtype</td><td>Content Subtype. </td></tr>
    <tr><td class="paramname">Tags</td><td>Content Tags. </td></tr>
    <tr><td class="paramname">IsOfficial</td><td>Filter only official contents </td></tr>
    <tr><td class="paramname">UserId</td><td><a class="el" href="../../dc/d3f/class_accel_byte_1_1_api_1_1_user.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria, name,download,like,date. default=date. </td></tr>
    <tr><td class="paramname">OrderBy</td><td>Sorting order: asc, desc. default=desc </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a68e7e5a6bbbc77424c5b198c56ad5d32" name="a68e7e5a6bbbc77424c5b198c56ad5d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e7e5a6bbbc77424c5b198c56ad5d32">&#9670;&#160;</a></span>SearchContentsSpecificToChannel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::SearchContentsSpecificToChannel </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/de7/struct_f_accel_byte_models_u_g_c_search_contents_request.html">FAccelByteModelsUGCSearchContentsRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>Request</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/d71/struct_f_accel_byte_models_u_g_c_search_contents_paging_response.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search contents specific to a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>Channel Id. </td></tr>
    <tr><td class="paramname">Request</td><td>Filter request to specify the search result. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a66d04e3e0daee390582322ecd41066fb" name="a66d04e3e0daee390582322ecd41066fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d04e3e0daee390582322ecd41066fb">&#9670;&#160;</a></span>SearchContentsSpecificToChannel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::SearchContentsSpecificToChannel </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Creator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Subtype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Tags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>IsOfficial</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/d71/struct_f_accel_byte_models_u_g_c_search_contents_paging_response.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcSortBy</td>          <td class="paramname"><span class="paramname"><em>SortBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcSortBy::DATE</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcOrderBy</td>          <td class="paramname"><span class="paramname"><em>OrderBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcOrderBy::DESC</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search contents specific to a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>Channel Id. </td></tr>
    <tr><td class="paramname">Name</td><td>Content Name. </td></tr>
    <tr><td class="paramname">Creator</td><td>Creator Name. </td></tr>
    <tr><td class="paramname">Type</td><td>Content Type. </td></tr>
    <tr><td class="paramname">Subtype</td><td>Content Subtype. </td></tr>
    <tr><td class="paramname">Tags</td><td>Content Tags. </td></tr>
    <tr><td class="paramname">IsOfficial</td><td>Filter only official contents </td></tr>
    <tr><td class="paramname">UserId</td><td><a class="el" href="../../dc/d3f/class_accel_byte_1_1_api_1_1_user.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria, name,download,like,date. default=date. </td></tr>
    <tr><td class="paramname">OrderBy</td><td>Sorting order: asc, desc. default=desc </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a250a39897cc58a0764b06c8e22fcaeef" name="a250a39897cc58a0764b06c8e22fcaeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250a39897cc58a0764b06c8e22fcaeef">&#9670;&#160;</a></span>SearchContentsSpecificToChannelV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::SearchContentsSpecificToChannelV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentUtilitiesSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search contents specific to a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>Channel Id. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria: created time with asc or desc. default = created time and desc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a852be2138aa2fb3dd112ae844b7ea98a" name="a852be2138aa2fb3dd112ae844b7ea98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852be2138aa2fb3dd112ae844b7ea98a">&#9670;&#160;</a></span>SearchContentsV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::SearchContentsV2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/de2/struct_f_accel_byte_models_u_g_c_filter_request_v2.html">FAccelByteModelsUGCFilterRequestV2</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>Filter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentSortByV2::CREATED_TIME_DESC</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all contents in current namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Filter</td><td>To filter the returned <a class="el" href="../../dc/d18/class_accel_byte_1_1_api_1_1_u_g_c.html" title="Provide APIs to access UGC service.">UGC</a> contets. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../de/dba/struct_f_accel_byte_models_u_g_c_search_contents_paging_response_v2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria: name, download, like, created time with asc or desc. default = created time and desc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a1887583a2adc10b741b9280f05219a46" name="a1887583a2adc10b741b9280f05219a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1887583a2adc10b741b9280f05219a46">&#9670;&#160;</a></span>UpdateChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::UpdateChannel </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d3/dc9/struct_f_accel_byte_models_u_g_c_channel_response.html">FAccelByteModelsUGCChannelResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a player's channel with specific channel name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the channel that will be updated. </td></tr>
    <tr><td class="paramname">ChannelName</td><td>The name of the channel. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d3/dc9/struct_f_accel_byte_models_u_g_c_channel_response.html">FAccelByteModelsUGCChannelResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a6a4fda93d1d19b299da7b264322a77c9" name="a6a4fda93d1d19b299da7b264322a77c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4fda93d1d19b299da7b264322a77c9">&#9670;&#160;</a></span>UpdateContentFileLocationV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::UpdateContentFileLocationV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>FileExtension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>S3Key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d5/d3a/struct_f_accel_byte_models_u_g_c_update_content_file_location_response_v2.html">FAccelByteModelsUGCUpdateContentFileLocationResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update Content File Location in S3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content. </td></tr>
    <tr><td class="paramname">FileExtension</td><td>FileExtension of the content. </td></tr>
    <tr><td class="paramname">S3Key</td><td>Detail information about the file location in S3. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../d5/d3a/struct_f_accel_byte_models_u_g_c_update_content_file_location_response_v2.html">FAccelByteModelsUGCUpdateContentFileLocationResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ab92127aa812da38f0d11cc875723d104" name="ab92127aa812da38f0d11cc875723d104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92127aa812da38f0d11cc875723d104">&#9670;&#160;</a></span>UpdateContentScreenshotV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::UpdateContentScreenshotV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d0d/struct_f_accel_byte_models_u_g_c_update_screenshots_v2.html">FAccelByteModelsUGCUpdateScreenshotsV2</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>ScreenshotsRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../da/d0d/struct_f_accel_byte_models_u_g_c_update_screenshots_v2.html">FAccelByteModelsUGCUpdateScreenshotsV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update screenshots for content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>Content Id. </td></tr>
    <tr><td class="paramname">ScreenshotsRequest</td><td>Screenshots Request Supported file extensions: pjp, jpg, jpeg, jfif, bmp, png. Maximum description length: 1024. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../da/d0d/struct_f_accel_byte_models_u_g_c_update_screenshots_v2.html">FAccelByteModelsUGCUpdateScreenshotsV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a001d433e9001ec490b30d6d5c25d723f" name="a001d433e9001ec490b30d6d5c25d723f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001d433e9001ec490b30d6d5c25d723f">&#9670;&#160;</a></span>UpdateFollowStatusToUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::UpdateFollowStatusToUser </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bFollowStatus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d2/dc6/struct_f_accel_byte_models_u_g_c_update_follow_status_to_user_response.html">FAccelByteModelsUGCUpdateFollowStatusToUserResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update follow/unfollow status to a user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td>The id of the user that will be updated. </td></tr>
    <tr><td class="paramname">bFollowStatus</td><td>The new follow status value. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a65e9aed5a33a0fe15406abbe1c36651d" name="a65e9aed5a33a0fe15406abbe1c36651d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e9aed5a33a0fe15406abbe1c36651d">&#9670;&#160;</a></span>UpdateLikeStatusToContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::UpdateLikeStatusToContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bLikeStatus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d2/d66/struct_f_accel_byte_models_u_g_c_update_like_status_to_content_response.html">FAccelByteModelsUGCUpdateLikeStatusToContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update like/unlike status to a content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The content id that will be updated. </td></tr>
    <tr><td class="paramname">bLikeStatus</td><td>New like Status value. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a5b4111c7a5376d256693091dfe44fc45" name="a5b4111c7a5376d256693091dfe44fc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4111c7a5376d256693091dfe44fc45">&#9670;&#160;</a></span>UpdateLikeStatusToContentV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::UpdateLikeStatusToContentV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bLikeStatus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../d2/d66/struct_f_accel_byte_models_u_g_c_update_like_status_to_content_response.html">FAccelByteModelsUGCUpdateLikeStatusToContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update like/unlike status to a content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The content id that will be updated. </td></tr>
    <tr><td class="paramname">bLikeStatus</td><td>New like Status value. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="ab198ac246549082f223718107f36d949" name="ab198ac246549082f223718107f36d949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab198ac246549082f223718107f36d949">&#9670;&#160;</a></span>UpdateStagingContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::UpdateStagingContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d41/struct_f_accel_byte_models_u_g_c_update_content_file_location_request_v2.html">FAccelByteModelsUGCUpdateContentFileLocationRequestV2</a></td>          <td class="paramname"><span class="paramname"><em>UpdateRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../df/d6f/struct_f_accel_byte_models_u_g_c_staging_content_response.html">FAccelByteModelsUGCStagingContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update staging content by content id using update request struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>Target content id to update the content </td></tr>
    <tr><td class="paramname">UpdateRequest</td><td>Query or params in struct to request an update </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is FAccelByteModelsStagingContentResponse. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a1c9f502108107d3a53d58b3f18c7e644" name="a1c9f502108107d3a53d58b3f18c7e644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9f502108107d3a53d58b3f18c7e644">&#9670;&#160;</a></span>UploadContentScreenshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::UploadContentScreenshot </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/dc4/struct_f_accel_byte_models_u_g_c_screenshots_request.html">FAccelByteModelsUGCScreenshotsRequest</a></td>          <td class="paramname"><span class="paramname"><em>ScreenshotsRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../dc/d1a/struct_f_accel_byte_models_u_g_c_update_content_screenshot_response.html">FAccelByteModelsUGCUpdateContentScreenshotResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upload screenshots for content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>Content Id. </td></tr>
    <tr><td class="paramname">UserId</td><td><a class="el" href="../../dc/d3f/class_accel_byte_1_1_api_1_1_user.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">ScreenshotsRequest</td><td>Screenshots Request <br  />
 Supported file extensions: pjp, jpg, jpeg, jfif, bmp, png. Maximum description length: 1024. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
<a id="a3f27487a7d06657253a836ccfbaccf58" name="a3f27487a7d06657253a836ccfbaccf58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f27487a7d06657253a836ccfbaccf58">&#9670;&#160;</a></span>UploadContentScreenshotV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FAccelByteTaskWPtr AccelByte::Api::UGC::UploadContentScreenshotV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d74/struct_f_accel_byte_models_u_g_c_upload_screenshots_request_v2.html">FAccelByteModelsUGCUploadScreenshotsRequestV2</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>ScreenshotsRequest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="../../dc/d1a/struct_f_accel_byte_models_u_g_c_update_content_screenshot_response.html">FAccelByteModelsUGCUpdateContentScreenshotResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upload screenshots for content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>Content Id. </td></tr>
    <tr><td class="paramname">ScreenshotsRequest</td><td>Screenshots Request. Supported file extensions: pjp, jpg, jpeg, jfif, bmp, png. Maximum description length: 1024. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="../../dc/d1a/struct_f_accel_byte_models_u_g_c_update_content_screenshot_response.html">FAccelByteModelsUGCUpdateContentScreenshotResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AccelByteTask object to track and cancel the ongoing API operation. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
