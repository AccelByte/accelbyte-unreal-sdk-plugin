/*@ fixed */

#if defined(_MSC_VER)
  #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
#endif
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: notification.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_notification_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_notification_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_notification_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_notification_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_notification_2eproto;
namespace session {
class DSInformationV1;
struct DSInformationV1DefaultTypeInternal;
extern DSInformationV1DefaultTypeInternal _DSInformationV1_default_instance_;
class DSStatusChangedNotificationV1;
struct DSStatusChangedNotificationV1DefaultTypeInternal;
extern DSStatusChangedNotificationV1DefaultTypeInternal _DSStatusChangedNotificationV1_default_instance_;
class GameServerV1;
struct GameServerV1DefaultTypeInternal;
extern GameServerV1DefaultTypeInternal _GameServerV1_default_instance_;
class GameSessionNotificationMembersChangedV1;
struct GameSessionNotificationMembersChangedV1DefaultTypeInternal;
extern GameSessionNotificationMembersChangedV1DefaultTypeInternal _GameSessionNotificationMembersChangedV1_default_instance_;
class GameSessionNotificationUserInvitedV1;
struct GameSessionNotificationUserInvitedV1DefaultTypeInternal;
extern GameSessionNotificationUserInvitedV1DefaultTypeInternal _GameSessionNotificationUserInvitedV1_default_instance_;
class GameSessionNotificationUserJoinedV1;
struct GameSessionNotificationUserJoinedV1DefaultTypeInternal;
extern GameSessionNotificationUserJoinedV1DefaultTypeInternal _GameSessionNotificationUserJoinedV1_default_instance_;
class GameSessionV1;
struct GameSessionV1DefaultTypeInternal;
extern GameSessionV1DefaultTypeInternal _GameSessionV1_default_instance_;
class NotificationEventEnvelope;
struct NotificationEventEnvelopeDefaultTypeInternal;
extern NotificationEventEnvelopeDefaultTypeInternal _NotificationEventEnvelope_default_instance_;
class PartyNotificationMembersChangedV1;
struct PartyNotificationMembersChangedV1DefaultTypeInternal;
extern PartyNotificationMembersChangedV1DefaultTypeInternal _PartyNotificationMembersChangedV1_default_instance_;
class PartyNotificationUserInvitedV1;
struct PartyNotificationUserInvitedV1DefaultTypeInternal;
extern PartyNotificationUserInvitedV1DefaultTypeInternal _PartyNotificationUserInvitedV1_default_instance_;
class PartyNotificationUserJoinedV1;
struct PartyNotificationUserJoinedV1DefaultTypeInternal;
extern PartyNotificationUserJoinedV1DefaultTypeInternal _PartyNotificationUserJoinedV1_default_instance_;
class PartyNotificationUserKickedV1;
struct PartyNotificationUserKickedV1DefaultTypeInternal;
extern PartyNotificationUserKickedV1DefaultTypeInternal _PartyNotificationUserKickedV1_default_instance_;
class PartyNotificationUserRejectV1;
struct PartyNotificationUserRejectV1DefaultTypeInternal;
extern PartyNotificationUserRejectV1DefaultTypeInternal _PartyNotificationUserRejectV1_default_instance_;
class PartySessionV1;
struct PartySessionV1DefaultTypeInternal;
extern PartySessionV1DefaultTypeInternal _PartySessionV1_default_instance_;
class SessionConfigV1;
struct SessionConfigV1DefaultTypeInternal;
extern SessionConfigV1DefaultTypeInternal _SessionConfigV1_default_instance_;
class Team;
struct TeamDefaultTypeInternal;
extern TeamDefaultTypeInternal _Team_default_instance_;
class UserIDs;
struct UserIDsDefaultTypeInternal;
extern UserIDsDefaultTypeInternal _UserIDs_default_instance_;
class UserV1;
struct UserV1DefaultTypeInternal;
extern UserV1DefaultTypeInternal _UserV1_default_instance_;
}  // namespace session
PROTOBUF_NAMESPACE_OPEN
template<> ::session::DSInformationV1* Arena::CreateMaybeMessage<::session::DSInformationV1>(Arena*);
template<> ::session::DSStatusChangedNotificationV1* Arena::CreateMaybeMessage<::session::DSStatusChangedNotificationV1>(Arena*);
template<> ::session::GameServerV1* Arena::CreateMaybeMessage<::session::GameServerV1>(Arena*);
template<> ::session::GameSessionNotificationMembersChangedV1* Arena::CreateMaybeMessage<::session::GameSessionNotificationMembersChangedV1>(Arena*);
template<> ::session::GameSessionNotificationUserInvitedV1* Arena::CreateMaybeMessage<::session::GameSessionNotificationUserInvitedV1>(Arena*);
template<> ::session::GameSessionNotificationUserJoinedV1* Arena::CreateMaybeMessage<::session::GameSessionNotificationUserJoinedV1>(Arena*);
template<> ::session::GameSessionV1* Arena::CreateMaybeMessage<::session::GameSessionV1>(Arena*);
template<> ::session::NotificationEventEnvelope* Arena::CreateMaybeMessage<::session::NotificationEventEnvelope>(Arena*);
template<> ::session::PartyNotificationMembersChangedV1* Arena::CreateMaybeMessage<::session::PartyNotificationMembersChangedV1>(Arena*);
template<> ::session::PartyNotificationUserInvitedV1* Arena::CreateMaybeMessage<::session::PartyNotificationUserInvitedV1>(Arena*);
template<> ::session::PartyNotificationUserJoinedV1* Arena::CreateMaybeMessage<::session::PartyNotificationUserJoinedV1>(Arena*);
template<> ::session::PartyNotificationUserKickedV1* Arena::CreateMaybeMessage<::session::PartyNotificationUserKickedV1>(Arena*);
template<> ::session::PartyNotificationUserRejectV1* Arena::CreateMaybeMessage<::session::PartyNotificationUserRejectV1>(Arena*);
template<> ::session::PartySessionV1* Arena::CreateMaybeMessage<::session::PartySessionV1>(Arena*);
template<> ::session::SessionConfigV1* Arena::CreateMaybeMessage<::session::SessionConfigV1>(Arena*);
template<> ::session::Team* Arena::CreateMaybeMessage<::session::Team>(Arena*);
template<> ::session::UserIDs* Arena::CreateMaybeMessage<::session::UserIDs>(Arena*);
template<> ::session::UserV1* Arena::CreateMaybeMessage<::session::UserV1>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace session {

// ===================================================================

class NotificationEventEnvelope final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.NotificationEventEnvelope) */ {
 public:
  inline NotificationEventEnvelope() : NotificationEventEnvelope(nullptr) {}
  ~NotificationEventEnvelope() override;
  explicit constexpr NotificationEventEnvelope(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotificationEventEnvelope(const NotificationEventEnvelope& from);
  NotificationEventEnvelope(NotificationEventEnvelope&& from) noexcept
    : NotificationEventEnvelope() {
    *this = ::std::move(from);
  }

  inline NotificationEventEnvelope& operator=(const NotificationEventEnvelope& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotificationEventEnvelope& operator=(NotificationEventEnvelope&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotificationEventEnvelope& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kPartyNotificationUserInvitedV1 = 1,
    kPartyNotificationUserJoinedV1 = 2,
    kPartyNotificationMembersChangedV1 = 3,
    kPartyNotificationUserRejectV1 = 4,
    kPartyNotificationUserKickedV1 = 5,
    kPartySessionV1 = 6,
    kGameSessionNotificationUserInvitedV1 = 7,
    kGameSessionNotificationUserJoinedV1 = 8,
    kGameSessionNotificationMembersChangedV1 = 9,
    kGameSessionV1 = 10,
    kDSStatusChangedNotificationV1 = 11,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const NotificationEventEnvelope* internal_default_instance() {
    return reinterpret_cast<const NotificationEventEnvelope*>(
               &_NotificationEventEnvelope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NotificationEventEnvelope& a, NotificationEventEnvelope& b) {
    a.Swap(&b);
  }
  inline void Swap(NotificationEventEnvelope* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotificationEventEnvelope* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotificationEventEnvelope* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotificationEventEnvelope>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotificationEventEnvelope& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NotificationEventEnvelope& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotificationEventEnvelope* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.NotificationEventEnvelope";
  }
  protected:
  explicit NotificationEventEnvelope(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartyNotificationUserInvitedV1FieldNumber = 1,
    kPartyNotificationUserJoinedV1FieldNumber = 2,
    kPartyNotificationMembersChangedV1FieldNumber = 3,
    kPartyNotificationUserRejectV1FieldNumber = 4,
    kPartyNotificationUserKickedV1FieldNumber = 5,
    kPartySessionV1FieldNumber = 6,
    kGameSessionNotificationUserInvitedV1FieldNumber = 7,
    kGameSessionNotificationUserJoinedV1FieldNumber = 8,
    kGameSessionNotificationMembersChangedV1FieldNumber = 9,
    kGameSessionV1FieldNumber = 10,
    kDSStatusChangedNotificationV1FieldNumber = 11,
  };
  // .session.PartyNotificationUserInvitedV1 PartyNotificationUserInvitedV1 = 1 [json_name = "OnPartyInvited"];
  bool has_partynotificationuserinvitedv1() const;
  private:
  bool _internal_has_partynotificationuserinvitedv1() const;
  public:
  void clear_partynotificationuserinvitedv1();
  const ::session::PartyNotificationUserInvitedV1& partynotificationuserinvitedv1() const;
  PROTOBUF_NODISCARD ::session::PartyNotificationUserInvitedV1* release_partynotificationuserinvitedv1();
  ::session::PartyNotificationUserInvitedV1* mutable_partynotificationuserinvitedv1();
  void set_allocated_partynotificationuserinvitedv1(::session::PartyNotificationUserInvitedV1* partynotificationuserinvitedv1);
  private:
  const ::session::PartyNotificationUserInvitedV1& _internal_partynotificationuserinvitedv1() const;
  ::session::PartyNotificationUserInvitedV1* _internal_mutable_partynotificationuserinvitedv1();
  public:
  void unsafe_arena_set_allocated_partynotificationuserinvitedv1(
      ::session::PartyNotificationUserInvitedV1* partynotificationuserinvitedv1);
  ::session::PartyNotificationUserInvitedV1* unsafe_arena_release_partynotificationuserinvitedv1();

  // .session.PartyNotificationUserJoinedV1 PartyNotificationUserJoinedV1 = 2 [json_name = "OnPartyJoined"];
  bool has_partynotificationuserjoinedv1() const;
  private:
  bool _internal_has_partynotificationuserjoinedv1() const;
  public:
  void clear_partynotificationuserjoinedv1();
  const ::session::PartyNotificationUserJoinedV1& partynotificationuserjoinedv1() const;
  PROTOBUF_NODISCARD ::session::PartyNotificationUserJoinedV1* release_partynotificationuserjoinedv1();
  ::session::PartyNotificationUserJoinedV1* mutable_partynotificationuserjoinedv1();
  void set_allocated_partynotificationuserjoinedv1(::session::PartyNotificationUserJoinedV1* partynotificationuserjoinedv1);
  private:
  const ::session::PartyNotificationUserJoinedV1& _internal_partynotificationuserjoinedv1() const;
  ::session::PartyNotificationUserJoinedV1* _internal_mutable_partynotificationuserjoinedv1();
  public:
  void unsafe_arena_set_allocated_partynotificationuserjoinedv1(
      ::session::PartyNotificationUserJoinedV1* partynotificationuserjoinedv1);
  ::session::PartyNotificationUserJoinedV1* unsafe_arena_release_partynotificationuserjoinedv1();

  // .session.PartyNotificationMembersChangedV1 PartyNotificationMembersChangedV1 = 3 [json_name = "OnPartyMembersChanged"];
  bool has_partynotificationmemberschangedv1() const;
  private:
  bool _internal_has_partynotificationmemberschangedv1() const;
  public:
  void clear_partynotificationmemberschangedv1();
  const ::session::PartyNotificationMembersChangedV1& partynotificationmemberschangedv1() const;
  PROTOBUF_NODISCARD ::session::PartyNotificationMembersChangedV1* release_partynotificationmemberschangedv1();
  ::session::PartyNotificationMembersChangedV1* mutable_partynotificationmemberschangedv1();
  void set_allocated_partynotificationmemberschangedv1(::session::PartyNotificationMembersChangedV1* partynotificationmemberschangedv1);
  private:
  const ::session::PartyNotificationMembersChangedV1& _internal_partynotificationmemberschangedv1() const;
  ::session::PartyNotificationMembersChangedV1* _internal_mutable_partynotificationmemberschangedv1();
  public:
  void unsafe_arena_set_allocated_partynotificationmemberschangedv1(
      ::session::PartyNotificationMembersChangedV1* partynotificationmemberschangedv1);
  ::session::PartyNotificationMembersChangedV1* unsafe_arena_release_partynotificationmemberschangedv1();

  // .session.PartyNotificationUserRejectV1 PartyNotificationUserRejectV1 = 4 [json_name = "OnPartyRejected"];
  bool has_partynotificationuserrejectv1() const;
  private:
  bool _internal_has_partynotificationuserrejectv1() const;
  public:
  void clear_partynotificationuserrejectv1();
  const ::session::PartyNotificationUserRejectV1& partynotificationuserrejectv1() const;
  PROTOBUF_NODISCARD ::session::PartyNotificationUserRejectV1* release_partynotificationuserrejectv1();
  ::session::PartyNotificationUserRejectV1* mutable_partynotificationuserrejectv1();
  void set_allocated_partynotificationuserrejectv1(::session::PartyNotificationUserRejectV1* partynotificationuserrejectv1);
  private:
  const ::session::PartyNotificationUserRejectV1& _internal_partynotificationuserrejectv1() const;
  ::session::PartyNotificationUserRejectV1* _internal_mutable_partynotificationuserrejectv1();
  public:
  void unsafe_arena_set_allocated_partynotificationuserrejectv1(
      ::session::PartyNotificationUserRejectV1* partynotificationuserrejectv1);
  ::session::PartyNotificationUserRejectV1* unsafe_arena_release_partynotificationuserrejectv1();

  // .session.PartyNotificationUserKickedV1 PartyNotificationUserKickedV1 = 5 [json_name = "OnPartyKicked"];
  bool has_partynotificationuserkickedv1() const;
  private:
  bool _internal_has_partynotificationuserkickedv1() const;
  public:
  void clear_partynotificationuserkickedv1();
  const ::session::PartyNotificationUserKickedV1& partynotificationuserkickedv1() const;
  PROTOBUF_NODISCARD ::session::PartyNotificationUserKickedV1* release_partynotificationuserkickedv1();
  ::session::PartyNotificationUserKickedV1* mutable_partynotificationuserkickedv1();
  void set_allocated_partynotificationuserkickedv1(::session::PartyNotificationUserKickedV1* partynotificationuserkickedv1);
  private:
  const ::session::PartyNotificationUserKickedV1& _internal_partynotificationuserkickedv1() const;
  ::session::PartyNotificationUserKickedV1* _internal_mutable_partynotificationuserkickedv1();
  public:
  void unsafe_arena_set_allocated_partynotificationuserkickedv1(
      ::session::PartyNotificationUserKickedV1* partynotificationuserkickedv1);
  ::session::PartyNotificationUserKickedV1* unsafe_arena_release_partynotificationuserkickedv1();

  // .session.PartySessionV1 PartySessionV1 = 6 [json_name = "OnPartyUpdated"];
  bool has_partysessionv1() const;
  private:
  bool _internal_has_partysessionv1() const;
  public:
  void clear_partysessionv1();
  const ::session::PartySessionV1& partysessionv1() const;
  PROTOBUF_NODISCARD ::session::PartySessionV1* release_partysessionv1();
  ::session::PartySessionV1* mutable_partysessionv1();
  void set_allocated_partysessionv1(::session::PartySessionV1* partysessionv1);
  private:
  const ::session::PartySessionV1& _internal_partysessionv1() const;
  ::session::PartySessionV1* _internal_mutable_partysessionv1();
  public:
  void unsafe_arena_set_allocated_partysessionv1(
      ::session::PartySessionV1* partysessionv1);
  ::session::PartySessionV1* unsafe_arena_release_partysessionv1();

  // .session.GameSessionNotificationUserInvitedV1 GameSessionNotificationUserInvitedV1 = 7 [json_name = "OnSessionInvited"];
  bool has_gamesessionnotificationuserinvitedv1() const;
  private:
  bool _internal_has_gamesessionnotificationuserinvitedv1() const;
  public:
  void clear_gamesessionnotificationuserinvitedv1();
  const ::session::GameSessionNotificationUserInvitedV1& gamesessionnotificationuserinvitedv1() const;
  PROTOBUF_NODISCARD ::session::GameSessionNotificationUserInvitedV1* release_gamesessionnotificationuserinvitedv1();
  ::session::GameSessionNotificationUserInvitedV1* mutable_gamesessionnotificationuserinvitedv1();
  void set_allocated_gamesessionnotificationuserinvitedv1(::session::GameSessionNotificationUserInvitedV1* gamesessionnotificationuserinvitedv1);
  private:
  const ::session::GameSessionNotificationUserInvitedV1& _internal_gamesessionnotificationuserinvitedv1() const;
  ::session::GameSessionNotificationUserInvitedV1* _internal_mutable_gamesessionnotificationuserinvitedv1();
  public:
  void unsafe_arena_set_allocated_gamesessionnotificationuserinvitedv1(
      ::session::GameSessionNotificationUserInvitedV1* gamesessionnotificationuserinvitedv1);
  ::session::GameSessionNotificationUserInvitedV1* unsafe_arena_release_gamesessionnotificationuserinvitedv1();

  // .session.GameSessionNotificationUserJoinedV1 GameSessionNotificationUserJoinedV1 = 8 [json_name = "OnSessionJoined"];
  bool has_gamesessionnotificationuserjoinedv1() const;
  private:
  bool _internal_has_gamesessionnotificationuserjoinedv1() const;
  public:
  void clear_gamesessionnotificationuserjoinedv1();
  const ::session::GameSessionNotificationUserJoinedV1& gamesessionnotificationuserjoinedv1() const;
  PROTOBUF_NODISCARD ::session::GameSessionNotificationUserJoinedV1* release_gamesessionnotificationuserjoinedv1();
  ::session::GameSessionNotificationUserJoinedV1* mutable_gamesessionnotificationuserjoinedv1();
  void set_allocated_gamesessionnotificationuserjoinedv1(::session::GameSessionNotificationUserJoinedV1* gamesessionnotificationuserjoinedv1);
  private:
  const ::session::GameSessionNotificationUserJoinedV1& _internal_gamesessionnotificationuserjoinedv1() const;
  ::session::GameSessionNotificationUserJoinedV1* _internal_mutable_gamesessionnotificationuserjoinedv1();
  public:
  void unsafe_arena_set_allocated_gamesessionnotificationuserjoinedv1(
      ::session::GameSessionNotificationUserJoinedV1* gamesessionnotificationuserjoinedv1);
  ::session::GameSessionNotificationUserJoinedV1* unsafe_arena_release_gamesessionnotificationuserjoinedv1();

  // .session.GameSessionNotificationMembersChangedV1 GameSessionNotificationMembersChangedV1 = 9 [json_name = "OnSessionMembersChanged"];
  bool has_gamesessionnotificationmemberschangedv1() const;
  private:
  bool _internal_has_gamesessionnotificationmemberschangedv1() const;
  public:
  void clear_gamesessionnotificationmemberschangedv1();
  const ::session::GameSessionNotificationMembersChangedV1& gamesessionnotificationmemberschangedv1() const;
  PROTOBUF_NODISCARD ::session::GameSessionNotificationMembersChangedV1* release_gamesessionnotificationmemberschangedv1();
  ::session::GameSessionNotificationMembersChangedV1* mutable_gamesessionnotificationmemberschangedv1();
  void set_allocated_gamesessionnotificationmemberschangedv1(::session::GameSessionNotificationMembersChangedV1* gamesessionnotificationmemberschangedv1);
  private:
  const ::session::GameSessionNotificationMembersChangedV1& _internal_gamesessionnotificationmemberschangedv1() const;
  ::session::GameSessionNotificationMembersChangedV1* _internal_mutable_gamesessionnotificationmemberschangedv1();
  public:
  void unsafe_arena_set_allocated_gamesessionnotificationmemberschangedv1(
      ::session::GameSessionNotificationMembersChangedV1* gamesessionnotificationmemberschangedv1);
  ::session::GameSessionNotificationMembersChangedV1* unsafe_arena_release_gamesessionnotificationmemberschangedv1();

  // .session.GameSessionV1 GameSessionV1 = 10 [json_name = "OnGameSessionUpdated"];
  bool has_gamesessionv1() const;
  private:
  bool _internal_has_gamesessionv1() const;
  public:
  void clear_gamesessionv1();
  const ::session::GameSessionV1& gamesessionv1() const;
  PROTOBUF_NODISCARD ::session::GameSessionV1* release_gamesessionv1();
  ::session::GameSessionV1* mutable_gamesessionv1();
  void set_allocated_gamesessionv1(::session::GameSessionV1* gamesessionv1);
  private:
  const ::session::GameSessionV1& _internal_gamesessionv1() const;
  ::session::GameSessionV1* _internal_mutable_gamesessionv1();
  public:
  void unsafe_arena_set_allocated_gamesessionv1(
      ::session::GameSessionV1* gamesessionv1);
  ::session::GameSessionV1* unsafe_arena_release_gamesessionv1();

  // .session.DSStatusChangedNotificationV1 DSStatusChangedNotificationV1 = 11 [json_name = "OnDSStatusChangedNotif"];
  bool has_dsstatuschangednotificationv1() const;
  private:
  bool _internal_has_dsstatuschangednotificationv1() const;
  public:
  void clear_dsstatuschangednotificationv1();
  const ::session::DSStatusChangedNotificationV1& dsstatuschangednotificationv1() const;
  PROTOBUF_NODISCARD ::session::DSStatusChangedNotificationV1* release_dsstatuschangednotificationv1();
  ::session::DSStatusChangedNotificationV1* mutable_dsstatuschangednotificationv1();
  void set_allocated_dsstatuschangednotificationv1(::session::DSStatusChangedNotificationV1* dsstatuschangednotificationv1);
  private:
  const ::session::DSStatusChangedNotificationV1& _internal_dsstatuschangednotificationv1() const;
  ::session::DSStatusChangedNotificationV1* _internal_mutable_dsstatuschangednotificationv1();
  public:
  void unsafe_arena_set_allocated_dsstatuschangednotificationv1(
      ::session::DSStatusChangedNotificationV1* dsstatuschangednotificationv1);
  ::session::DSStatusChangedNotificationV1* unsafe_arena_release_dsstatuschangednotificationv1();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:session.NotificationEventEnvelope)
 private:
  class _Internal;
  void set_has_partynotificationuserinvitedv1();
  void set_has_partynotificationuserjoinedv1();
  void set_has_partynotificationmemberschangedv1();
  void set_has_partynotificationuserrejectv1();
  void set_has_partynotificationuserkickedv1();
  void set_has_partysessionv1();
  void set_has_gamesessionnotificationuserinvitedv1();
  void set_has_gamesessionnotificationuserjoinedv1();
  void set_has_gamesessionnotificationmemberschangedv1();
  void set_has_gamesessionv1();
  void set_has_dsstatuschangednotificationv1();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PayloadUnion {
    constexpr PayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::session::PartyNotificationUserInvitedV1* partynotificationuserinvitedv1_;
    ::session::PartyNotificationUserJoinedV1* partynotificationuserjoinedv1_;
    ::session::PartyNotificationMembersChangedV1* partynotificationmemberschangedv1_;
    ::session::PartyNotificationUserRejectV1* partynotificationuserrejectv1_;
    ::session::PartyNotificationUserKickedV1* partynotificationuserkickedv1_;
    ::session::PartySessionV1* partysessionv1_;
    ::session::GameSessionNotificationUserInvitedV1* gamesessionnotificationuserinvitedv1_;
    ::session::GameSessionNotificationUserJoinedV1* gamesessionnotificationuserjoinedv1_;
    ::session::GameSessionNotificationMembersChangedV1* gamesessionnotificationmemberschangedv1_;
    ::session::GameSessionV1* gamesessionv1_;
    ::session::DSStatusChangedNotificationV1* dsstatuschangednotificationv1_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class UserV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.UserV1) */ {
 public:
  inline UserV1() : UserV1(nullptr) {}
  ~UserV1() override;
  explicit constexpr UserV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserV1(const UserV1& from);
  UserV1(UserV1&& from) noexcept
    : UserV1() {
    *this = ::std::move(from);
  }

  inline UserV1& operator=(const UserV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserV1& operator=(UserV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserV1* internal_default_instance() {
    return reinterpret_cast<const UserV1*>(
               &_UserV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserV1& a, UserV1& b) {
    a.Swap(&b);
  }
  inline void Swap(UserV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.UserV1";
  }
  protected:
  explicit UserV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStatusFieldNumber = 2,
    kUpdatedAtFieldNumber = 3,
    kPlatformIdFieldNumber = 4,
    kPlatformUserIdFieldNumber = 5,
  };
  // string id = 1 [json_name = "_id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string status = 2 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string updatedAt = 3 [json_name = "updatedAt"];
  void clear_updatedat();
  const std::string& updatedat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updatedat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updatedat();
  PROTOBUF_NODISCARD std::string* release_updatedat();
  void set_allocated_updatedat(std::string* updatedat);
  private:
  const std::string& _internal_updatedat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updatedat(const std::string& value);
  std::string* _internal_mutable_updatedat();
  public:

  // string platform_id = 4 [json_name = "platformID"];
  void clear_platform_id();
  const std::string& platform_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform_id();
  PROTOBUF_NODISCARD std::string* release_platform_id();
  void set_allocated_platform_id(std::string* platform_id);
  private:
  const std::string& _internal_platform_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform_id(const std::string& value);
  std::string* _internal_mutable_platform_id();
  public:

  // string platform_user_id = 5 [json_name = "platformUserID"];
  void clear_platform_user_id();
  const std::string& platform_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform_user_id();
  PROTOBUF_NODISCARD std::string* release_platform_user_id();
  void set_allocated_platform_user_id(std::string* platform_user_id);
  private:
  const std::string& _internal_platform_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform_user_id(const std::string& value);
  std::string* _internal_mutable_platform_user_id();
  public:

  // @@protoc_insertion_point(class_scope:session.UserV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updatedat_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class SessionConfigV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.SessionConfigV1) */ {
 public:
  inline SessionConfigV1() : SessionConfigV1(nullptr) {}
  ~SessionConfigV1() override;
  explicit constexpr SessionConfigV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionConfigV1(const SessionConfigV1& from);
  SessionConfigV1(SessionConfigV1&& from) noexcept
    : SessionConfigV1() {
    *this = ::std::move(from);
  }

  inline SessionConfigV1& operator=(const SessionConfigV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionConfigV1& operator=(SessionConfigV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionConfigV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionConfigV1* internal_default_instance() {
    return reinterpret_cast<const SessionConfigV1*>(
               &_SessionConfigV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SessionConfigV1& a, SessionConfigV1& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionConfigV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionConfigV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionConfigV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionConfigV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionConfigV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionConfigV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionConfigV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.SessionConfigV1";
  }
  protected:
  explicit SessionConfigV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxSizeFieldNumber = 1,
    kInitialJoinTimeoutFieldNumber = 2,
    kRejoinTimeoutFieldNumber = 3,
  };
  // int32 max_size = 1 [json_name = "maxSize"];
  void clear_max_size();
  int32_t max_size() const;
  void set_max_size(int32_t value);
  private:
  int32_t _internal_max_size() const;
  void _internal_set_max_size(int32_t value);
  public:

  // int32 initial_join_timeout = 2 [json_name = "initialJoinTimeout"];
  void clear_initial_join_timeout();
  int32_t initial_join_timeout() const;
  void set_initial_join_timeout(int32_t value);
  private:
  int32_t _internal_initial_join_timeout() const;
  void _internal_set_initial_join_timeout(int32_t value);
  public:

  // int32 rejoin_timeout = 3 [json_name = "rejoinTimeout"];
  void clear_rejoin_timeout();
  int32_t rejoin_timeout() const;
  void set_rejoin_timeout(int32_t value);
  private:
  int32_t _internal_rejoin_timeout() const;
  void _internal_set_rejoin_timeout(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:session.SessionConfigV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t max_size_;
  int32_t initial_join_timeout_;
  int32_t rejoin_timeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class PartySessionV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.PartySessionV1) */ {
 public:
  inline PartySessionV1() : PartySessionV1(nullptr) {}
  ~PartySessionV1() override;
  explicit constexpr PartySessionV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartySessionV1(const PartySessionV1& from);
  PartySessionV1(PartySessionV1&& from) noexcept
    : PartySessionV1() {
    *this = ::std::move(from);
  }

  inline PartySessionV1& operator=(const PartySessionV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartySessionV1& operator=(PartySessionV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartySessionV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartySessionV1* internal_default_instance() {
    return reinterpret_cast<const PartySessionV1*>(
               &_PartySessionV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PartySessionV1& a, PartySessionV1& b) {
    a.Swap(&b);
  }
  inline void Swap(PartySessionV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartySessionV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartySessionV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartySessionV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartySessionV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PartySessionV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartySessionV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.PartySessionV1";
  }
  protected:
  explicit PartySessionV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 3,
    kIdFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kAttributesFieldNumber = 4,
    kJoinTypeFieldNumber = 5,
    kCreatedAtFieldNumber = 6,
    kUpdatedAtFieldNumber = 7,
    kLeaderIdFieldNumber = 10,
    kConfigFieldNumber = 8,
    kVersionFieldNumber = 9,
  };
  // repeated .session.UserV1 members = 3 [json_name = "members"];
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::session::UserV1* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >*
      mutable_members();
  private:
  const ::session::UserV1& _internal_members(int index) const;
  ::session::UserV1* _internal_add_members();
  public:
  const ::session::UserV1& members(int index) const;
  ::session::UserV1* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >&
      members() const;

  // string id = 1 [json_name = "_id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string namespace = 2 [json_name = "namespace"];
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // bytes attributes = 4 [json_name = "attributes"];
  void clear_attributes();
  const std::string& attributes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attributes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attributes();
  PROTOBUF_NODISCARD std::string* release_attributes();
  void set_allocated_attributes(std::string* attributes);
  private:
  const std::string& _internal_attributes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attributes(const std::string& value);
  std::string* _internal_mutable_attributes();
  public:

  // string join_type = 5 [json_name = "joinType"];
  void clear_join_type();
  const std::string& join_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_join_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_join_type();
  PROTOBUF_NODISCARD std::string* release_join_type();
  void set_allocated_join_type(std::string* join_type);
  private:
  const std::string& _internal_join_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_join_type(const std::string& value);
  std::string* _internal_mutable_join_type();
  public:

  // string created_at = 6 [json_name = "createdAt"];
  void clear_created_at();
  const std::string& created_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* created_at);
  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(const std::string& value);
  std::string* _internal_mutable_created_at();
  public:

  // string updated_at = 7 [json_name = "updatedAt"];
  void clear_updated_at();
  const std::string& updated_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updated_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updated_at();
  PROTOBUF_NODISCARD std::string* release_updated_at();
  void set_allocated_updated_at(std::string* updated_at);
  private:
  const std::string& _internal_updated_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_at(const std::string& value);
  std::string* _internal_mutable_updated_at();
  public:

  // string leader_id = 10 [json_name = "leaderID"];
  void clear_leader_id();
  const std::string& leader_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader_id();
  PROTOBUF_NODISCARD std::string* release_leader_id();
  void set_allocated_leader_id(std::string* leader_id);
  private:
  const std::string& _internal_leader_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader_id(const std::string& value);
  std::string* _internal_mutable_leader_id();
  public:

  // .session.SessionConfigV1 config = 8 [json_name = "config"];
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::session::SessionConfigV1& config() const;
  PROTOBUF_NODISCARD ::session::SessionConfigV1* release_config();
  ::session::SessionConfigV1* mutable_config();
  void set_allocated_config(::session::SessionConfigV1* config);
  private:
  const ::session::SessionConfigV1& _internal_config() const;
  ::session::SessionConfigV1* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::session::SessionConfigV1* config);
  ::session::SessionConfigV1* unsafe_arena_release_config();

  // int32 version = 9 [json_name = "_version"];
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:session.PartySessionV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 > members_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr join_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_at_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updated_at_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_id_;
  ::session::SessionConfigV1* config_;
  int32_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class PartyNotificationUserJoinedV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.PartyNotificationUserJoinedV1) */ {
 public:
  inline PartyNotificationUserJoinedV1() : PartyNotificationUserJoinedV1(nullptr) {}
  ~PartyNotificationUserJoinedV1() override;
  explicit constexpr PartyNotificationUserJoinedV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartyNotificationUserJoinedV1(const PartyNotificationUserJoinedV1& from);
  PartyNotificationUserJoinedV1(PartyNotificationUserJoinedV1&& from) noexcept
    : PartyNotificationUserJoinedV1() {
    *this = ::std::move(from);
  }

  inline PartyNotificationUserJoinedV1& operator=(const PartyNotificationUserJoinedV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyNotificationUserJoinedV1& operator=(PartyNotificationUserJoinedV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartyNotificationUserJoinedV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartyNotificationUserJoinedV1* internal_default_instance() {
    return reinterpret_cast<const PartyNotificationUserJoinedV1*>(
               &_PartyNotificationUserJoinedV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PartyNotificationUserJoinedV1& a, PartyNotificationUserJoinedV1& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyNotificationUserJoinedV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyNotificationUserJoinedV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartyNotificationUserJoinedV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartyNotificationUserJoinedV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartyNotificationUserJoinedV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PartyNotificationUserJoinedV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyNotificationUserJoinedV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.PartyNotificationUserJoinedV1";
  }
  protected:
  explicit PartyNotificationUserJoinedV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 1,
    kPartyIDFieldNumber = 2,
  };
  // repeated .session.UserV1 members = 1 [json_name = "members"];
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::session::UserV1* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >*
      mutable_members();
  private:
  const ::session::UserV1& _internal_members(int index) const;
  ::session::UserV1* _internal_add_members();
  public:
  const ::session::UserV1& members(int index) const;
  ::session::UserV1* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >&
      members() const;

  // string PartyID = 2 [json_name = "partyID"];
  void clear_partyid();
  const std::string& partyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partyid();
  PROTOBUF_NODISCARD std::string* release_partyid();
  void set_allocated_partyid(std::string* partyid);
  private:
  const std::string& _internal_partyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partyid(const std::string& value);
  std::string* _internal_mutable_partyid();
  public:

  // @@protoc_insertion_point(class_scope:session.PartyNotificationUserJoinedV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 > members_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partyid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class PartyNotificationMembersChangedV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.PartyNotificationMembersChangedV1) */ {
 public:
  inline PartyNotificationMembersChangedV1() : PartyNotificationMembersChangedV1(nullptr) {}
  ~PartyNotificationMembersChangedV1() override;
  explicit constexpr PartyNotificationMembersChangedV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartyNotificationMembersChangedV1(const PartyNotificationMembersChangedV1& from);
  PartyNotificationMembersChangedV1(PartyNotificationMembersChangedV1&& from) noexcept
    : PartyNotificationMembersChangedV1() {
    *this = ::std::move(from);
  }

  inline PartyNotificationMembersChangedV1& operator=(const PartyNotificationMembersChangedV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyNotificationMembersChangedV1& operator=(PartyNotificationMembersChangedV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartyNotificationMembersChangedV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartyNotificationMembersChangedV1* internal_default_instance() {
    return reinterpret_cast<const PartyNotificationMembersChangedV1*>(
               &_PartyNotificationMembersChangedV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PartyNotificationMembersChangedV1& a, PartyNotificationMembersChangedV1& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyNotificationMembersChangedV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyNotificationMembersChangedV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartyNotificationMembersChangedV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartyNotificationMembersChangedV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartyNotificationMembersChangedV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PartyNotificationMembersChangedV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyNotificationMembersChangedV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.PartyNotificationMembersChangedV1";
  }
  protected:
  explicit PartyNotificationMembersChangedV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 1,
    kPartyIDFieldNumber = 2,
    kJoinerIDFieldNumber = 3,
    kLeaderIDFieldNumber = 4,
  };
  // repeated .session.UserV1 members = 1 [json_name = "members"];
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::session::UserV1* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >*
      mutable_members();
  private:
  const ::session::UserV1& _internal_members(int index) const;
  ::session::UserV1* _internal_add_members();
  public:
  const ::session::UserV1& members(int index) const;
  ::session::UserV1* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >&
      members() const;

  // string PartyID = 2 [json_name = "partyID"];
  void clear_partyid();
  const std::string& partyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partyid();
  PROTOBUF_NODISCARD std::string* release_partyid();
  void set_allocated_partyid(std::string* partyid);
  private:
  const std::string& _internal_partyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partyid(const std::string& value);
  std::string* _internal_mutable_partyid();
  public:

  // string JoinerID = 3 [json_name = "joinerID"];
  void clear_joinerid();
  const std::string& joinerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_joinerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_joinerid();
  PROTOBUF_NODISCARD std::string* release_joinerid();
  void set_allocated_joinerid(std::string* joinerid);
  private:
  const std::string& _internal_joinerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_joinerid(const std::string& value);
  std::string* _internal_mutable_joinerid();
  public:

  // string LeaderID = 4 [json_name = "leaderID"];
  void clear_leaderid();
  const std::string& leaderid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leaderid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leaderid();
  PROTOBUF_NODISCARD std::string* release_leaderid();
  void set_allocated_leaderid(std::string* leaderid);
  private:
  const std::string& _internal_leaderid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leaderid(const std::string& value);
  std::string* _internal_mutable_leaderid();
  public:

  // @@protoc_insertion_point(class_scope:session.PartyNotificationMembersChangedV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 > members_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partyid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr joinerid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leaderid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class PartyNotificationUserInvitedV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.PartyNotificationUserInvitedV1) */ {
 public:
  inline PartyNotificationUserInvitedV1() : PartyNotificationUserInvitedV1(nullptr) {}
  ~PartyNotificationUserInvitedV1() override;
  explicit constexpr PartyNotificationUserInvitedV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartyNotificationUserInvitedV1(const PartyNotificationUserInvitedV1& from);
  PartyNotificationUserInvitedV1(PartyNotificationUserInvitedV1&& from) noexcept
    : PartyNotificationUserInvitedV1() {
    *this = ::std::move(from);
  }

  inline PartyNotificationUserInvitedV1& operator=(const PartyNotificationUserInvitedV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyNotificationUserInvitedV1& operator=(PartyNotificationUserInvitedV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartyNotificationUserInvitedV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartyNotificationUserInvitedV1* internal_default_instance() {
    return reinterpret_cast<const PartyNotificationUserInvitedV1*>(
               &_PartyNotificationUserInvitedV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PartyNotificationUserInvitedV1& a, PartyNotificationUserInvitedV1& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyNotificationUserInvitedV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyNotificationUserInvitedV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartyNotificationUserInvitedV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartyNotificationUserInvitedV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartyNotificationUserInvitedV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PartyNotificationUserInvitedV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyNotificationUserInvitedV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.PartyNotificationUserInvitedV1";
  }
  protected:
  explicit PartyNotificationUserInvitedV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderIDFieldNumber = 1,
    kPartyIDFieldNumber = 2,
  };
  // string senderID = 1 [json_name = "senderID"];
  void clear_senderid();
  const std::string& senderid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_senderid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_senderid();
  PROTOBUF_NODISCARD std::string* release_senderid();
  void set_allocated_senderid(std::string* senderid);
  private:
  const std::string& _internal_senderid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_senderid(const std::string& value);
  std::string* _internal_mutable_senderid();
  public:

  // string PartyID = 2 [json_name = "partyID"];
  void clear_partyid();
  const std::string& partyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partyid();
  PROTOBUF_NODISCARD std::string* release_partyid();
  void set_allocated_partyid(std::string* partyid);
  private:
  const std::string& _internal_partyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partyid(const std::string& value);
  std::string* _internal_mutable_partyid();
  public:

  // @@protoc_insertion_point(class_scope:session.PartyNotificationUserInvitedV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr senderid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partyid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class PartyNotificationUserRejectV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.PartyNotificationUserRejectV1) */ {
 public:
  inline PartyNotificationUserRejectV1() : PartyNotificationUserRejectV1(nullptr) {}
  ~PartyNotificationUserRejectV1() override;
  explicit constexpr PartyNotificationUserRejectV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartyNotificationUserRejectV1(const PartyNotificationUserRejectV1& from);
  PartyNotificationUserRejectV1(PartyNotificationUserRejectV1&& from) noexcept
    : PartyNotificationUserRejectV1() {
    *this = ::std::move(from);
  }

  inline PartyNotificationUserRejectV1& operator=(const PartyNotificationUserRejectV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyNotificationUserRejectV1& operator=(PartyNotificationUserRejectV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartyNotificationUserRejectV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartyNotificationUserRejectV1* internal_default_instance() {
    return reinterpret_cast<const PartyNotificationUserRejectV1*>(
               &_PartyNotificationUserRejectV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PartyNotificationUserRejectV1& a, PartyNotificationUserRejectV1& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyNotificationUserRejectV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyNotificationUserRejectV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartyNotificationUserRejectV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartyNotificationUserRejectV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartyNotificationUserRejectV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PartyNotificationUserRejectV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyNotificationUserRejectV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.PartyNotificationUserRejectV1";
  }
  protected:
  explicit PartyNotificationUserRejectV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 1,
    kPartyIDFieldNumber = 2,
    kRejectedIDFieldNumber = 3,
  };
  // repeated .session.UserV1 members = 1 [json_name = "members"];
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::session::UserV1* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >*
      mutable_members();
  private:
  const ::session::UserV1& _internal_members(int index) const;
  ::session::UserV1* _internal_add_members();
  public:
  const ::session::UserV1& members(int index) const;
  ::session::UserV1* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >&
      members() const;

  // string PartyID = 2 [json_name = "partyID"];
  void clear_partyid();
  const std::string& partyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partyid();
  PROTOBUF_NODISCARD std::string* release_partyid();
  void set_allocated_partyid(std::string* partyid);
  private:
  const std::string& _internal_partyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partyid(const std::string& value);
  std::string* _internal_mutable_partyid();
  public:

  // string RejectedID = 3 [json_name = "rejectedID"];
  void clear_rejectedid();
  const std::string& rejectedid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rejectedid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rejectedid();
  PROTOBUF_NODISCARD std::string* release_rejectedid();
  void set_allocated_rejectedid(std::string* rejectedid);
  private:
  const std::string& _internal_rejectedid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rejectedid(const std::string& value);
  std::string* _internal_mutable_rejectedid();
  public:

  // @@protoc_insertion_point(class_scope:session.PartyNotificationUserRejectV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 > members_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partyid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rejectedid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class PartyNotificationUserKickedV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.PartyNotificationUserKickedV1) */ {
 public:
  inline PartyNotificationUserKickedV1() : PartyNotificationUserKickedV1(nullptr) {}
  ~PartyNotificationUserKickedV1() override;
  explicit constexpr PartyNotificationUserKickedV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartyNotificationUserKickedV1(const PartyNotificationUserKickedV1& from);
  PartyNotificationUserKickedV1(PartyNotificationUserKickedV1&& from) noexcept
    : PartyNotificationUserKickedV1() {
    *this = ::std::move(from);
  }

  inline PartyNotificationUserKickedV1& operator=(const PartyNotificationUserKickedV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartyNotificationUserKickedV1& operator=(PartyNotificationUserKickedV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartyNotificationUserKickedV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartyNotificationUserKickedV1* internal_default_instance() {
    return reinterpret_cast<const PartyNotificationUserKickedV1*>(
               &_PartyNotificationUserKickedV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PartyNotificationUserKickedV1& a, PartyNotificationUserKickedV1& b) {
    a.Swap(&b);
  }
  inline void Swap(PartyNotificationUserKickedV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartyNotificationUserKickedV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartyNotificationUserKickedV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartyNotificationUserKickedV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartyNotificationUserKickedV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PartyNotificationUserKickedV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartyNotificationUserKickedV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.PartyNotificationUserKickedV1";
  }
  protected:
  explicit PartyNotificationUserKickedV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartyIDFieldNumber = 1,
  };
  // string PartyID = 1 [json_name = "partyID"];
  void clear_partyid();
  const std::string& partyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partyid();
  PROTOBUF_NODISCARD std::string* release_partyid();
  void set_allocated_partyid(std::string* partyid);
  private:
  const std::string& _internal_partyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partyid(const std::string& value);
  std::string* _internal_mutable_partyid();
  public:

  // @@protoc_insertion_point(class_scope:session.PartyNotificationUserKickedV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partyid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class GameSessionNotificationUserInvitedV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.GameSessionNotificationUserInvitedV1) */ {
 public:
  inline GameSessionNotificationUserInvitedV1() : GameSessionNotificationUserInvitedV1(nullptr) {}
  ~GameSessionNotificationUserInvitedV1() override;
  explicit constexpr GameSessionNotificationUserInvitedV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameSessionNotificationUserInvitedV1(const GameSessionNotificationUserInvitedV1& from);
  GameSessionNotificationUserInvitedV1(GameSessionNotificationUserInvitedV1&& from) noexcept
    : GameSessionNotificationUserInvitedV1() {
    *this = ::std::move(from);
  }

  inline GameSessionNotificationUserInvitedV1& operator=(const GameSessionNotificationUserInvitedV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameSessionNotificationUserInvitedV1& operator=(GameSessionNotificationUserInvitedV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameSessionNotificationUserInvitedV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameSessionNotificationUserInvitedV1* internal_default_instance() {
    return reinterpret_cast<const GameSessionNotificationUserInvitedV1*>(
               &_GameSessionNotificationUserInvitedV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GameSessionNotificationUserInvitedV1& a, GameSessionNotificationUserInvitedV1& b) {
    a.Swap(&b);
  }
  inline void Swap(GameSessionNotificationUserInvitedV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameSessionNotificationUserInvitedV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameSessionNotificationUserInvitedV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameSessionNotificationUserInvitedV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameSessionNotificationUserInvitedV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameSessionNotificationUserInvitedV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameSessionNotificationUserInvitedV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.GameSessionNotificationUserInvitedV1";
  }
  protected:
  explicit GameSessionNotificationUserInvitedV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIDFieldNumber = 1,
  };
  // string SessionID = 1 [json_name = "SessionID"];
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // @@protoc_insertion_point(class_scope:session.GameSessionNotificationUserInvitedV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class GameSessionNotificationUserJoinedV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.GameSessionNotificationUserJoinedV1) */ {
 public:
  inline GameSessionNotificationUserJoinedV1() : GameSessionNotificationUserJoinedV1(nullptr) {}
  ~GameSessionNotificationUserJoinedV1() override;
  explicit constexpr GameSessionNotificationUserJoinedV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameSessionNotificationUserJoinedV1(const GameSessionNotificationUserJoinedV1& from);
  GameSessionNotificationUserJoinedV1(GameSessionNotificationUserJoinedV1&& from) noexcept
    : GameSessionNotificationUserJoinedV1() {
    *this = ::std::move(from);
  }

  inline GameSessionNotificationUserJoinedV1& operator=(const GameSessionNotificationUserJoinedV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameSessionNotificationUserJoinedV1& operator=(GameSessionNotificationUserJoinedV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameSessionNotificationUserJoinedV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameSessionNotificationUserJoinedV1* internal_default_instance() {
    return reinterpret_cast<const GameSessionNotificationUserJoinedV1*>(
               &_GameSessionNotificationUserJoinedV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GameSessionNotificationUserJoinedV1& a, GameSessionNotificationUserJoinedV1& b) {
    a.Swap(&b);
  }
  inline void Swap(GameSessionNotificationUserJoinedV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameSessionNotificationUserJoinedV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameSessionNotificationUserJoinedV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameSessionNotificationUserJoinedV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameSessionNotificationUserJoinedV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameSessionNotificationUserJoinedV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameSessionNotificationUserJoinedV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.GameSessionNotificationUserJoinedV1";
  }
  protected:
  explicit GameSessionNotificationUserJoinedV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 2,
    kSessionIDFieldNumber = 1,
  };
  // repeated .session.UserV1 members = 2 [json_name = "members"];
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::session::UserV1* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >*
      mutable_members();
  private:
  const ::session::UserV1& _internal_members(int index) const;
  ::session::UserV1* _internal_add_members();
  public:
  const ::session::UserV1& members(int index) const;
  ::session::UserV1* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >&
      members() const;

  // string SessionID = 1 [json_name = "SessionID"];
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // @@protoc_insertion_point(class_scope:session.GameSessionNotificationUserJoinedV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 > members_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class GameSessionNotificationMembersChangedV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.GameSessionNotificationMembersChangedV1) */ {
 public:
  inline GameSessionNotificationMembersChangedV1() : GameSessionNotificationMembersChangedV1(nullptr) {}
  ~GameSessionNotificationMembersChangedV1() override;
  explicit constexpr GameSessionNotificationMembersChangedV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameSessionNotificationMembersChangedV1(const GameSessionNotificationMembersChangedV1& from);
  GameSessionNotificationMembersChangedV1(GameSessionNotificationMembersChangedV1&& from) noexcept
    : GameSessionNotificationMembersChangedV1() {
    *this = ::std::move(from);
  }

  inline GameSessionNotificationMembersChangedV1& operator=(const GameSessionNotificationMembersChangedV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameSessionNotificationMembersChangedV1& operator=(GameSessionNotificationMembersChangedV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameSessionNotificationMembersChangedV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameSessionNotificationMembersChangedV1* internal_default_instance() {
    return reinterpret_cast<const GameSessionNotificationMembersChangedV1*>(
               &_GameSessionNotificationMembersChangedV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GameSessionNotificationMembersChangedV1& a, GameSessionNotificationMembersChangedV1& b) {
    a.Swap(&b);
  }
  inline void Swap(GameSessionNotificationMembersChangedV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameSessionNotificationMembersChangedV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameSessionNotificationMembersChangedV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameSessionNotificationMembersChangedV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameSessionNotificationMembersChangedV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameSessionNotificationMembersChangedV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameSessionNotificationMembersChangedV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.GameSessionNotificationMembersChangedV1";
  }
  protected:
  explicit GameSessionNotificationMembersChangedV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 1,
    kSessionIDFieldNumber = 2,
    kJoinerIDFieldNumber = 3,
  };
  // repeated .session.UserV1 members = 1 [json_name = "members"];
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::session::UserV1* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >*
      mutable_members();
  private:
  const ::session::UserV1& _internal_members(int index) const;
  ::session::UserV1* _internal_add_members();
  public:
  const ::session::UserV1& members(int index) const;
  ::session::UserV1* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >&
      members() const;

  // string SessionID = 2 [json_name = "sessionID"];
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // string JoinerID = 3 [json_name = "joinerID"];
  void clear_joinerid();
  const std::string& joinerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_joinerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_joinerid();
  PROTOBUF_NODISCARD std::string* release_joinerid();
  void set_allocated_joinerid(std::string* joinerid);
  private:
  const std::string& _internal_joinerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_joinerid(const std::string& value);
  std::string* _internal_mutable_joinerid();
  public:

  // @@protoc_insertion_point(class_scope:session.GameSessionNotificationMembersChangedV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 > members_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr joinerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class DSStatusChangedNotificationV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.DSStatusChangedNotificationV1) */ {
 public:
  inline DSStatusChangedNotificationV1() : DSStatusChangedNotificationV1(nullptr) {}
  ~DSStatusChangedNotificationV1() override;
  explicit constexpr DSStatusChangedNotificationV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DSStatusChangedNotificationV1(const DSStatusChangedNotificationV1& from);
  DSStatusChangedNotificationV1(DSStatusChangedNotificationV1&& from) noexcept
    : DSStatusChangedNotificationV1() {
    *this = ::std::move(from);
  }

  inline DSStatusChangedNotificationV1& operator=(const DSStatusChangedNotificationV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline DSStatusChangedNotificationV1& operator=(DSStatusChangedNotificationV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DSStatusChangedNotificationV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const DSStatusChangedNotificationV1* internal_default_instance() {
    return reinterpret_cast<const DSStatusChangedNotificationV1*>(
               &_DSStatusChangedNotificationV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DSStatusChangedNotificationV1& a, DSStatusChangedNotificationV1& b) {
    a.Swap(&b);
  }
  inline void Swap(DSStatusChangedNotificationV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DSStatusChangedNotificationV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DSStatusChangedNotificationV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DSStatusChangedNotificationV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DSStatusChangedNotificationV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DSStatusChangedNotificationV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DSStatusChangedNotificationV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.DSStatusChangedNotificationV1";
  }
  protected:
  explicit DSStatusChangedNotificationV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIDFieldNumber = 2,
    kErrorFieldNumber = 3,
    kGameServerFieldNumber = 1,
  };
  // string SessionID = 2 [json_name = "sessionID"];
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // string Error = 3 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .session.GameServerV1 GameServer = 1 [json_name = "game_server"];
  bool has_gameserver() const;
  private:
  bool _internal_has_gameserver() const;
  public:
  void clear_gameserver();
  const ::session::GameServerV1& gameserver() const;
  PROTOBUF_NODISCARD ::session::GameServerV1* release_gameserver();
  ::session::GameServerV1* mutable_gameserver();
  void set_allocated_gameserver(::session::GameServerV1* gameserver);
  private:
  const ::session::GameServerV1& _internal_gameserver() const;
  ::session::GameServerV1* _internal_mutable_gameserver();
  public:
  void unsafe_arena_set_allocated_gameserver(
      ::session::GameServerV1* gameserver);
  ::session::GameServerV1* unsafe_arena_release_gameserver();

  // @@protoc_insertion_point(class_scope:session.DSStatusChangedNotificationV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  ::session::GameServerV1* gameserver_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class UserIDs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.UserIDs) */ {
 public:
  inline UserIDs() : UserIDs(nullptr) {}
  ~UserIDs() override;
  explicit constexpr UserIDs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserIDs(const UserIDs& from);
  UserIDs(UserIDs&& from) noexcept
    : UserIDs() {
    *this = ::std::move(from);
  }

  inline UserIDs& operator=(const UserIDs& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserIDs& operator=(UserIDs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserIDs& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserIDs* internal_default_instance() {
    return reinterpret_cast<const UserIDs*>(
               &_UserIDs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UserIDs& a, UserIDs& b) {
    a.Swap(&b);
  }
  inline void Swap(UserIDs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserIDs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserIDs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserIDs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserIDs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserIDs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserIDs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.UserIDs";
  }
  protected:
  explicit UserIDs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // repeated string userID = 1 [json_name = "user_ids"];
  int userid_size() const;
  private:
  int _internal_userid_size() const;
  public:
  void clear_userid();
  const std::string& userid(int index) const;
  std::string* mutable_userid(int index);
  void set_userid(int index, const std::string& value);
  void set_userid(int index, std::string&& value);
  void set_userid(int index, const char* value);
  void set_userid(int index, const char* value, size_t size);
  std::string* add_userid();
  void add_userid(const std::string& value);
  void add_userid(std::string&& value);
  void add_userid(const char* value);
  void add_userid(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& userid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_userid();
  private:
  const std::string& _internal_userid(int index) const;
  std::string* _internal_add_userid();
  public:

  // @@protoc_insertion_point(class_scope:session.UserIDs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class Team final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.Team) */ {
 public:
  inline Team() : Team(nullptr) {}
  ~Team() override;
  explicit constexpr Team(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Team(const Team& from);
  Team(Team&& from) noexcept
    : Team() {
    *this = ::std::move(from);
  }

  inline Team& operator=(const Team& from) {
    CopyFrom(from);
    return *this;
  }
  inline Team& operator=(Team&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Team& default_instance() {
    return *internal_default_instance();
  }
  static inline const Team* internal_default_instance() {
    return reinterpret_cast<const Team*>(
               &_Team_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Team& a, Team& b) {
    a.Swap(&b);
  }
  inline void Swap(Team* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Team* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Team* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Team>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Team& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Team& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Team* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.Team";
  }
  protected:
  explicit Team(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdsFieldNumber = 1,
  };
  // repeated string user_ids = 1 [json_name = "user_ids"];
  int user_ids_size() const;
  private:
  int _internal_user_ids_size() const;
  public:
  void clear_user_ids();
  const std::string& user_ids(int index) const;
  std::string* mutable_user_ids(int index);
  void set_user_ids(int index, const std::string& value);
  void set_user_ids(int index, std::string&& value);
  void set_user_ids(int index, const char* value);
  void set_user_ids(int index, const char* value, size_t size);
  std::string* add_user_ids();
  void add_user_ids(const std::string& value);
  void add_user_ids(std::string&& value);
  void add_user_ids(const char* value);
  void add_user_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_ids();
  private:
  const std::string& _internal_user_ids(int index) const;
  std::string* _internal_add_user_ids();
  public:

  // @@protoc_insertion_point(class_scope:session.Team)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class GameSessionV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.GameSessionV1) */ {
 public:
  inline GameSessionV1() : GameSessionV1(nullptr) {}
  ~GameSessionV1() override;
  explicit constexpr GameSessionV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameSessionV1(const GameSessionV1& from);
  GameSessionV1(GameSessionV1&& from) noexcept
    : GameSessionV1() {
    *this = ::std::move(from);
  }

  inline GameSessionV1& operator=(const GameSessionV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameSessionV1& operator=(GameSessionV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameSessionV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameSessionV1* internal_default_instance() {
    return reinterpret_cast<const GameSessionV1*>(
               &_GameSessionV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GameSessionV1& a, GameSessionV1& b) {
    a.Swap(&b);
  }
  inline void Swap(GameSessionV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameSessionV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameSessionV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameSessionV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameSessionV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameSessionV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameSessionV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.GameSessionV1";
  }
  protected:
  explicit GameSessionV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 3,
    kTeamsFieldNumber = 13,
    kIdFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kAttributesFieldNumber = 4,
    kJoinTypeFieldNumber = 5,
    kCreatedAtFieldNumber = 6,
    kUpdatedAtFieldNumber = 7,
    kMatchPoolFieldNumber = 10,
    kGameModeFieldNumber = 11,
    kBackfillTicketIdFieldNumber = 12,
    kConfigFieldNumber = 8,
    kDSInformationV1FieldNumber = 14,
    kVersionFieldNumber = 9,
  };
  // repeated .session.UserV1 members = 3 [json_name = "members"];
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::session::UserV1* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >*
      mutable_members();
  private:
  const ::session::UserV1& _internal_members(int index) const;
  ::session::UserV1* _internal_add_members();
  public:
  const ::session::UserV1& members(int index) const;
  ::session::UserV1* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >&
      members() const;

  // repeated .session.Team teams = 13 [json_name = "teams"];
  int teams_size() const;
  private:
  int _internal_teams_size() const;
  public:
  void clear_teams();
  ::session::Team* mutable_teams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::Team >*
      mutable_teams();
  private:
  const ::session::Team& _internal_teams(int index) const;
  ::session::Team* _internal_add_teams();
  public:
  const ::session::Team& teams(int index) const;
  ::session::Team* add_teams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::Team >&
      teams() const;

  // string id = 1 [json_name = "_id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string namespace = 2 [json_name = "namespace"];
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // bytes attributes = 4 [json_name = "attributes"];
  void clear_attributes();
  const std::string& attributes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attributes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attributes();
  PROTOBUF_NODISCARD std::string* release_attributes();
  void set_allocated_attributes(std::string* attributes);
  private:
  const std::string& _internal_attributes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attributes(const std::string& value);
  std::string* _internal_mutable_attributes();
  public:

  // string join_type = 5 [json_name = "joinType"];
  void clear_join_type();
  const std::string& join_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_join_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_join_type();
  PROTOBUF_NODISCARD std::string* release_join_type();
  void set_allocated_join_type(std::string* join_type);
  private:
  const std::string& _internal_join_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_join_type(const std::string& value);
  std::string* _internal_mutable_join_type();
  public:

  // string created_at = 6 [json_name = "createdAt"];
  void clear_created_at();
  const std::string& created_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* created_at);
  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(const std::string& value);
  std::string* _internal_mutable_created_at();
  public:

  // string updated_at = 7 [json_name = "updatedAt"];
  void clear_updated_at();
  const std::string& updated_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updated_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updated_at();
  PROTOBUF_NODISCARD std::string* release_updated_at();
  void set_allocated_updated_at(std::string* updated_at);
  private:
  const std::string& _internal_updated_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_at(const std::string& value);
  std::string* _internal_mutable_updated_at();
  public:

  // string match_pool = 10 [json_name = "match_pool"];
  void clear_match_pool();
  const std::string& match_pool() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_match_pool(ArgT0&& arg0, ArgT... args);
  std::string* mutable_match_pool();
  PROTOBUF_NODISCARD std::string* release_match_pool();
  void set_allocated_match_pool(std::string* match_pool);
  private:
  const std::string& _internal_match_pool() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_match_pool(const std::string& value);
  std::string* _internal_mutable_match_pool();
  public:

  // string game_mode = 11 [json_name = "game_mode"];
  void clear_game_mode();
  const std::string& game_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_mode();
  PROTOBUF_NODISCARD std::string* release_game_mode();
  void set_allocated_game_mode(std::string* game_mode);
  private:
  const std::string& _internal_game_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_mode(const std::string& value);
  std::string* _internal_mutable_game_mode();
  public:

  // string backfill_ticket_id = 12 [json_name = "backfill_ticket_id"];
  void clear_backfill_ticket_id();
  const std::string& backfill_ticket_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backfill_ticket_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backfill_ticket_id();
  PROTOBUF_NODISCARD std::string* release_backfill_ticket_id();
  void set_allocated_backfill_ticket_id(std::string* backfill_ticket_id);
  private:
  const std::string& _internal_backfill_ticket_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backfill_ticket_id(const std::string& value);
  std::string* _internal_mutable_backfill_ticket_id();
  public:

  // .session.SessionConfigV1 config = 8 [json_name = "config"];
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::session::SessionConfigV1& config() const;
  PROTOBUF_NODISCARD ::session::SessionConfigV1* release_config();
  ::session::SessionConfigV1* mutable_config();
  void set_allocated_config(::session::SessionConfigV1* config);
  private:
  const ::session::SessionConfigV1& _internal_config() const;
  ::session::SessionConfigV1* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::session::SessionConfigV1* config);
  ::session::SessionConfigV1* unsafe_arena_release_config();

  // .session.DSInformationV1 DSInformationV1 = 14 [json_name = "ds_information"];
  bool has_dsinformationv1() const;
  private:
  bool _internal_has_dsinformationv1() const;
  public:
  void clear_dsinformationv1();
  const ::session::DSInformationV1& dsinformationv1() const;
  PROTOBUF_NODISCARD ::session::DSInformationV1* release_dsinformationv1();
  ::session::DSInformationV1* mutable_dsinformationv1();
  void set_allocated_dsinformationv1(::session::DSInformationV1* dsinformationv1);
  private:
  const ::session::DSInformationV1& _internal_dsinformationv1() const;
  ::session::DSInformationV1* _internal_mutable_dsinformationv1();
  public:
  void unsafe_arena_set_allocated_dsinformationv1(
      ::session::DSInformationV1* dsinformationv1);
  ::session::DSInformationV1* unsafe_arena_release_dsinformationv1();

  // int32 version = 9 [json_name = "_version"];
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:session.GameSessionV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 > members_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::Team > teams_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr join_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_at_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updated_at_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr match_pool_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_mode_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backfill_ticket_id_;
  ::session::SessionConfigV1* config_;
  ::session::DSInformationV1* dsinformationv1_;
  int32_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class DSInformationV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.DSInformationV1) */ {
 public:
  inline DSInformationV1() : DSInformationV1(nullptr) {}
  ~DSInformationV1() override;
  explicit constexpr DSInformationV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DSInformationV1(const DSInformationV1& from);
  DSInformationV1(DSInformationV1&& from) noexcept
    : DSInformationV1() {
    *this = ::std::move(from);
  }

  inline DSInformationV1& operator=(const DSInformationV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline DSInformationV1& operator=(DSInformationV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DSInformationV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const DSInformationV1* internal_default_instance() {
    return reinterpret_cast<const DSInformationV1*>(
               &_DSInformationV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DSInformationV1& a, DSInformationV1& b) {
    a.Swap(&b);
  }
  inline void Swap(DSInformationV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DSInformationV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DSInformationV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DSInformationV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DSInformationV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DSInformationV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DSInformationV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.DSInformationV1";
  }
  protected:
  explicit DSInformationV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestedRegionsFieldNumber = 2,
    kRequestedAtFieldNumber = 3,
    kStatusFieldNumber = 5,
    kClientVersionFieldNumber = 6,
    kDeploymentFieldNumber = 7,
    kGameServerFieldNumber = 1,
    kMinPlayersFieldNumber = 4,
  };
  // repeated string requested_regions = 2 [json_name = "requested_regions"];
  int requested_regions_size() const;
  private:
  int _internal_requested_regions_size() const;
  public:
  void clear_requested_regions();
  const std::string& requested_regions(int index) const;
  std::string* mutable_requested_regions(int index);
  void set_requested_regions(int index, const std::string& value);
  void set_requested_regions(int index, std::string&& value);
  void set_requested_regions(int index, const char* value);
  void set_requested_regions(int index, const char* value, size_t size);
  std::string* add_requested_regions();
  void add_requested_regions(const std::string& value);
  void add_requested_regions(std::string&& value);
  void add_requested_regions(const char* value);
  void add_requested_regions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& requested_regions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_requested_regions();
  private:
  const std::string& _internal_requested_regions(int index) const;
  std::string* _internal_add_requested_regions();
  public:

  // string requested_at = 3 [json_name = "requested_at"];
  void clear_requested_at();
  const std::string& requested_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requested_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requested_at();
  PROTOBUF_NODISCARD std::string* release_requested_at();
  void set_allocated_requested_at(std::string* requested_at);
  private:
  const std::string& _internal_requested_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requested_at(const std::string& value);
  std::string* _internal_mutable_requested_at();
  public:

  // string status = 5 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string client_version = 6 [json_name = "client_version"];
  void clear_client_version();
  const std::string& client_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_version();
  PROTOBUF_NODISCARD std::string* release_client_version();
  void set_allocated_client_version(std::string* client_version);
  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(const std::string& value);
  std::string* _internal_mutable_client_version();
  public:

  // string deployment = 7 [json_name = "deployment"];
  void clear_deployment();
  const std::string& deployment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deployment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deployment();
  PROTOBUF_NODISCARD std::string* release_deployment();
  void set_allocated_deployment(std::string* deployment);
  private:
  const std::string& _internal_deployment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deployment(const std::string& value);
  std::string* _internal_mutable_deployment();
  public:

  // .session.GameServerV1 GameServer = 1 [json_name = "game_server"];
  bool has_gameserver() const;
  private:
  bool _internal_has_gameserver() const;
  public:
  void clear_gameserver();
  const ::session::GameServerV1& gameserver() const;
  PROTOBUF_NODISCARD ::session::GameServerV1* release_gameserver();
  ::session::GameServerV1* mutable_gameserver();
  void set_allocated_gameserver(::session::GameServerV1* gameserver);
  private:
  const ::session::GameServerV1& _internal_gameserver() const;
  ::session::GameServerV1* _internal_mutable_gameserver();
  public:
  void unsafe_arena_set_allocated_gameserver(
      ::session::GameServerV1* gameserver);
  ::session::GameServerV1* unsafe_arena_release_gameserver();

  // int32 min_players = 4 [json_name = "min_players"];
  void clear_min_players();
  int32_t min_players() const;
  void set_min_players(int32_t value);
  private:
  int32_t _internal_min_players() const;
  void _internal_set_min_players(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:session.DSInformationV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> requested_regions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requested_at_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deployment_;
  ::session::GameServerV1* gameserver_;
  int32_t min_players_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// -------------------------------------------------------------------

class GameServerV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:session.GameServerV1) */ {
 public:
  inline GameServerV1() : GameServerV1(nullptr) {}
  ~GameServerV1() override;
  explicit constexpr GameServerV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameServerV1(const GameServerV1& from);
  GameServerV1(GameServerV1&& from) noexcept
    : GameServerV1() {
    *this = ::std::move(from);
  }

  inline GameServerV1& operator=(const GameServerV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameServerV1& operator=(GameServerV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameServerV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameServerV1* internal_default_instance() {
    return reinterpret_cast<const GameServerV1*>(
               &_GameServerV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GameServerV1& a, GameServerV1& b) {
    a.Swap(&b);
  }
  inline void Swap(GameServerV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameServerV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameServerV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameServerV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameServerV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameServerV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameServerV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "session.GameServerV1";
  }
  protected:
  explicit GameServerV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlternateIpsFieldNumber = 5,
    kPodNameFieldNumber = 1,
    kImageVersionFieldNumber = 2,
    kNamespaceFieldNumber = 3,
    kIpFieldNumber = 4,
    kProtocolFieldNumber = 7,
    kPortsFieldNumber = 8,
    kProviderFieldNumber = 9,
    kGameVersionFieldNumber = 10,
    kStatusFieldNumber = 11,
    kSessionIdFieldNumber = 12,
    kDeploymentFieldNumber = 13,
    kRegionFieldNumber = 14,
    kCustomAttributeFieldNumber = 15,
    kLastUpdateFieldNumber = 17,
    kPortFieldNumber = 6,
    kIsOverrideGameVersionFieldNumber = 16,
  };
  // repeated string alternate_ips = 5 [json_name = "alternate_ips"];
  int alternate_ips_size() const;
  private:
  int _internal_alternate_ips_size() const;
  public:
  void clear_alternate_ips();
  const std::string& alternate_ips(int index) const;
  std::string* mutable_alternate_ips(int index);
  void set_alternate_ips(int index, const std::string& value);
  void set_alternate_ips(int index, std::string&& value);
  void set_alternate_ips(int index, const char* value);
  void set_alternate_ips(int index, const char* value, size_t size);
  std::string* add_alternate_ips();
  void add_alternate_ips(const std::string& value);
  void add_alternate_ips(std::string&& value);
  void add_alternate_ips(const char* value);
  void add_alternate_ips(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& alternate_ips() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_alternate_ips();
  private:
  const std::string& _internal_alternate_ips(int index) const;
  std::string* _internal_add_alternate_ips();
  public:

  // string pod_name = 1 [json_name = "pod_name"];
  void clear_pod_name();
  const std::string& pod_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pod_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pod_name();
  PROTOBUF_NODISCARD std::string* release_pod_name();
  void set_allocated_pod_name(std::string* pod_name);
  private:
  const std::string& _internal_pod_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pod_name(const std::string& value);
  std::string* _internal_mutable_pod_name();
  public:

  // string image_version = 2 [json_name = "image_version"];
  void clear_image_version();
  const std::string& image_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_version();
  PROTOBUF_NODISCARD std::string* release_image_version();
  void set_allocated_image_version(std::string* image_version);
  private:
  const std::string& _internal_image_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_version(const std::string& value);
  std::string* _internal_mutable_image_version();
  public:

  // string namespace = 3 [json_name = "namespace"];
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // string ip = 4 [json_name = "ip"];
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string protocol = 7 [json_name = "protocol"];
  void clear_protocol();
  const std::string& protocol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol();
  PROTOBUF_NODISCARD std::string* release_protocol();
  void set_allocated_protocol(std::string* protocol);
  private:
  const std::string& _internal_protocol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol(const std::string& value);
  std::string* _internal_mutable_protocol();
  public:

  // bytes ports = 8 [json_name = "ports"];
  void clear_ports();
  const std::string& ports() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ports(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ports();
  PROTOBUF_NODISCARD std::string* release_ports();
  void set_allocated_ports(std::string* ports);
  private:
  const std::string& _internal_ports() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ports(const std::string& value);
  std::string* _internal_mutable_ports();
  public:

  // string provider = 9 [json_name = "provider"];
  void clear_provider();
  const std::string& provider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provider();
  PROTOBUF_NODISCARD std::string* release_provider();
  void set_allocated_provider(std::string* provider);
  private:
  const std::string& _internal_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider(const std::string& value);
  std::string* _internal_mutable_provider();
  public:

  // string game_version = 10 [json_name = "game_version"];
  void clear_game_version();
  const std::string& game_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_version();
  PROTOBUF_NODISCARD std::string* release_game_version();
  void set_allocated_game_version(std::string* game_version);
  private:
  const std::string& _internal_game_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_version(const std::string& value);
  std::string* _internal_mutable_game_version();
  public:

  // string status = 11 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string session_id = 12 [json_name = "session_id"];
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string deployment = 13 [json_name = "deployment"];
  void clear_deployment();
  const std::string& deployment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deployment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deployment();
  PROTOBUF_NODISCARD std::string* release_deployment();
  void set_allocated_deployment(std::string* deployment);
  private:
  const std::string& _internal_deployment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deployment(const std::string& value);
  std::string* _internal_mutable_deployment();
  public:

  // string region = 14 [json_name = "region"];
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // string custom_attribute = 15 [json_name = "custom_attribute"];
  void clear_custom_attribute();
  const std::string& custom_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_custom_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_custom_attribute();
  PROTOBUF_NODISCARD std::string* release_custom_attribute();
  void set_allocated_custom_attribute(std::string* custom_attribute);
  private:
  const std::string& _internal_custom_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_custom_attribute(const std::string& value);
  std::string* _internal_mutable_custom_attribute();
  public:

  // string last_update = 17 [json_name = "last_update"];
  void clear_last_update();
  const std::string& last_update() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_update(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_update();
  PROTOBUF_NODISCARD std::string* release_last_update();
  void set_allocated_last_update(std::string* last_update);
  private:
  const std::string& _internal_last_update() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_update(const std::string& value);
  std::string* _internal_mutable_last_update();
  public:

  // int32 port = 6 [json_name = "port"];
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // bool is_override_game_version = 16 [json_name = "is_override_game_version"];
  void clear_is_override_game_version();
  bool is_override_game_version() const;
  void set_is_override_game_version(bool value);
  private:
  bool _internal_is_override_game_version() const;
  void _internal_set_is_override_game_version(bool value);
  public:

  // @@protoc_insertion_point(class_scope:session.GameServerV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> alternate_ips_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pod_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ports_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deployment_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_update_;
  int32_t port_;
  bool is_override_game_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_notification_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NotificationEventEnvelope

// .session.PartyNotificationUserInvitedV1 PartyNotificationUserInvitedV1 = 1 [json_name = "OnPartyInvited"];
inline bool NotificationEventEnvelope::_internal_has_partynotificationuserinvitedv1() const {
  return payload_case() == kPartyNotificationUserInvitedV1;
}
inline bool NotificationEventEnvelope::has_partynotificationuserinvitedv1() const {
  return _internal_has_partynotificationuserinvitedv1();
}
inline void NotificationEventEnvelope::set_has_partynotificationuserinvitedv1() {
  _oneof_case_[0] = kPartyNotificationUserInvitedV1;
}
inline void NotificationEventEnvelope::clear_partynotificationuserinvitedv1() {
  if (_internal_has_partynotificationuserinvitedv1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.partynotificationuserinvitedv1_;
    }
    clear_has_payload();
  }
}
inline ::session::PartyNotificationUserInvitedV1* NotificationEventEnvelope::release_partynotificationuserinvitedv1() {
  // @@protoc_insertion_point(field_release:session.NotificationEventEnvelope.PartyNotificationUserInvitedV1)
  if (_internal_has_partynotificationuserinvitedv1()) {
    clear_has_payload();
      ::session::PartyNotificationUserInvitedV1* temp = payload_.partynotificationuserinvitedv1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.partynotificationuserinvitedv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::session::PartyNotificationUserInvitedV1& NotificationEventEnvelope::_internal_partynotificationuserinvitedv1() const {
  return _internal_has_partynotificationuserinvitedv1()
      ? *payload_.partynotificationuserinvitedv1_
      : reinterpret_cast< ::session::PartyNotificationUserInvitedV1&>(::session::_PartyNotificationUserInvitedV1_default_instance_);
}
inline const ::session::PartyNotificationUserInvitedV1& NotificationEventEnvelope::partynotificationuserinvitedv1() const {
  // @@protoc_insertion_point(field_get:session.NotificationEventEnvelope.PartyNotificationUserInvitedV1)
  return _internal_partynotificationuserinvitedv1();
}
inline ::session::PartyNotificationUserInvitedV1* NotificationEventEnvelope::unsafe_arena_release_partynotificationuserinvitedv1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:session.NotificationEventEnvelope.PartyNotificationUserInvitedV1)
  if (_internal_has_partynotificationuserinvitedv1()) {
    clear_has_payload();
    ::session::PartyNotificationUserInvitedV1* temp = payload_.partynotificationuserinvitedv1_;
    payload_.partynotificationuserinvitedv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotificationEventEnvelope::unsafe_arena_set_allocated_partynotificationuserinvitedv1(::session::PartyNotificationUserInvitedV1* partynotificationuserinvitedv1) {
  clear_payload();
  if (partynotificationuserinvitedv1) {
    set_has_partynotificationuserinvitedv1();
    payload_.partynotificationuserinvitedv1_ = partynotificationuserinvitedv1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.NotificationEventEnvelope.PartyNotificationUserInvitedV1)
}
inline ::session::PartyNotificationUserInvitedV1* NotificationEventEnvelope::_internal_mutable_partynotificationuserinvitedv1() {
  if (!_internal_has_partynotificationuserinvitedv1()) {
    clear_payload();
    set_has_partynotificationuserinvitedv1();
    payload_.partynotificationuserinvitedv1_ = CreateMaybeMessage< ::session::PartyNotificationUserInvitedV1 >(GetArenaForAllocation());
  }
  return payload_.partynotificationuserinvitedv1_;
}
inline ::session::PartyNotificationUserInvitedV1* NotificationEventEnvelope::mutable_partynotificationuserinvitedv1() {
  ::session::PartyNotificationUserInvitedV1* _msg = _internal_mutable_partynotificationuserinvitedv1();
  // @@protoc_insertion_point(field_mutable:session.NotificationEventEnvelope.PartyNotificationUserInvitedV1)
  return _msg;
}

// .session.PartyNotificationUserJoinedV1 PartyNotificationUserJoinedV1 = 2 [json_name = "OnPartyJoined"];
inline bool NotificationEventEnvelope::_internal_has_partynotificationuserjoinedv1() const {
  return payload_case() == kPartyNotificationUserJoinedV1;
}
inline bool NotificationEventEnvelope::has_partynotificationuserjoinedv1() const {
  return _internal_has_partynotificationuserjoinedv1();
}
inline void NotificationEventEnvelope::set_has_partynotificationuserjoinedv1() {
  _oneof_case_[0] = kPartyNotificationUserJoinedV1;
}
inline void NotificationEventEnvelope::clear_partynotificationuserjoinedv1() {
  if (_internal_has_partynotificationuserjoinedv1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.partynotificationuserjoinedv1_;
    }
    clear_has_payload();
  }
}
inline ::session::PartyNotificationUserJoinedV1* NotificationEventEnvelope::release_partynotificationuserjoinedv1() {
  // @@protoc_insertion_point(field_release:session.NotificationEventEnvelope.PartyNotificationUserJoinedV1)
  if (_internal_has_partynotificationuserjoinedv1()) {
    clear_has_payload();
      ::session::PartyNotificationUserJoinedV1* temp = payload_.partynotificationuserjoinedv1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.partynotificationuserjoinedv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::session::PartyNotificationUserJoinedV1& NotificationEventEnvelope::_internal_partynotificationuserjoinedv1() const {
  return _internal_has_partynotificationuserjoinedv1()
      ? *payload_.partynotificationuserjoinedv1_
      : reinterpret_cast< ::session::PartyNotificationUserJoinedV1&>(::session::_PartyNotificationUserJoinedV1_default_instance_);
}
inline const ::session::PartyNotificationUserJoinedV1& NotificationEventEnvelope::partynotificationuserjoinedv1() const {
  // @@protoc_insertion_point(field_get:session.NotificationEventEnvelope.PartyNotificationUserJoinedV1)
  return _internal_partynotificationuserjoinedv1();
}
inline ::session::PartyNotificationUserJoinedV1* NotificationEventEnvelope::unsafe_arena_release_partynotificationuserjoinedv1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:session.NotificationEventEnvelope.PartyNotificationUserJoinedV1)
  if (_internal_has_partynotificationuserjoinedv1()) {
    clear_has_payload();
    ::session::PartyNotificationUserJoinedV1* temp = payload_.partynotificationuserjoinedv1_;
    payload_.partynotificationuserjoinedv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotificationEventEnvelope::unsafe_arena_set_allocated_partynotificationuserjoinedv1(::session::PartyNotificationUserJoinedV1* partynotificationuserjoinedv1) {
  clear_payload();
  if (partynotificationuserjoinedv1) {
    set_has_partynotificationuserjoinedv1();
    payload_.partynotificationuserjoinedv1_ = partynotificationuserjoinedv1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.NotificationEventEnvelope.PartyNotificationUserJoinedV1)
}
inline ::session::PartyNotificationUserJoinedV1* NotificationEventEnvelope::_internal_mutable_partynotificationuserjoinedv1() {
  if (!_internal_has_partynotificationuserjoinedv1()) {
    clear_payload();
    set_has_partynotificationuserjoinedv1();
    payload_.partynotificationuserjoinedv1_ = CreateMaybeMessage< ::session::PartyNotificationUserJoinedV1 >(GetArenaForAllocation());
  }
  return payload_.partynotificationuserjoinedv1_;
}
inline ::session::PartyNotificationUserJoinedV1* NotificationEventEnvelope::mutable_partynotificationuserjoinedv1() {
  ::session::PartyNotificationUserJoinedV1* _msg = _internal_mutable_partynotificationuserjoinedv1();
  // @@protoc_insertion_point(field_mutable:session.NotificationEventEnvelope.PartyNotificationUserJoinedV1)
  return _msg;
}

// .session.PartyNotificationMembersChangedV1 PartyNotificationMembersChangedV1 = 3 [json_name = "OnPartyMembersChanged"];
inline bool NotificationEventEnvelope::_internal_has_partynotificationmemberschangedv1() const {
  return payload_case() == kPartyNotificationMembersChangedV1;
}
inline bool NotificationEventEnvelope::has_partynotificationmemberschangedv1() const {
  return _internal_has_partynotificationmemberschangedv1();
}
inline void NotificationEventEnvelope::set_has_partynotificationmemberschangedv1() {
  _oneof_case_[0] = kPartyNotificationMembersChangedV1;
}
inline void NotificationEventEnvelope::clear_partynotificationmemberschangedv1() {
  if (_internal_has_partynotificationmemberschangedv1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.partynotificationmemberschangedv1_;
    }
    clear_has_payload();
  }
}
inline ::session::PartyNotificationMembersChangedV1* NotificationEventEnvelope::release_partynotificationmemberschangedv1() {
  // @@protoc_insertion_point(field_release:session.NotificationEventEnvelope.PartyNotificationMembersChangedV1)
  if (_internal_has_partynotificationmemberschangedv1()) {
    clear_has_payload();
      ::session::PartyNotificationMembersChangedV1* temp = payload_.partynotificationmemberschangedv1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.partynotificationmemberschangedv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::session::PartyNotificationMembersChangedV1& NotificationEventEnvelope::_internal_partynotificationmemberschangedv1() const {
  return _internal_has_partynotificationmemberschangedv1()
      ? *payload_.partynotificationmemberschangedv1_
      : reinterpret_cast< ::session::PartyNotificationMembersChangedV1&>(::session::_PartyNotificationMembersChangedV1_default_instance_);
}
inline const ::session::PartyNotificationMembersChangedV1& NotificationEventEnvelope::partynotificationmemberschangedv1() const {
  // @@protoc_insertion_point(field_get:session.NotificationEventEnvelope.PartyNotificationMembersChangedV1)
  return _internal_partynotificationmemberschangedv1();
}
inline ::session::PartyNotificationMembersChangedV1* NotificationEventEnvelope::unsafe_arena_release_partynotificationmemberschangedv1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:session.NotificationEventEnvelope.PartyNotificationMembersChangedV1)
  if (_internal_has_partynotificationmemberschangedv1()) {
    clear_has_payload();
    ::session::PartyNotificationMembersChangedV1* temp = payload_.partynotificationmemberschangedv1_;
    payload_.partynotificationmemberschangedv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotificationEventEnvelope::unsafe_arena_set_allocated_partynotificationmemberschangedv1(::session::PartyNotificationMembersChangedV1* partynotificationmemberschangedv1) {
  clear_payload();
  if (partynotificationmemberschangedv1) {
    set_has_partynotificationmemberschangedv1();
    payload_.partynotificationmemberschangedv1_ = partynotificationmemberschangedv1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.NotificationEventEnvelope.PartyNotificationMembersChangedV1)
}
inline ::session::PartyNotificationMembersChangedV1* NotificationEventEnvelope::_internal_mutable_partynotificationmemberschangedv1() {
  if (!_internal_has_partynotificationmemberschangedv1()) {
    clear_payload();
    set_has_partynotificationmemberschangedv1();
    payload_.partynotificationmemberschangedv1_ = CreateMaybeMessage< ::session::PartyNotificationMembersChangedV1 >(GetArenaForAllocation());
  }
  return payload_.partynotificationmemberschangedv1_;
}
inline ::session::PartyNotificationMembersChangedV1* NotificationEventEnvelope::mutable_partynotificationmemberschangedv1() {
  ::session::PartyNotificationMembersChangedV1* _msg = _internal_mutable_partynotificationmemberschangedv1();
  // @@protoc_insertion_point(field_mutable:session.NotificationEventEnvelope.PartyNotificationMembersChangedV1)
  return _msg;
}

// .session.PartyNotificationUserRejectV1 PartyNotificationUserRejectV1 = 4 [json_name = "OnPartyRejected"];
inline bool NotificationEventEnvelope::_internal_has_partynotificationuserrejectv1() const {
  return payload_case() == kPartyNotificationUserRejectV1;
}
inline bool NotificationEventEnvelope::has_partynotificationuserrejectv1() const {
  return _internal_has_partynotificationuserrejectv1();
}
inline void NotificationEventEnvelope::set_has_partynotificationuserrejectv1() {
  _oneof_case_[0] = kPartyNotificationUserRejectV1;
}
inline void NotificationEventEnvelope::clear_partynotificationuserrejectv1() {
  if (_internal_has_partynotificationuserrejectv1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.partynotificationuserrejectv1_;
    }
    clear_has_payload();
  }
}
inline ::session::PartyNotificationUserRejectV1* NotificationEventEnvelope::release_partynotificationuserrejectv1() {
  // @@protoc_insertion_point(field_release:session.NotificationEventEnvelope.PartyNotificationUserRejectV1)
  if (_internal_has_partynotificationuserrejectv1()) {
    clear_has_payload();
      ::session::PartyNotificationUserRejectV1* temp = payload_.partynotificationuserrejectv1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.partynotificationuserrejectv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::session::PartyNotificationUserRejectV1& NotificationEventEnvelope::_internal_partynotificationuserrejectv1() const {
  return _internal_has_partynotificationuserrejectv1()
      ? *payload_.partynotificationuserrejectv1_
      : reinterpret_cast< ::session::PartyNotificationUserRejectV1&>(::session::_PartyNotificationUserRejectV1_default_instance_);
}
inline const ::session::PartyNotificationUserRejectV1& NotificationEventEnvelope::partynotificationuserrejectv1() const {
  // @@protoc_insertion_point(field_get:session.NotificationEventEnvelope.PartyNotificationUserRejectV1)
  return _internal_partynotificationuserrejectv1();
}
inline ::session::PartyNotificationUserRejectV1* NotificationEventEnvelope::unsafe_arena_release_partynotificationuserrejectv1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:session.NotificationEventEnvelope.PartyNotificationUserRejectV1)
  if (_internal_has_partynotificationuserrejectv1()) {
    clear_has_payload();
    ::session::PartyNotificationUserRejectV1* temp = payload_.partynotificationuserrejectv1_;
    payload_.partynotificationuserrejectv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotificationEventEnvelope::unsafe_arena_set_allocated_partynotificationuserrejectv1(::session::PartyNotificationUserRejectV1* partynotificationuserrejectv1) {
  clear_payload();
  if (partynotificationuserrejectv1) {
    set_has_partynotificationuserrejectv1();
    payload_.partynotificationuserrejectv1_ = partynotificationuserrejectv1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.NotificationEventEnvelope.PartyNotificationUserRejectV1)
}
inline ::session::PartyNotificationUserRejectV1* NotificationEventEnvelope::_internal_mutable_partynotificationuserrejectv1() {
  if (!_internal_has_partynotificationuserrejectv1()) {
    clear_payload();
    set_has_partynotificationuserrejectv1();
    payload_.partynotificationuserrejectv1_ = CreateMaybeMessage< ::session::PartyNotificationUserRejectV1 >(GetArenaForAllocation());
  }
  return payload_.partynotificationuserrejectv1_;
}
inline ::session::PartyNotificationUserRejectV1* NotificationEventEnvelope::mutable_partynotificationuserrejectv1() {
  ::session::PartyNotificationUserRejectV1* _msg = _internal_mutable_partynotificationuserrejectv1();
  // @@protoc_insertion_point(field_mutable:session.NotificationEventEnvelope.PartyNotificationUserRejectV1)
  return _msg;
}

// .session.PartyNotificationUserKickedV1 PartyNotificationUserKickedV1 = 5 [json_name = "OnPartyKicked"];
inline bool NotificationEventEnvelope::_internal_has_partynotificationuserkickedv1() const {
  return payload_case() == kPartyNotificationUserKickedV1;
}
inline bool NotificationEventEnvelope::has_partynotificationuserkickedv1() const {
  return _internal_has_partynotificationuserkickedv1();
}
inline void NotificationEventEnvelope::set_has_partynotificationuserkickedv1() {
  _oneof_case_[0] = kPartyNotificationUserKickedV1;
}
inline void NotificationEventEnvelope::clear_partynotificationuserkickedv1() {
  if (_internal_has_partynotificationuserkickedv1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.partynotificationuserkickedv1_;
    }
    clear_has_payload();
  }
}
inline ::session::PartyNotificationUserKickedV1* NotificationEventEnvelope::release_partynotificationuserkickedv1() {
  // @@protoc_insertion_point(field_release:session.NotificationEventEnvelope.PartyNotificationUserKickedV1)
  if (_internal_has_partynotificationuserkickedv1()) {
    clear_has_payload();
      ::session::PartyNotificationUserKickedV1* temp = payload_.partynotificationuserkickedv1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.partynotificationuserkickedv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::session::PartyNotificationUserKickedV1& NotificationEventEnvelope::_internal_partynotificationuserkickedv1() const {
  return _internal_has_partynotificationuserkickedv1()
      ? *payload_.partynotificationuserkickedv1_
      : reinterpret_cast< ::session::PartyNotificationUserKickedV1&>(::session::_PartyNotificationUserKickedV1_default_instance_);
}
inline const ::session::PartyNotificationUserKickedV1& NotificationEventEnvelope::partynotificationuserkickedv1() const {
  // @@protoc_insertion_point(field_get:session.NotificationEventEnvelope.PartyNotificationUserKickedV1)
  return _internal_partynotificationuserkickedv1();
}
inline ::session::PartyNotificationUserKickedV1* NotificationEventEnvelope::unsafe_arena_release_partynotificationuserkickedv1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:session.NotificationEventEnvelope.PartyNotificationUserKickedV1)
  if (_internal_has_partynotificationuserkickedv1()) {
    clear_has_payload();
    ::session::PartyNotificationUserKickedV1* temp = payload_.partynotificationuserkickedv1_;
    payload_.partynotificationuserkickedv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotificationEventEnvelope::unsafe_arena_set_allocated_partynotificationuserkickedv1(::session::PartyNotificationUserKickedV1* partynotificationuserkickedv1) {
  clear_payload();
  if (partynotificationuserkickedv1) {
    set_has_partynotificationuserkickedv1();
    payload_.partynotificationuserkickedv1_ = partynotificationuserkickedv1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.NotificationEventEnvelope.PartyNotificationUserKickedV1)
}
inline ::session::PartyNotificationUserKickedV1* NotificationEventEnvelope::_internal_mutable_partynotificationuserkickedv1() {
  if (!_internal_has_partynotificationuserkickedv1()) {
    clear_payload();
    set_has_partynotificationuserkickedv1();
    payload_.partynotificationuserkickedv1_ = CreateMaybeMessage< ::session::PartyNotificationUserKickedV1 >(GetArenaForAllocation());
  }
  return payload_.partynotificationuserkickedv1_;
}
inline ::session::PartyNotificationUserKickedV1* NotificationEventEnvelope::mutable_partynotificationuserkickedv1() {
  ::session::PartyNotificationUserKickedV1* _msg = _internal_mutable_partynotificationuserkickedv1();
  // @@protoc_insertion_point(field_mutable:session.NotificationEventEnvelope.PartyNotificationUserKickedV1)
  return _msg;
}

// .session.PartySessionV1 PartySessionV1 = 6 [json_name = "OnPartyUpdated"];
inline bool NotificationEventEnvelope::_internal_has_partysessionv1() const {
  return payload_case() == kPartySessionV1;
}
inline bool NotificationEventEnvelope::has_partysessionv1() const {
  return _internal_has_partysessionv1();
}
inline void NotificationEventEnvelope::set_has_partysessionv1() {
  _oneof_case_[0] = kPartySessionV1;
}
inline void NotificationEventEnvelope::clear_partysessionv1() {
  if (_internal_has_partysessionv1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.partysessionv1_;
    }
    clear_has_payload();
  }
}
inline ::session::PartySessionV1* NotificationEventEnvelope::release_partysessionv1() {
  // @@protoc_insertion_point(field_release:session.NotificationEventEnvelope.PartySessionV1)
  if (_internal_has_partysessionv1()) {
    clear_has_payload();
      ::session::PartySessionV1* temp = payload_.partysessionv1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.partysessionv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::session::PartySessionV1& NotificationEventEnvelope::_internal_partysessionv1() const {
  return _internal_has_partysessionv1()
      ? *payload_.partysessionv1_
      : reinterpret_cast< ::session::PartySessionV1&>(::session::_PartySessionV1_default_instance_);
}
inline const ::session::PartySessionV1& NotificationEventEnvelope::partysessionv1() const {
  // @@protoc_insertion_point(field_get:session.NotificationEventEnvelope.PartySessionV1)
  return _internal_partysessionv1();
}
inline ::session::PartySessionV1* NotificationEventEnvelope::unsafe_arena_release_partysessionv1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:session.NotificationEventEnvelope.PartySessionV1)
  if (_internal_has_partysessionv1()) {
    clear_has_payload();
    ::session::PartySessionV1* temp = payload_.partysessionv1_;
    payload_.partysessionv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotificationEventEnvelope::unsafe_arena_set_allocated_partysessionv1(::session::PartySessionV1* partysessionv1) {
  clear_payload();
  if (partysessionv1) {
    set_has_partysessionv1();
    payload_.partysessionv1_ = partysessionv1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.NotificationEventEnvelope.PartySessionV1)
}
inline ::session::PartySessionV1* NotificationEventEnvelope::_internal_mutable_partysessionv1() {
  if (!_internal_has_partysessionv1()) {
    clear_payload();
    set_has_partysessionv1();
    payload_.partysessionv1_ = CreateMaybeMessage< ::session::PartySessionV1 >(GetArenaForAllocation());
  }
  return payload_.partysessionv1_;
}
inline ::session::PartySessionV1* NotificationEventEnvelope::mutable_partysessionv1() {
  ::session::PartySessionV1* _msg = _internal_mutable_partysessionv1();
  // @@protoc_insertion_point(field_mutable:session.NotificationEventEnvelope.PartySessionV1)
  return _msg;
}

// .session.GameSessionNotificationUserInvitedV1 GameSessionNotificationUserInvitedV1 = 7 [json_name = "OnSessionInvited"];
inline bool NotificationEventEnvelope::_internal_has_gamesessionnotificationuserinvitedv1() const {
  return payload_case() == kGameSessionNotificationUserInvitedV1;
}
inline bool NotificationEventEnvelope::has_gamesessionnotificationuserinvitedv1() const {
  return _internal_has_gamesessionnotificationuserinvitedv1();
}
inline void NotificationEventEnvelope::set_has_gamesessionnotificationuserinvitedv1() {
  _oneof_case_[0] = kGameSessionNotificationUserInvitedV1;
}
inline void NotificationEventEnvelope::clear_gamesessionnotificationuserinvitedv1() {
  if (_internal_has_gamesessionnotificationuserinvitedv1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.gamesessionnotificationuserinvitedv1_;
    }
    clear_has_payload();
  }
}
inline ::session::GameSessionNotificationUserInvitedV1* NotificationEventEnvelope::release_gamesessionnotificationuserinvitedv1() {
  // @@protoc_insertion_point(field_release:session.NotificationEventEnvelope.GameSessionNotificationUserInvitedV1)
  if (_internal_has_gamesessionnotificationuserinvitedv1()) {
    clear_has_payload();
      ::session::GameSessionNotificationUserInvitedV1* temp = payload_.gamesessionnotificationuserinvitedv1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.gamesessionnotificationuserinvitedv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::session::GameSessionNotificationUserInvitedV1& NotificationEventEnvelope::_internal_gamesessionnotificationuserinvitedv1() const {
  return _internal_has_gamesessionnotificationuserinvitedv1()
      ? *payload_.gamesessionnotificationuserinvitedv1_
      : reinterpret_cast< ::session::GameSessionNotificationUserInvitedV1&>(::session::_GameSessionNotificationUserInvitedV1_default_instance_);
}
inline const ::session::GameSessionNotificationUserInvitedV1& NotificationEventEnvelope::gamesessionnotificationuserinvitedv1() const {
  // @@protoc_insertion_point(field_get:session.NotificationEventEnvelope.GameSessionNotificationUserInvitedV1)
  return _internal_gamesessionnotificationuserinvitedv1();
}
inline ::session::GameSessionNotificationUserInvitedV1* NotificationEventEnvelope::unsafe_arena_release_gamesessionnotificationuserinvitedv1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:session.NotificationEventEnvelope.GameSessionNotificationUserInvitedV1)
  if (_internal_has_gamesessionnotificationuserinvitedv1()) {
    clear_has_payload();
    ::session::GameSessionNotificationUserInvitedV1* temp = payload_.gamesessionnotificationuserinvitedv1_;
    payload_.gamesessionnotificationuserinvitedv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotificationEventEnvelope::unsafe_arena_set_allocated_gamesessionnotificationuserinvitedv1(::session::GameSessionNotificationUserInvitedV1* gamesessionnotificationuserinvitedv1) {
  clear_payload();
  if (gamesessionnotificationuserinvitedv1) {
    set_has_gamesessionnotificationuserinvitedv1();
    payload_.gamesessionnotificationuserinvitedv1_ = gamesessionnotificationuserinvitedv1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.NotificationEventEnvelope.GameSessionNotificationUserInvitedV1)
}
inline ::session::GameSessionNotificationUserInvitedV1* NotificationEventEnvelope::_internal_mutable_gamesessionnotificationuserinvitedv1() {
  if (!_internal_has_gamesessionnotificationuserinvitedv1()) {
    clear_payload();
    set_has_gamesessionnotificationuserinvitedv1();
    payload_.gamesessionnotificationuserinvitedv1_ = CreateMaybeMessage< ::session::GameSessionNotificationUserInvitedV1 >(GetArenaForAllocation());
  }
  return payload_.gamesessionnotificationuserinvitedv1_;
}
inline ::session::GameSessionNotificationUserInvitedV1* NotificationEventEnvelope::mutable_gamesessionnotificationuserinvitedv1() {
  ::session::GameSessionNotificationUserInvitedV1* _msg = _internal_mutable_gamesessionnotificationuserinvitedv1();
  // @@protoc_insertion_point(field_mutable:session.NotificationEventEnvelope.GameSessionNotificationUserInvitedV1)
  return _msg;
}

// .session.GameSessionNotificationUserJoinedV1 GameSessionNotificationUserJoinedV1 = 8 [json_name = "OnSessionJoined"];
inline bool NotificationEventEnvelope::_internal_has_gamesessionnotificationuserjoinedv1() const {
  return payload_case() == kGameSessionNotificationUserJoinedV1;
}
inline bool NotificationEventEnvelope::has_gamesessionnotificationuserjoinedv1() const {
  return _internal_has_gamesessionnotificationuserjoinedv1();
}
inline void NotificationEventEnvelope::set_has_gamesessionnotificationuserjoinedv1() {
  _oneof_case_[0] = kGameSessionNotificationUserJoinedV1;
}
inline void NotificationEventEnvelope::clear_gamesessionnotificationuserjoinedv1() {
  if (_internal_has_gamesessionnotificationuserjoinedv1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.gamesessionnotificationuserjoinedv1_;
    }
    clear_has_payload();
  }
}
inline ::session::GameSessionNotificationUserJoinedV1* NotificationEventEnvelope::release_gamesessionnotificationuserjoinedv1() {
  // @@protoc_insertion_point(field_release:session.NotificationEventEnvelope.GameSessionNotificationUserJoinedV1)
  if (_internal_has_gamesessionnotificationuserjoinedv1()) {
    clear_has_payload();
      ::session::GameSessionNotificationUserJoinedV1* temp = payload_.gamesessionnotificationuserjoinedv1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.gamesessionnotificationuserjoinedv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::session::GameSessionNotificationUserJoinedV1& NotificationEventEnvelope::_internal_gamesessionnotificationuserjoinedv1() const {
  return _internal_has_gamesessionnotificationuserjoinedv1()
      ? *payload_.gamesessionnotificationuserjoinedv1_
      : reinterpret_cast< ::session::GameSessionNotificationUserJoinedV1&>(::session::_GameSessionNotificationUserJoinedV1_default_instance_);
}
inline const ::session::GameSessionNotificationUserJoinedV1& NotificationEventEnvelope::gamesessionnotificationuserjoinedv1() const {
  // @@protoc_insertion_point(field_get:session.NotificationEventEnvelope.GameSessionNotificationUserJoinedV1)
  return _internal_gamesessionnotificationuserjoinedv1();
}
inline ::session::GameSessionNotificationUserJoinedV1* NotificationEventEnvelope::unsafe_arena_release_gamesessionnotificationuserjoinedv1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:session.NotificationEventEnvelope.GameSessionNotificationUserJoinedV1)
  if (_internal_has_gamesessionnotificationuserjoinedv1()) {
    clear_has_payload();
    ::session::GameSessionNotificationUserJoinedV1* temp = payload_.gamesessionnotificationuserjoinedv1_;
    payload_.gamesessionnotificationuserjoinedv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotificationEventEnvelope::unsafe_arena_set_allocated_gamesessionnotificationuserjoinedv1(::session::GameSessionNotificationUserJoinedV1* gamesessionnotificationuserjoinedv1) {
  clear_payload();
  if (gamesessionnotificationuserjoinedv1) {
    set_has_gamesessionnotificationuserjoinedv1();
    payload_.gamesessionnotificationuserjoinedv1_ = gamesessionnotificationuserjoinedv1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.NotificationEventEnvelope.GameSessionNotificationUserJoinedV1)
}
inline ::session::GameSessionNotificationUserJoinedV1* NotificationEventEnvelope::_internal_mutable_gamesessionnotificationuserjoinedv1() {
  if (!_internal_has_gamesessionnotificationuserjoinedv1()) {
    clear_payload();
    set_has_gamesessionnotificationuserjoinedv1();
    payload_.gamesessionnotificationuserjoinedv1_ = CreateMaybeMessage< ::session::GameSessionNotificationUserJoinedV1 >(GetArenaForAllocation());
  }
  return payload_.gamesessionnotificationuserjoinedv1_;
}
inline ::session::GameSessionNotificationUserJoinedV1* NotificationEventEnvelope::mutable_gamesessionnotificationuserjoinedv1() {
  ::session::GameSessionNotificationUserJoinedV1* _msg = _internal_mutable_gamesessionnotificationuserjoinedv1();
  // @@protoc_insertion_point(field_mutable:session.NotificationEventEnvelope.GameSessionNotificationUserJoinedV1)
  return _msg;
}

// .session.GameSessionNotificationMembersChangedV1 GameSessionNotificationMembersChangedV1 = 9 [json_name = "OnSessionMembersChanged"];
inline bool NotificationEventEnvelope::_internal_has_gamesessionnotificationmemberschangedv1() const {
  return payload_case() == kGameSessionNotificationMembersChangedV1;
}
inline bool NotificationEventEnvelope::has_gamesessionnotificationmemberschangedv1() const {
  return _internal_has_gamesessionnotificationmemberschangedv1();
}
inline void NotificationEventEnvelope::set_has_gamesessionnotificationmemberschangedv1() {
  _oneof_case_[0] = kGameSessionNotificationMembersChangedV1;
}
inline void NotificationEventEnvelope::clear_gamesessionnotificationmemberschangedv1() {
  if (_internal_has_gamesessionnotificationmemberschangedv1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.gamesessionnotificationmemberschangedv1_;
    }
    clear_has_payload();
  }
}
inline ::session::GameSessionNotificationMembersChangedV1* NotificationEventEnvelope::release_gamesessionnotificationmemberschangedv1() {
  // @@protoc_insertion_point(field_release:session.NotificationEventEnvelope.GameSessionNotificationMembersChangedV1)
  if (_internal_has_gamesessionnotificationmemberschangedv1()) {
    clear_has_payload();
      ::session::GameSessionNotificationMembersChangedV1* temp = payload_.gamesessionnotificationmemberschangedv1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.gamesessionnotificationmemberschangedv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::session::GameSessionNotificationMembersChangedV1& NotificationEventEnvelope::_internal_gamesessionnotificationmemberschangedv1() const {
  return _internal_has_gamesessionnotificationmemberschangedv1()
      ? *payload_.gamesessionnotificationmemberschangedv1_
      : reinterpret_cast< ::session::GameSessionNotificationMembersChangedV1&>(::session::_GameSessionNotificationMembersChangedV1_default_instance_);
}
inline const ::session::GameSessionNotificationMembersChangedV1& NotificationEventEnvelope::gamesessionnotificationmemberschangedv1() const {
  // @@protoc_insertion_point(field_get:session.NotificationEventEnvelope.GameSessionNotificationMembersChangedV1)
  return _internal_gamesessionnotificationmemberschangedv1();
}
inline ::session::GameSessionNotificationMembersChangedV1* NotificationEventEnvelope::unsafe_arena_release_gamesessionnotificationmemberschangedv1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:session.NotificationEventEnvelope.GameSessionNotificationMembersChangedV1)
  if (_internal_has_gamesessionnotificationmemberschangedv1()) {
    clear_has_payload();
    ::session::GameSessionNotificationMembersChangedV1* temp = payload_.gamesessionnotificationmemberschangedv1_;
    payload_.gamesessionnotificationmemberschangedv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotificationEventEnvelope::unsafe_arena_set_allocated_gamesessionnotificationmemberschangedv1(::session::GameSessionNotificationMembersChangedV1* gamesessionnotificationmemberschangedv1) {
  clear_payload();
  if (gamesessionnotificationmemberschangedv1) {
    set_has_gamesessionnotificationmemberschangedv1();
    payload_.gamesessionnotificationmemberschangedv1_ = gamesessionnotificationmemberschangedv1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.NotificationEventEnvelope.GameSessionNotificationMembersChangedV1)
}
inline ::session::GameSessionNotificationMembersChangedV1* NotificationEventEnvelope::_internal_mutable_gamesessionnotificationmemberschangedv1() {
  if (!_internal_has_gamesessionnotificationmemberschangedv1()) {
    clear_payload();
    set_has_gamesessionnotificationmemberschangedv1();
    payload_.gamesessionnotificationmemberschangedv1_ = CreateMaybeMessage< ::session::GameSessionNotificationMembersChangedV1 >(GetArenaForAllocation());
  }
  return payload_.gamesessionnotificationmemberschangedv1_;
}
inline ::session::GameSessionNotificationMembersChangedV1* NotificationEventEnvelope::mutable_gamesessionnotificationmemberschangedv1() {
  ::session::GameSessionNotificationMembersChangedV1* _msg = _internal_mutable_gamesessionnotificationmemberschangedv1();
  // @@protoc_insertion_point(field_mutable:session.NotificationEventEnvelope.GameSessionNotificationMembersChangedV1)
  return _msg;
}

// .session.GameSessionV1 GameSessionV1 = 10 [json_name = "OnGameSessionUpdated"];
inline bool NotificationEventEnvelope::_internal_has_gamesessionv1() const {
  return payload_case() == kGameSessionV1;
}
inline bool NotificationEventEnvelope::has_gamesessionv1() const {
  return _internal_has_gamesessionv1();
}
inline void NotificationEventEnvelope::set_has_gamesessionv1() {
  _oneof_case_[0] = kGameSessionV1;
}
inline void NotificationEventEnvelope::clear_gamesessionv1() {
  if (_internal_has_gamesessionv1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.gamesessionv1_;
    }
    clear_has_payload();
  }
}
inline ::session::GameSessionV1* NotificationEventEnvelope::release_gamesessionv1() {
  // @@protoc_insertion_point(field_release:session.NotificationEventEnvelope.GameSessionV1)
  if (_internal_has_gamesessionv1()) {
    clear_has_payload();
      ::session::GameSessionV1* temp = payload_.gamesessionv1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.gamesessionv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::session::GameSessionV1& NotificationEventEnvelope::_internal_gamesessionv1() const {
  return _internal_has_gamesessionv1()
      ? *payload_.gamesessionv1_
      : reinterpret_cast< ::session::GameSessionV1&>(::session::_GameSessionV1_default_instance_);
}
inline const ::session::GameSessionV1& NotificationEventEnvelope::gamesessionv1() const {
  // @@protoc_insertion_point(field_get:session.NotificationEventEnvelope.GameSessionV1)
  return _internal_gamesessionv1();
}
inline ::session::GameSessionV1* NotificationEventEnvelope::unsafe_arena_release_gamesessionv1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:session.NotificationEventEnvelope.GameSessionV1)
  if (_internal_has_gamesessionv1()) {
    clear_has_payload();
    ::session::GameSessionV1* temp = payload_.gamesessionv1_;
    payload_.gamesessionv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotificationEventEnvelope::unsafe_arena_set_allocated_gamesessionv1(::session::GameSessionV1* gamesessionv1) {
  clear_payload();
  if (gamesessionv1) {
    set_has_gamesessionv1();
    payload_.gamesessionv1_ = gamesessionv1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.NotificationEventEnvelope.GameSessionV1)
}
inline ::session::GameSessionV1* NotificationEventEnvelope::_internal_mutable_gamesessionv1() {
  if (!_internal_has_gamesessionv1()) {
    clear_payload();
    set_has_gamesessionv1();
    payload_.gamesessionv1_ = CreateMaybeMessage< ::session::GameSessionV1 >(GetArenaForAllocation());
  }
  return payload_.gamesessionv1_;
}
inline ::session::GameSessionV1* NotificationEventEnvelope::mutable_gamesessionv1() {
  ::session::GameSessionV1* _msg = _internal_mutable_gamesessionv1();
  // @@protoc_insertion_point(field_mutable:session.NotificationEventEnvelope.GameSessionV1)
  return _msg;
}

// .session.DSStatusChangedNotificationV1 DSStatusChangedNotificationV1 = 11 [json_name = "OnDSStatusChangedNotif"];
inline bool NotificationEventEnvelope::_internal_has_dsstatuschangednotificationv1() const {
  return payload_case() == kDSStatusChangedNotificationV1;
}
inline bool NotificationEventEnvelope::has_dsstatuschangednotificationv1() const {
  return _internal_has_dsstatuschangednotificationv1();
}
inline void NotificationEventEnvelope::set_has_dsstatuschangednotificationv1() {
  _oneof_case_[0] = kDSStatusChangedNotificationV1;
}
inline void NotificationEventEnvelope::clear_dsstatuschangednotificationv1() {
  if (_internal_has_dsstatuschangednotificationv1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.dsstatuschangednotificationv1_;
    }
    clear_has_payload();
  }
}
inline ::session::DSStatusChangedNotificationV1* NotificationEventEnvelope::release_dsstatuschangednotificationv1() {
  // @@protoc_insertion_point(field_release:session.NotificationEventEnvelope.DSStatusChangedNotificationV1)
  if (_internal_has_dsstatuschangednotificationv1()) {
    clear_has_payload();
      ::session::DSStatusChangedNotificationV1* temp = payload_.dsstatuschangednotificationv1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.dsstatuschangednotificationv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::session::DSStatusChangedNotificationV1& NotificationEventEnvelope::_internal_dsstatuschangednotificationv1() const {
  return _internal_has_dsstatuschangednotificationv1()
      ? *payload_.dsstatuschangednotificationv1_
      : reinterpret_cast< ::session::DSStatusChangedNotificationV1&>(::session::_DSStatusChangedNotificationV1_default_instance_);
}
inline const ::session::DSStatusChangedNotificationV1& NotificationEventEnvelope::dsstatuschangednotificationv1() const {
  // @@protoc_insertion_point(field_get:session.NotificationEventEnvelope.DSStatusChangedNotificationV1)
  return _internal_dsstatuschangednotificationv1();
}
inline ::session::DSStatusChangedNotificationV1* NotificationEventEnvelope::unsafe_arena_release_dsstatuschangednotificationv1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:session.NotificationEventEnvelope.DSStatusChangedNotificationV1)
  if (_internal_has_dsstatuschangednotificationv1()) {
    clear_has_payload();
    ::session::DSStatusChangedNotificationV1* temp = payload_.dsstatuschangednotificationv1_;
    payload_.dsstatuschangednotificationv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotificationEventEnvelope::unsafe_arena_set_allocated_dsstatuschangednotificationv1(::session::DSStatusChangedNotificationV1* dsstatuschangednotificationv1) {
  clear_payload();
  if (dsstatuschangednotificationv1) {
    set_has_dsstatuschangednotificationv1();
    payload_.dsstatuschangednotificationv1_ = dsstatuschangednotificationv1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.NotificationEventEnvelope.DSStatusChangedNotificationV1)
}
inline ::session::DSStatusChangedNotificationV1* NotificationEventEnvelope::_internal_mutable_dsstatuschangednotificationv1() {
  if (!_internal_has_dsstatuschangednotificationv1()) {
    clear_payload();
    set_has_dsstatuschangednotificationv1();
    payload_.dsstatuschangednotificationv1_ = CreateMaybeMessage< ::session::DSStatusChangedNotificationV1 >(GetArenaForAllocation());
  }
  return payload_.dsstatuschangednotificationv1_;
}
inline ::session::DSStatusChangedNotificationV1* NotificationEventEnvelope::mutable_dsstatuschangednotificationv1() {
  ::session::DSStatusChangedNotificationV1* _msg = _internal_mutable_dsstatuschangednotificationv1();
  // @@protoc_insertion_point(field_mutable:session.NotificationEventEnvelope.DSStatusChangedNotificationV1)
  return _msg;
}

inline bool NotificationEventEnvelope::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void NotificationEventEnvelope::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline NotificationEventEnvelope::PayloadCase NotificationEventEnvelope::payload_case() const {
  return NotificationEventEnvelope::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UserV1

// string id = 1 [json_name = "_id"];
inline void UserV1::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UserV1::id() const {
  // @@protoc_insertion_point(field_get:session.UserV1.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserV1::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.UserV1.id)
}
inline std::string* UserV1::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:session.UserV1.id)
  return _s;
}
inline const std::string& UserV1::_internal_id() const {
  return id_.Get();
}
inline void UserV1::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserV1::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserV1::release_id() {
  // @@protoc_insertion_point(field_release:session.UserV1.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserV1::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.UserV1.id)
}

// string status = 2 [json_name = "status"];
inline void UserV1::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& UserV1::status() const {
  // @@protoc_insertion_point(field_get:session.UserV1.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserV1::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.UserV1.status)
}
inline std::string* UserV1::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:session.UserV1.status)
  return _s;
}
inline const std::string& UserV1::_internal_status() const {
  return status_.Get();
}
inline void UserV1::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserV1::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserV1::release_status() {
  // @@protoc_insertion_point(field_release:session.UserV1.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserV1::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.UserV1.status)
}

// string updatedAt = 3 [json_name = "updatedAt"];
inline void UserV1::clear_updatedat() {
  updatedat_.ClearToEmpty();
}
inline const std::string& UserV1::updatedat() const {
  // @@protoc_insertion_point(field_get:session.UserV1.updatedAt)
  return _internal_updatedat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserV1::set_updatedat(ArgT0&& arg0, ArgT... args) {
 
 updatedat_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.UserV1.updatedAt)
}
inline std::string* UserV1::mutable_updatedat() {
  std::string* _s = _internal_mutable_updatedat();
  // @@protoc_insertion_point(field_mutable:session.UserV1.updatedAt)
  return _s;
}
inline const std::string& UserV1::_internal_updatedat() const {
  return updatedat_.Get();
}
inline void UserV1::_internal_set_updatedat(const std::string& value) {
  
  updatedat_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserV1::_internal_mutable_updatedat() {
  
  return updatedat_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserV1::release_updatedat() {
  // @@protoc_insertion_point(field_release:session.UserV1.updatedAt)
  return updatedat_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserV1::set_allocated_updatedat(std::string* updatedat) {
  if (updatedat != nullptr) {
    
  } else {
    
  }
  updatedat_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), updatedat,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (updatedat_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    updatedat_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.UserV1.updatedAt)
}

// string platform_id = 4 [json_name = "platformID"];
inline void UserV1::clear_platform_id() {
  platform_id_.ClearToEmpty();
}
inline const std::string& UserV1::platform_id() const {
  // @@protoc_insertion_point(field_get:session.UserV1.platform_id)
  return _internal_platform_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserV1::set_platform_id(ArgT0&& arg0, ArgT... args) {
 
 platform_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.UserV1.platform_id)
}
inline std::string* UserV1::mutable_platform_id() {
  std::string* _s = _internal_mutable_platform_id();
  // @@protoc_insertion_point(field_mutable:session.UserV1.platform_id)
  return _s;
}
inline const std::string& UserV1::_internal_platform_id() const {
  return platform_id_.Get();
}
inline void UserV1::_internal_set_platform_id(const std::string& value) {
  
  platform_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserV1::_internal_mutable_platform_id() {
  
  return platform_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserV1::release_platform_id() {
  // @@protoc_insertion_point(field_release:session.UserV1.platform_id)
  return platform_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserV1::set_allocated_platform_id(std::string* platform_id) {
  if (platform_id != nullptr) {
    
  } else {
    
  }
  platform_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.UserV1.platform_id)
}

// string platform_user_id = 5 [json_name = "platformUserID"];
inline void UserV1::clear_platform_user_id() {
  platform_user_id_.ClearToEmpty();
}
inline const std::string& UserV1::platform_user_id() const {
  // @@protoc_insertion_point(field_get:session.UserV1.platform_user_id)
  return _internal_platform_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserV1::set_platform_user_id(ArgT0&& arg0, ArgT... args) {
 
 platform_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.UserV1.platform_user_id)
}
inline std::string* UserV1::mutable_platform_user_id() {
  std::string* _s = _internal_mutable_platform_user_id();
  // @@protoc_insertion_point(field_mutable:session.UserV1.platform_user_id)
  return _s;
}
inline const std::string& UserV1::_internal_platform_user_id() const {
  return platform_user_id_.Get();
}
inline void UserV1::_internal_set_platform_user_id(const std::string& value) {
  
  platform_user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserV1::_internal_mutable_platform_user_id() {
  
  return platform_user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserV1::release_platform_user_id() {
  // @@protoc_insertion_point(field_release:session.UserV1.platform_user_id)
  return platform_user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserV1::set_allocated_platform_user_id(std::string* platform_user_id) {
  if (platform_user_id != nullptr) {
    
  } else {
    
  }
  platform_user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform_user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.UserV1.platform_user_id)
}

// -------------------------------------------------------------------

// SessionConfigV1

// int32 max_size = 1 [json_name = "maxSize"];
inline void SessionConfigV1::clear_max_size() {
  max_size_ = 0;
}
inline int32_t SessionConfigV1::_internal_max_size() const {
  return max_size_;
}
inline int32_t SessionConfigV1::max_size() const {
  // @@protoc_insertion_point(field_get:session.SessionConfigV1.max_size)
  return _internal_max_size();
}
inline void SessionConfigV1::_internal_set_max_size(int32_t value) {
  
  max_size_ = value;
}
inline void SessionConfigV1::set_max_size(int32_t value) {
  _internal_set_max_size(value);
  // @@protoc_insertion_point(field_set:session.SessionConfigV1.max_size)
}

// int32 initial_join_timeout = 2 [json_name = "initialJoinTimeout"];
inline void SessionConfigV1::clear_initial_join_timeout() {
  initial_join_timeout_ = 0;
}
inline int32_t SessionConfigV1::_internal_initial_join_timeout() const {
  return initial_join_timeout_;
}
inline int32_t SessionConfigV1::initial_join_timeout() const {
  // @@protoc_insertion_point(field_get:session.SessionConfigV1.initial_join_timeout)
  return _internal_initial_join_timeout();
}
inline void SessionConfigV1::_internal_set_initial_join_timeout(int32_t value) {
  
  initial_join_timeout_ = value;
}
inline void SessionConfigV1::set_initial_join_timeout(int32_t value) {
  _internal_set_initial_join_timeout(value);
  // @@protoc_insertion_point(field_set:session.SessionConfigV1.initial_join_timeout)
}

// int32 rejoin_timeout = 3 [json_name = "rejoinTimeout"];
inline void SessionConfigV1::clear_rejoin_timeout() {
  rejoin_timeout_ = 0;
}
inline int32_t SessionConfigV1::_internal_rejoin_timeout() const {
  return rejoin_timeout_;
}
inline int32_t SessionConfigV1::rejoin_timeout() const {
  // @@protoc_insertion_point(field_get:session.SessionConfigV1.rejoin_timeout)
  return _internal_rejoin_timeout();
}
inline void SessionConfigV1::_internal_set_rejoin_timeout(int32_t value) {
  
  rejoin_timeout_ = value;
}
inline void SessionConfigV1::set_rejoin_timeout(int32_t value) {
  _internal_set_rejoin_timeout(value);
  // @@protoc_insertion_point(field_set:session.SessionConfigV1.rejoin_timeout)
}

// -------------------------------------------------------------------

// PartySessionV1

// string id = 1 [json_name = "_id"];
inline void PartySessionV1::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& PartySessionV1::id() const {
  // @@protoc_insertion_point(field_get:session.PartySessionV1.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartySessionV1::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartySessionV1.id)
}
inline std::string* PartySessionV1::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:session.PartySessionV1.id)
  return _s;
}
inline const std::string& PartySessionV1::_internal_id() const {
  return id_.Get();
}
inline void PartySessionV1::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartySessionV1::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartySessionV1::release_id() {
  // @@protoc_insertion_point(field_release:session.PartySessionV1.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartySessionV1::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartySessionV1.id)
}

// string namespace = 2 [json_name = "namespace"];
inline void PartySessionV1::clear_namespace_() {
  namespace__.ClearToEmpty();
}
inline const std::string& PartySessionV1::namespace_() const {
  // @@protoc_insertion_point(field_get:session.PartySessionV1.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartySessionV1::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartySessionV1.namespace)
}
inline std::string* PartySessionV1::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:session.PartySessionV1.namespace)
  return _s;
}
inline const std::string& PartySessionV1::_internal_namespace_() const {
  return namespace__.Get();
}
inline void PartySessionV1::_internal_set_namespace_(const std::string& value) {
  
  namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartySessionV1::_internal_mutable_namespace_() {
  
  return namespace__.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartySessionV1::release_namespace_() {
  // @@protoc_insertion_point(field_release:session.PartySessionV1.namespace)
  return namespace__.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartySessionV1::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  namespace__.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (namespace__.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    namespace__.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartySessionV1.namespace)
}

// repeated .session.UserV1 members = 3 [json_name = "members"];
inline int PartySessionV1::_internal_members_size() const {
  return members_.size();
}
inline int PartySessionV1::members_size() const {
  return _internal_members_size();
}
inline void PartySessionV1::clear_members() {
  members_.Clear();
}
inline ::session::UserV1* PartySessionV1::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:session.PartySessionV1.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >*
PartySessionV1::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:session.PartySessionV1.members)
  return &members_;
}
inline const ::session::UserV1& PartySessionV1::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::session::UserV1& PartySessionV1::members(int index) const {
  // @@protoc_insertion_point(field_get:session.PartySessionV1.members)
  return _internal_members(index);
}
inline ::session::UserV1* PartySessionV1::_internal_add_members() {
  return members_.Add();
}
inline ::session::UserV1* PartySessionV1::add_members() {
  ::session::UserV1* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:session.PartySessionV1.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >&
PartySessionV1::members() const {
  // @@protoc_insertion_point(field_list:session.PartySessionV1.members)
  return members_;
}

// bytes attributes = 4 [json_name = "attributes"];
inline void PartySessionV1::clear_attributes() {
  attributes_.ClearToEmpty();
}
inline const std::string& PartySessionV1::attributes() const {
  // @@protoc_insertion_point(field_get:session.PartySessionV1.attributes)
  return _internal_attributes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartySessionV1::set_attributes(ArgT0&& arg0, ArgT... args) {
 
 attributes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartySessionV1.attributes)
}
inline std::string* PartySessionV1::mutable_attributes() {
  std::string* _s = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:session.PartySessionV1.attributes)
  return _s;
}
inline const std::string& PartySessionV1::_internal_attributes() const {
  return attributes_.Get();
}
inline void PartySessionV1::_internal_set_attributes(const std::string& value) {
  
  attributes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartySessionV1::_internal_mutable_attributes() {
  
  return attributes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartySessionV1::release_attributes() {
  // @@protoc_insertion_point(field_release:session.PartySessionV1.attributes)
  return attributes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartySessionV1::set_allocated_attributes(std::string* attributes) {
  if (attributes != nullptr) {
    
  } else {
    
  }
  attributes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attributes,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (attributes_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    attributes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartySessionV1.attributes)
}

// string join_type = 5 [json_name = "joinType"];
inline void PartySessionV1::clear_join_type() {
  join_type_.ClearToEmpty();
}
inline const std::string& PartySessionV1::join_type() const {
  // @@protoc_insertion_point(field_get:session.PartySessionV1.join_type)
  return _internal_join_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartySessionV1::set_join_type(ArgT0&& arg0, ArgT... args) {
 
 join_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartySessionV1.join_type)
}
inline std::string* PartySessionV1::mutable_join_type() {
  std::string* _s = _internal_mutable_join_type();
  // @@protoc_insertion_point(field_mutable:session.PartySessionV1.join_type)
  return _s;
}
inline const std::string& PartySessionV1::_internal_join_type() const {
  return join_type_.Get();
}
inline void PartySessionV1::_internal_set_join_type(const std::string& value) {
  
  join_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartySessionV1::_internal_mutable_join_type() {
  
  return join_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartySessionV1::release_join_type() {
  // @@protoc_insertion_point(field_release:session.PartySessionV1.join_type)
  return join_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartySessionV1::set_allocated_join_type(std::string* join_type) {
  if (join_type != nullptr) {
    
  } else {
    
  }
  join_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), join_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (join_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    join_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartySessionV1.join_type)
}

// string created_at = 6 [json_name = "createdAt"];
inline void PartySessionV1::clear_created_at() {
  created_at_.ClearToEmpty();
}
inline const std::string& PartySessionV1::created_at() const {
  // @@protoc_insertion_point(field_get:session.PartySessionV1.created_at)
  return _internal_created_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartySessionV1::set_created_at(ArgT0&& arg0, ArgT... args) {
 
 created_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartySessionV1.created_at)
}
inline std::string* PartySessionV1::mutable_created_at() {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:session.PartySessionV1.created_at)
  return _s;
}
inline const std::string& PartySessionV1::_internal_created_at() const {
  return created_at_.Get();
}
inline void PartySessionV1::_internal_set_created_at(const std::string& value) {
  
  created_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartySessionV1::_internal_mutable_created_at() {
  
  return created_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartySessionV1::release_created_at() {
  // @@protoc_insertion_point(field_release:session.PartySessionV1.created_at)
  return created_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartySessionV1::set_allocated_created_at(std::string* created_at) {
  if (created_at != nullptr) {
    
  } else {
    
  }
  created_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), created_at,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (created_at_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    created_at_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartySessionV1.created_at)
}

// string updated_at = 7 [json_name = "updatedAt"];
inline void PartySessionV1::clear_updated_at() {
  updated_at_.ClearToEmpty();
}
inline const std::string& PartySessionV1::updated_at() const {
  // @@protoc_insertion_point(field_get:session.PartySessionV1.updated_at)
  return _internal_updated_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartySessionV1::set_updated_at(ArgT0&& arg0, ArgT... args) {
 
 updated_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartySessionV1.updated_at)
}
inline std::string* PartySessionV1::mutable_updated_at() {
  std::string* _s = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:session.PartySessionV1.updated_at)
  return _s;
}
inline const std::string& PartySessionV1::_internal_updated_at() const {
  return updated_at_.Get();
}
inline void PartySessionV1::_internal_set_updated_at(const std::string& value) {
  
  updated_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartySessionV1::_internal_mutable_updated_at() {
  
  return updated_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartySessionV1::release_updated_at() {
  // @@protoc_insertion_point(field_release:session.PartySessionV1.updated_at)
  return updated_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartySessionV1::set_allocated_updated_at(std::string* updated_at) {
  if (updated_at != nullptr) {
    
  } else {
    
  }
  updated_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), updated_at,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (updated_at_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    updated_at_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartySessionV1.updated_at)
}

// .session.SessionConfigV1 config = 8 [json_name = "config"];
inline bool PartySessionV1::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool PartySessionV1::has_config() const {
  return _internal_has_config();
}
inline void PartySessionV1::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::session::SessionConfigV1& PartySessionV1::_internal_config() const {
  const ::session::SessionConfigV1* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::session::SessionConfigV1&>(
      ::session::_SessionConfigV1_default_instance_);
}
inline const ::session::SessionConfigV1& PartySessionV1::config() const {
  // @@protoc_insertion_point(field_get:session.PartySessionV1.config)
  return _internal_config();
}
inline void PartySessionV1::unsafe_arena_set_allocated_config(
    ::session::SessionConfigV1* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.PartySessionV1.config)
}
inline ::session::SessionConfigV1* PartySessionV1::release_config() {
  
  ::session::SessionConfigV1* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::session::SessionConfigV1* PartySessionV1::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:session.PartySessionV1.config)
  
  ::session::SessionConfigV1* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::session::SessionConfigV1* PartySessionV1::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::session::SessionConfigV1>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::session::SessionConfigV1* PartySessionV1::mutable_config() {
  ::session::SessionConfigV1* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:session.PartySessionV1.config)
  return _msg;
}
inline void PartySessionV1::set_allocated_config(::session::SessionConfigV1* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::session::SessionConfigV1>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:session.PartySessionV1.config)
}

// int32 version = 9 [json_name = "_version"];
inline void PartySessionV1::clear_version() {
  version_ = 0;
}
inline int32_t PartySessionV1::_internal_version() const {
  return version_;
}
inline int32_t PartySessionV1::version() const {
  // @@protoc_insertion_point(field_get:session.PartySessionV1.version)
  return _internal_version();
}
inline void PartySessionV1::_internal_set_version(int32_t value) {
  
  version_ = value;
}
inline void PartySessionV1::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:session.PartySessionV1.version)
}

// string leader_id = 10 [json_name = "leaderID"];
inline void PartySessionV1::clear_leader_id() {
  leader_id_.ClearToEmpty();
}
inline const std::string& PartySessionV1::leader_id() const {
  // @@protoc_insertion_point(field_get:session.PartySessionV1.leader_id)
  return _internal_leader_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartySessionV1::set_leader_id(ArgT0&& arg0, ArgT... args) {
 
 leader_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartySessionV1.leader_id)
}
inline std::string* PartySessionV1::mutable_leader_id() {
  std::string* _s = _internal_mutable_leader_id();
  // @@protoc_insertion_point(field_mutable:session.PartySessionV1.leader_id)
  return _s;
}
inline const std::string& PartySessionV1::_internal_leader_id() const {
  return leader_id_.Get();
}
inline void PartySessionV1::_internal_set_leader_id(const std::string& value) {
  
  leader_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartySessionV1::_internal_mutable_leader_id() {
  
  return leader_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartySessionV1::release_leader_id() {
  // @@protoc_insertion_point(field_release:session.PartySessionV1.leader_id)
  return leader_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartySessionV1::set_allocated_leader_id(std::string* leader_id) {
  if (leader_id != nullptr) {
    
  } else {
    
  }
  leader_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (leader_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    leader_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartySessionV1.leader_id)
}

// -------------------------------------------------------------------

// PartyNotificationUserJoinedV1

// repeated .session.UserV1 members = 1 [json_name = "members"];
inline int PartyNotificationUserJoinedV1::_internal_members_size() const {
  return members_.size();
}
inline int PartyNotificationUserJoinedV1::members_size() const {
  return _internal_members_size();
}
inline void PartyNotificationUserJoinedV1::clear_members() {
  members_.Clear();
}
inline ::session::UserV1* PartyNotificationUserJoinedV1::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:session.PartyNotificationUserJoinedV1.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >*
PartyNotificationUserJoinedV1::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:session.PartyNotificationUserJoinedV1.members)
  return &members_;
}
inline const ::session::UserV1& PartyNotificationUserJoinedV1::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::session::UserV1& PartyNotificationUserJoinedV1::members(int index) const {
  // @@protoc_insertion_point(field_get:session.PartyNotificationUserJoinedV1.members)
  return _internal_members(index);
}
inline ::session::UserV1* PartyNotificationUserJoinedV1::_internal_add_members() {
  return members_.Add();
}
inline ::session::UserV1* PartyNotificationUserJoinedV1::add_members() {
  ::session::UserV1* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:session.PartyNotificationUserJoinedV1.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >&
PartyNotificationUserJoinedV1::members() const {
  // @@protoc_insertion_point(field_list:session.PartyNotificationUserJoinedV1.members)
  return members_;
}

// string PartyID = 2 [json_name = "partyID"];
inline void PartyNotificationUserJoinedV1::clear_partyid() {
  partyid_.ClearToEmpty();
}
inline const std::string& PartyNotificationUserJoinedV1::partyid() const {
  // @@protoc_insertion_point(field_get:session.PartyNotificationUserJoinedV1.PartyID)
  return _internal_partyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartyNotificationUserJoinedV1::set_partyid(ArgT0&& arg0, ArgT... args) {
 
 partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartyNotificationUserJoinedV1.PartyID)
}
inline std::string* PartyNotificationUserJoinedV1::mutable_partyid() {
  std::string* _s = _internal_mutable_partyid();
  // @@protoc_insertion_point(field_mutable:session.PartyNotificationUserJoinedV1.PartyID)
  return _s;
}
inline const std::string& PartyNotificationUserJoinedV1::_internal_partyid() const {
  return partyid_.Get();
}
inline void PartyNotificationUserJoinedV1::_internal_set_partyid(const std::string& value) {
  
  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartyNotificationUserJoinedV1::_internal_mutable_partyid() {
  
  return partyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartyNotificationUserJoinedV1::release_partyid() {
  // @@protoc_insertion_point(field_release:session.PartyNotificationUserJoinedV1.PartyID)
  return partyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartyNotificationUserJoinedV1::set_allocated_partyid(std::string* partyid) {
  if (partyid != nullptr) {
    
  } else {
    
  }
  partyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partyid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (partyid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    partyid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartyNotificationUserJoinedV1.PartyID)
}

// -------------------------------------------------------------------

// PartyNotificationMembersChangedV1

// repeated .session.UserV1 members = 1 [json_name = "members"];
inline int PartyNotificationMembersChangedV1::_internal_members_size() const {
  return members_.size();
}
inline int PartyNotificationMembersChangedV1::members_size() const {
  return _internal_members_size();
}
inline void PartyNotificationMembersChangedV1::clear_members() {
  members_.Clear();
}
inline ::session::UserV1* PartyNotificationMembersChangedV1::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:session.PartyNotificationMembersChangedV1.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >*
PartyNotificationMembersChangedV1::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:session.PartyNotificationMembersChangedV1.members)
  return &members_;
}
inline const ::session::UserV1& PartyNotificationMembersChangedV1::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::session::UserV1& PartyNotificationMembersChangedV1::members(int index) const {
  // @@protoc_insertion_point(field_get:session.PartyNotificationMembersChangedV1.members)
  return _internal_members(index);
}
inline ::session::UserV1* PartyNotificationMembersChangedV1::_internal_add_members() {
  return members_.Add();
}
inline ::session::UserV1* PartyNotificationMembersChangedV1::add_members() {
  ::session::UserV1* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:session.PartyNotificationMembersChangedV1.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >&
PartyNotificationMembersChangedV1::members() const {
  // @@protoc_insertion_point(field_list:session.PartyNotificationMembersChangedV1.members)
  return members_;
}

// string PartyID = 2 [json_name = "partyID"];
inline void PartyNotificationMembersChangedV1::clear_partyid() {
  partyid_.ClearToEmpty();
}
inline const std::string& PartyNotificationMembersChangedV1::partyid() const {
  // @@protoc_insertion_point(field_get:session.PartyNotificationMembersChangedV1.PartyID)
  return _internal_partyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartyNotificationMembersChangedV1::set_partyid(ArgT0&& arg0, ArgT... args) {
 
 partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartyNotificationMembersChangedV1.PartyID)
}
inline std::string* PartyNotificationMembersChangedV1::mutable_partyid() {
  std::string* _s = _internal_mutable_partyid();
  // @@protoc_insertion_point(field_mutable:session.PartyNotificationMembersChangedV1.PartyID)
  return _s;
}
inline const std::string& PartyNotificationMembersChangedV1::_internal_partyid() const {
  return partyid_.Get();
}
inline void PartyNotificationMembersChangedV1::_internal_set_partyid(const std::string& value) {
  
  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartyNotificationMembersChangedV1::_internal_mutable_partyid() {
  
  return partyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartyNotificationMembersChangedV1::release_partyid() {
  // @@protoc_insertion_point(field_release:session.PartyNotificationMembersChangedV1.PartyID)
  return partyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartyNotificationMembersChangedV1::set_allocated_partyid(std::string* partyid) {
  if (partyid != nullptr) {
    
  } else {
    
  }
  partyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partyid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (partyid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    partyid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartyNotificationMembersChangedV1.PartyID)
}

// string JoinerID = 3 [json_name = "joinerID"];
inline void PartyNotificationMembersChangedV1::clear_joinerid() {
  joinerid_.ClearToEmpty();
}
inline const std::string& PartyNotificationMembersChangedV1::joinerid() const {
  // @@protoc_insertion_point(field_get:session.PartyNotificationMembersChangedV1.JoinerID)
  return _internal_joinerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartyNotificationMembersChangedV1::set_joinerid(ArgT0&& arg0, ArgT... args) {
 
 joinerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartyNotificationMembersChangedV1.JoinerID)
}
inline std::string* PartyNotificationMembersChangedV1::mutable_joinerid() {
  std::string* _s = _internal_mutable_joinerid();
  // @@protoc_insertion_point(field_mutable:session.PartyNotificationMembersChangedV1.JoinerID)
  return _s;
}
inline const std::string& PartyNotificationMembersChangedV1::_internal_joinerid() const {
  return joinerid_.Get();
}
inline void PartyNotificationMembersChangedV1::_internal_set_joinerid(const std::string& value) {
  
  joinerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartyNotificationMembersChangedV1::_internal_mutable_joinerid() {
  
  return joinerid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartyNotificationMembersChangedV1::release_joinerid() {
  // @@protoc_insertion_point(field_release:session.PartyNotificationMembersChangedV1.JoinerID)
  return joinerid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartyNotificationMembersChangedV1::set_allocated_joinerid(std::string* joinerid) {
  if (joinerid != nullptr) {
    
  } else {
    
  }
  joinerid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), joinerid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (joinerid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    joinerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartyNotificationMembersChangedV1.JoinerID)
}

// string LeaderID = 4 [json_name = "leaderID"];
inline void PartyNotificationMembersChangedV1::clear_leaderid() {
  leaderid_.ClearToEmpty();
}
inline const std::string& PartyNotificationMembersChangedV1::leaderid() const {
  // @@protoc_insertion_point(field_get:session.PartyNotificationMembersChangedV1.LeaderID)
  return _internal_leaderid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartyNotificationMembersChangedV1::set_leaderid(ArgT0&& arg0, ArgT... args) {
 
 leaderid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartyNotificationMembersChangedV1.LeaderID)
}
inline std::string* PartyNotificationMembersChangedV1::mutable_leaderid() {
  std::string* _s = _internal_mutable_leaderid();
  // @@protoc_insertion_point(field_mutable:session.PartyNotificationMembersChangedV1.LeaderID)
  return _s;
}
inline const std::string& PartyNotificationMembersChangedV1::_internal_leaderid() const {
  return leaderid_.Get();
}
inline void PartyNotificationMembersChangedV1::_internal_set_leaderid(const std::string& value) {
  
  leaderid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartyNotificationMembersChangedV1::_internal_mutable_leaderid() {
  
  return leaderid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartyNotificationMembersChangedV1::release_leaderid() {
  // @@protoc_insertion_point(field_release:session.PartyNotificationMembersChangedV1.LeaderID)
  return leaderid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartyNotificationMembersChangedV1::set_allocated_leaderid(std::string* leaderid) {
  if (leaderid != nullptr) {
    
  } else {
    
  }
  leaderid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leaderid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (leaderid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    leaderid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartyNotificationMembersChangedV1.LeaderID)
}

// -------------------------------------------------------------------

// PartyNotificationUserInvitedV1

// string senderID = 1 [json_name = "senderID"];
inline void PartyNotificationUserInvitedV1::clear_senderid() {
  senderid_.ClearToEmpty();
}
inline const std::string& PartyNotificationUserInvitedV1::senderid() const {
  // @@protoc_insertion_point(field_get:session.PartyNotificationUserInvitedV1.senderID)
  return _internal_senderid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartyNotificationUserInvitedV1::set_senderid(ArgT0&& arg0, ArgT... args) {
 
 senderid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartyNotificationUserInvitedV1.senderID)
}
inline std::string* PartyNotificationUserInvitedV1::mutable_senderid() {
  std::string* _s = _internal_mutable_senderid();
  // @@protoc_insertion_point(field_mutable:session.PartyNotificationUserInvitedV1.senderID)
  return _s;
}
inline const std::string& PartyNotificationUserInvitedV1::_internal_senderid() const {
  return senderid_.Get();
}
inline void PartyNotificationUserInvitedV1::_internal_set_senderid(const std::string& value) {
  
  senderid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartyNotificationUserInvitedV1::_internal_mutable_senderid() {
  
  return senderid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartyNotificationUserInvitedV1::release_senderid() {
  // @@protoc_insertion_point(field_release:session.PartyNotificationUserInvitedV1.senderID)
  return senderid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartyNotificationUserInvitedV1::set_allocated_senderid(std::string* senderid) {
  if (senderid != nullptr) {
    
  } else {
    
  }
  senderid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), senderid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (senderid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    senderid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartyNotificationUserInvitedV1.senderID)
}

// string PartyID = 2 [json_name = "partyID"];
inline void PartyNotificationUserInvitedV1::clear_partyid() {
  partyid_.ClearToEmpty();
}
inline const std::string& PartyNotificationUserInvitedV1::partyid() const {
  // @@protoc_insertion_point(field_get:session.PartyNotificationUserInvitedV1.PartyID)
  return _internal_partyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartyNotificationUserInvitedV1::set_partyid(ArgT0&& arg0, ArgT... args) {
 
 partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartyNotificationUserInvitedV1.PartyID)
}
inline std::string* PartyNotificationUserInvitedV1::mutable_partyid() {
  std::string* _s = _internal_mutable_partyid();
  // @@protoc_insertion_point(field_mutable:session.PartyNotificationUserInvitedV1.PartyID)
  return _s;
}
inline const std::string& PartyNotificationUserInvitedV1::_internal_partyid() const {
  return partyid_.Get();
}
inline void PartyNotificationUserInvitedV1::_internal_set_partyid(const std::string& value) {
  
  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartyNotificationUserInvitedV1::_internal_mutable_partyid() {
  
  return partyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartyNotificationUserInvitedV1::release_partyid() {
  // @@protoc_insertion_point(field_release:session.PartyNotificationUserInvitedV1.PartyID)
  return partyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartyNotificationUserInvitedV1::set_allocated_partyid(std::string* partyid) {
  if (partyid != nullptr) {
    
  } else {
    
  }
  partyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partyid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (partyid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    partyid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartyNotificationUserInvitedV1.PartyID)
}

// -------------------------------------------------------------------

// PartyNotificationUserRejectV1

// repeated .session.UserV1 members = 1 [json_name = "members"];
inline int PartyNotificationUserRejectV1::_internal_members_size() const {
  return members_.size();
}
inline int PartyNotificationUserRejectV1::members_size() const {
  return _internal_members_size();
}
inline void PartyNotificationUserRejectV1::clear_members() {
  members_.Clear();
}
inline ::session::UserV1* PartyNotificationUserRejectV1::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:session.PartyNotificationUserRejectV1.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >*
PartyNotificationUserRejectV1::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:session.PartyNotificationUserRejectV1.members)
  return &members_;
}
inline const ::session::UserV1& PartyNotificationUserRejectV1::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::session::UserV1& PartyNotificationUserRejectV1::members(int index) const {
  // @@protoc_insertion_point(field_get:session.PartyNotificationUserRejectV1.members)
  return _internal_members(index);
}
inline ::session::UserV1* PartyNotificationUserRejectV1::_internal_add_members() {
  return members_.Add();
}
inline ::session::UserV1* PartyNotificationUserRejectV1::add_members() {
  ::session::UserV1* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:session.PartyNotificationUserRejectV1.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >&
PartyNotificationUserRejectV1::members() const {
  // @@protoc_insertion_point(field_list:session.PartyNotificationUserRejectV1.members)
  return members_;
}

// string PartyID = 2 [json_name = "partyID"];
inline void PartyNotificationUserRejectV1::clear_partyid() {
  partyid_.ClearToEmpty();
}
inline const std::string& PartyNotificationUserRejectV1::partyid() const {
  // @@protoc_insertion_point(field_get:session.PartyNotificationUserRejectV1.PartyID)
  return _internal_partyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartyNotificationUserRejectV1::set_partyid(ArgT0&& arg0, ArgT... args) {
 
 partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartyNotificationUserRejectV1.PartyID)
}
inline std::string* PartyNotificationUserRejectV1::mutable_partyid() {
  std::string* _s = _internal_mutable_partyid();
  // @@protoc_insertion_point(field_mutable:session.PartyNotificationUserRejectV1.PartyID)
  return _s;
}
inline const std::string& PartyNotificationUserRejectV1::_internal_partyid() const {
  return partyid_.Get();
}
inline void PartyNotificationUserRejectV1::_internal_set_partyid(const std::string& value) {
  
  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartyNotificationUserRejectV1::_internal_mutable_partyid() {
  
  return partyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartyNotificationUserRejectV1::release_partyid() {
  // @@protoc_insertion_point(field_release:session.PartyNotificationUserRejectV1.PartyID)
  return partyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartyNotificationUserRejectV1::set_allocated_partyid(std::string* partyid) {
  if (partyid != nullptr) {
    
  } else {
    
  }
  partyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partyid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (partyid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    partyid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartyNotificationUserRejectV1.PartyID)
}

// string RejectedID = 3 [json_name = "rejectedID"];
inline void PartyNotificationUserRejectV1::clear_rejectedid() {
  rejectedid_.ClearToEmpty();
}
inline const std::string& PartyNotificationUserRejectV1::rejectedid() const {
  // @@protoc_insertion_point(field_get:session.PartyNotificationUserRejectV1.RejectedID)
  return _internal_rejectedid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartyNotificationUserRejectV1::set_rejectedid(ArgT0&& arg0, ArgT... args) {
 
 rejectedid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartyNotificationUserRejectV1.RejectedID)
}
inline std::string* PartyNotificationUserRejectV1::mutable_rejectedid() {
  std::string* _s = _internal_mutable_rejectedid();
  // @@protoc_insertion_point(field_mutable:session.PartyNotificationUserRejectV1.RejectedID)
  return _s;
}
inline const std::string& PartyNotificationUserRejectV1::_internal_rejectedid() const {
  return rejectedid_.Get();
}
inline void PartyNotificationUserRejectV1::_internal_set_rejectedid(const std::string& value) {
  
  rejectedid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartyNotificationUserRejectV1::_internal_mutable_rejectedid() {
  
  return rejectedid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartyNotificationUserRejectV1::release_rejectedid() {
  // @@protoc_insertion_point(field_release:session.PartyNotificationUserRejectV1.RejectedID)
  return rejectedid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartyNotificationUserRejectV1::set_allocated_rejectedid(std::string* rejectedid) {
  if (rejectedid != nullptr) {
    
  } else {
    
  }
  rejectedid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rejectedid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rejectedid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rejectedid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartyNotificationUserRejectV1.RejectedID)
}

// -------------------------------------------------------------------

// PartyNotificationUserKickedV1

// string PartyID = 1 [json_name = "partyID"];
inline void PartyNotificationUserKickedV1::clear_partyid() {
  partyid_.ClearToEmpty();
}
inline const std::string& PartyNotificationUserKickedV1::partyid() const {
  // @@protoc_insertion_point(field_get:session.PartyNotificationUserKickedV1.PartyID)
  return _internal_partyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartyNotificationUserKickedV1::set_partyid(ArgT0&& arg0, ArgT... args) {
 
 partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.PartyNotificationUserKickedV1.PartyID)
}
inline std::string* PartyNotificationUserKickedV1::mutable_partyid() {
  std::string* _s = _internal_mutable_partyid();
  // @@protoc_insertion_point(field_mutable:session.PartyNotificationUserKickedV1.PartyID)
  return _s;
}
inline const std::string& PartyNotificationUserKickedV1::_internal_partyid() const {
  return partyid_.Get();
}
inline void PartyNotificationUserKickedV1::_internal_set_partyid(const std::string& value) {
  
  partyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartyNotificationUserKickedV1::_internal_mutable_partyid() {
  
  return partyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartyNotificationUserKickedV1::release_partyid() {
  // @@protoc_insertion_point(field_release:session.PartyNotificationUserKickedV1.PartyID)
  return partyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartyNotificationUserKickedV1::set_allocated_partyid(std::string* partyid) {
  if (partyid != nullptr) {
    
  } else {
    
  }
  partyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partyid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (partyid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    partyid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.PartyNotificationUserKickedV1.PartyID)
}

// -------------------------------------------------------------------

// GameSessionNotificationUserInvitedV1

// string SessionID = 1 [json_name = "SessionID"];
inline void GameSessionNotificationUserInvitedV1::clear_sessionid() {
  sessionid_.ClearToEmpty();
}
inline const std::string& GameSessionNotificationUserInvitedV1::sessionid() const {
  // @@protoc_insertion_point(field_get:session.GameSessionNotificationUserInvitedV1.SessionID)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSessionNotificationUserInvitedV1::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameSessionNotificationUserInvitedV1.SessionID)
}
inline std::string* GameSessionNotificationUserInvitedV1::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:session.GameSessionNotificationUserInvitedV1.SessionID)
  return _s;
}
inline const std::string& GameSessionNotificationUserInvitedV1::_internal_sessionid() const {
  return sessionid_.Get();
}
inline void GameSessionNotificationUserInvitedV1::_internal_set_sessionid(const std::string& value) {
  
  sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameSessionNotificationUserInvitedV1::_internal_mutable_sessionid() {
  
  return sessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameSessionNotificationUserInvitedV1::release_sessionid() {
  // @@protoc_insertion_point(field_release:session.GameSessionNotificationUserInvitedV1.SessionID)
  return sessionid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameSessionNotificationUserInvitedV1::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sessionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionNotificationUserInvitedV1.SessionID)
}

// -------------------------------------------------------------------

// GameSessionNotificationUserJoinedV1

// string SessionID = 1 [json_name = "SessionID"];
inline void GameSessionNotificationUserJoinedV1::clear_sessionid() {
  sessionid_.ClearToEmpty();
}
inline const std::string& GameSessionNotificationUserJoinedV1::sessionid() const {
  // @@protoc_insertion_point(field_get:session.GameSessionNotificationUserJoinedV1.SessionID)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSessionNotificationUserJoinedV1::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameSessionNotificationUserJoinedV1.SessionID)
}
inline std::string* GameSessionNotificationUserJoinedV1::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:session.GameSessionNotificationUserJoinedV1.SessionID)
  return _s;
}
inline const std::string& GameSessionNotificationUserJoinedV1::_internal_sessionid() const {
  return sessionid_.Get();
}
inline void GameSessionNotificationUserJoinedV1::_internal_set_sessionid(const std::string& value) {
  
  sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameSessionNotificationUserJoinedV1::_internal_mutable_sessionid() {
  
  return sessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameSessionNotificationUserJoinedV1::release_sessionid() {
  // @@protoc_insertion_point(field_release:session.GameSessionNotificationUserJoinedV1.SessionID)
  return sessionid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameSessionNotificationUserJoinedV1::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sessionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionNotificationUserJoinedV1.SessionID)
}

// repeated .session.UserV1 members = 2 [json_name = "members"];
inline int GameSessionNotificationUserJoinedV1::_internal_members_size() const {
  return members_.size();
}
inline int GameSessionNotificationUserJoinedV1::members_size() const {
  return _internal_members_size();
}
inline void GameSessionNotificationUserJoinedV1::clear_members() {
  members_.Clear();
}
inline ::session::UserV1* GameSessionNotificationUserJoinedV1::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:session.GameSessionNotificationUserJoinedV1.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >*
GameSessionNotificationUserJoinedV1::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:session.GameSessionNotificationUserJoinedV1.members)
  return &members_;
}
inline const ::session::UserV1& GameSessionNotificationUserJoinedV1::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::session::UserV1& GameSessionNotificationUserJoinedV1::members(int index) const {
  // @@protoc_insertion_point(field_get:session.GameSessionNotificationUserJoinedV1.members)
  return _internal_members(index);
}
inline ::session::UserV1* GameSessionNotificationUserJoinedV1::_internal_add_members() {
  return members_.Add();
}
inline ::session::UserV1* GameSessionNotificationUserJoinedV1::add_members() {
  ::session::UserV1* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:session.GameSessionNotificationUserJoinedV1.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >&
GameSessionNotificationUserJoinedV1::members() const {
  // @@protoc_insertion_point(field_list:session.GameSessionNotificationUserJoinedV1.members)
  return members_;
}

// -------------------------------------------------------------------

// GameSessionNotificationMembersChangedV1

// repeated .session.UserV1 members = 1 [json_name = "members"];
inline int GameSessionNotificationMembersChangedV1::_internal_members_size() const {
  return members_.size();
}
inline int GameSessionNotificationMembersChangedV1::members_size() const {
  return _internal_members_size();
}
inline void GameSessionNotificationMembersChangedV1::clear_members() {
  members_.Clear();
}
inline ::session::UserV1* GameSessionNotificationMembersChangedV1::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:session.GameSessionNotificationMembersChangedV1.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >*
GameSessionNotificationMembersChangedV1::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:session.GameSessionNotificationMembersChangedV1.members)
  return &members_;
}
inline const ::session::UserV1& GameSessionNotificationMembersChangedV1::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::session::UserV1& GameSessionNotificationMembersChangedV1::members(int index) const {
  // @@protoc_insertion_point(field_get:session.GameSessionNotificationMembersChangedV1.members)
  return _internal_members(index);
}
inline ::session::UserV1* GameSessionNotificationMembersChangedV1::_internal_add_members() {
  return members_.Add();
}
inline ::session::UserV1* GameSessionNotificationMembersChangedV1::add_members() {
  ::session::UserV1* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:session.GameSessionNotificationMembersChangedV1.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >&
GameSessionNotificationMembersChangedV1::members() const {
  // @@protoc_insertion_point(field_list:session.GameSessionNotificationMembersChangedV1.members)
  return members_;
}

// string SessionID = 2 [json_name = "sessionID"];
inline void GameSessionNotificationMembersChangedV1::clear_sessionid() {
  sessionid_.ClearToEmpty();
}
inline const std::string& GameSessionNotificationMembersChangedV1::sessionid() const {
  // @@protoc_insertion_point(field_get:session.GameSessionNotificationMembersChangedV1.SessionID)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSessionNotificationMembersChangedV1::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameSessionNotificationMembersChangedV1.SessionID)
}
inline std::string* GameSessionNotificationMembersChangedV1::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:session.GameSessionNotificationMembersChangedV1.SessionID)
  return _s;
}
inline const std::string& GameSessionNotificationMembersChangedV1::_internal_sessionid() const {
  return sessionid_.Get();
}
inline void GameSessionNotificationMembersChangedV1::_internal_set_sessionid(const std::string& value) {
  
  sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameSessionNotificationMembersChangedV1::_internal_mutable_sessionid() {
  
  return sessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameSessionNotificationMembersChangedV1::release_sessionid() {
  // @@protoc_insertion_point(field_release:session.GameSessionNotificationMembersChangedV1.SessionID)
  return sessionid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameSessionNotificationMembersChangedV1::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sessionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionNotificationMembersChangedV1.SessionID)
}

// string JoinerID = 3 [json_name = "joinerID"];
inline void GameSessionNotificationMembersChangedV1::clear_joinerid() {
  joinerid_.ClearToEmpty();
}
inline const std::string& GameSessionNotificationMembersChangedV1::joinerid() const {
  // @@protoc_insertion_point(field_get:session.GameSessionNotificationMembersChangedV1.JoinerID)
  return _internal_joinerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSessionNotificationMembersChangedV1::set_joinerid(ArgT0&& arg0, ArgT... args) {
 
 joinerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameSessionNotificationMembersChangedV1.JoinerID)
}
inline std::string* GameSessionNotificationMembersChangedV1::mutable_joinerid() {
  std::string* _s = _internal_mutable_joinerid();
  // @@protoc_insertion_point(field_mutable:session.GameSessionNotificationMembersChangedV1.JoinerID)
  return _s;
}
inline const std::string& GameSessionNotificationMembersChangedV1::_internal_joinerid() const {
  return joinerid_.Get();
}
inline void GameSessionNotificationMembersChangedV1::_internal_set_joinerid(const std::string& value) {
  
  joinerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameSessionNotificationMembersChangedV1::_internal_mutable_joinerid() {
  
  return joinerid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameSessionNotificationMembersChangedV1::release_joinerid() {
  // @@protoc_insertion_point(field_release:session.GameSessionNotificationMembersChangedV1.JoinerID)
  return joinerid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameSessionNotificationMembersChangedV1::set_allocated_joinerid(std::string* joinerid) {
  if (joinerid != nullptr) {
    
  } else {
    
  }
  joinerid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), joinerid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (joinerid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    joinerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionNotificationMembersChangedV1.JoinerID)
}

// -------------------------------------------------------------------

// DSStatusChangedNotificationV1

// .session.GameServerV1 GameServer = 1 [json_name = "game_server"];
inline bool DSStatusChangedNotificationV1::_internal_has_gameserver() const {
  return this != internal_default_instance() && gameserver_ != nullptr;
}
inline bool DSStatusChangedNotificationV1::has_gameserver() const {
  return _internal_has_gameserver();
}
inline void DSStatusChangedNotificationV1::clear_gameserver() {
  if (GetArenaForAllocation() == nullptr && gameserver_ != nullptr) {
    delete gameserver_;
  }
  gameserver_ = nullptr;
}
inline const ::session::GameServerV1& DSStatusChangedNotificationV1::_internal_gameserver() const {
  const ::session::GameServerV1* p = gameserver_;
  return p != nullptr ? *p : reinterpret_cast<const ::session::GameServerV1&>(
      ::session::_GameServerV1_default_instance_);
}
inline const ::session::GameServerV1& DSStatusChangedNotificationV1::gameserver() const {
  // @@protoc_insertion_point(field_get:session.DSStatusChangedNotificationV1.GameServer)
  return _internal_gameserver();
}
inline void DSStatusChangedNotificationV1::unsafe_arena_set_allocated_gameserver(
    ::session::GameServerV1* gameserver) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gameserver_);
  }
  gameserver_ = gameserver;
  if (gameserver) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.DSStatusChangedNotificationV1.GameServer)
}
inline ::session::GameServerV1* DSStatusChangedNotificationV1::release_gameserver() {
  
  ::session::GameServerV1* temp = gameserver_;
  gameserver_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::session::GameServerV1* DSStatusChangedNotificationV1::unsafe_arena_release_gameserver() {
  // @@protoc_insertion_point(field_release:session.DSStatusChangedNotificationV1.GameServer)
  
  ::session::GameServerV1* temp = gameserver_;
  gameserver_ = nullptr;
  return temp;
}
inline ::session::GameServerV1* DSStatusChangedNotificationV1::_internal_mutable_gameserver() {
  
  if (gameserver_ == nullptr) {
    auto* p = CreateMaybeMessage<::session::GameServerV1>(GetArenaForAllocation());
    gameserver_ = p;
  }
  return gameserver_;
}
inline ::session::GameServerV1* DSStatusChangedNotificationV1::mutable_gameserver() {
  ::session::GameServerV1* _msg = _internal_mutable_gameserver();
  // @@protoc_insertion_point(field_mutable:session.DSStatusChangedNotificationV1.GameServer)
  return _msg;
}
inline void DSStatusChangedNotificationV1::set_allocated_gameserver(::session::GameServerV1* gameserver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gameserver_;
  }
  if (gameserver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::session::GameServerV1>::GetOwningArena(gameserver);
    if (message_arena != submessage_arena) {
      gameserver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gameserver, submessage_arena);
    }
    
  } else {
    
  }
  gameserver_ = gameserver;
  // @@protoc_insertion_point(field_set_allocated:session.DSStatusChangedNotificationV1.GameServer)
}

// string SessionID = 2 [json_name = "sessionID"];
inline void DSStatusChangedNotificationV1::clear_sessionid() {
  sessionid_.ClearToEmpty();
}
inline const std::string& DSStatusChangedNotificationV1::sessionid() const {
  // @@protoc_insertion_point(field_get:session.DSStatusChangedNotificationV1.SessionID)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DSStatusChangedNotificationV1::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.DSStatusChangedNotificationV1.SessionID)
}
inline std::string* DSStatusChangedNotificationV1::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:session.DSStatusChangedNotificationV1.SessionID)
  return _s;
}
inline const std::string& DSStatusChangedNotificationV1::_internal_sessionid() const {
  return sessionid_.Get();
}
inline void DSStatusChangedNotificationV1::_internal_set_sessionid(const std::string& value) {
  
  sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DSStatusChangedNotificationV1::_internal_mutable_sessionid() {
  
  return sessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DSStatusChangedNotificationV1::release_sessionid() {
  // @@protoc_insertion_point(field_release:session.DSStatusChangedNotificationV1.SessionID)
  return sessionid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DSStatusChangedNotificationV1::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sessionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.DSStatusChangedNotificationV1.SessionID)
}

// string Error = 3 [json_name = "error"];
inline void DSStatusChangedNotificationV1::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& DSStatusChangedNotificationV1::error() const {
  // @@protoc_insertion_point(field_get:session.DSStatusChangedNotificationV1.Error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DSStatusChangedNotificationV1::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.DSStatusChangedNotificationV1.Error)
}
inline std::string* DSStatusChangedNotificationV1::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:session.DSStatusChangedNotificationV1.Error)
  return _s;
}
inline const std::string& DSStatusChangedNotificationV1::_internal_error() const {
  return error_.Get();
}
inline void DSStatusChangedNotificationV1::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DSStatusChangedNotificationV1::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DSStatusChangedNotificationV1::release_error() {
  // @@protoc_insertion_point(field_release:session.DSStatusChangedNotificationV1.Error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DSStatusChangedNotificationV1::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.DSStatusChangedNotificationV1.Error)
}

// -------------------------------------------------------------------

// UserIDs

// repeated string userID = 1 [json_name = "user_ids"];
inline int UserIDs::_internal_userid_size() const {
  return userid_.size();
}
inline int UserIDs::userid_size() const {
  return _internal_userid_size();
}
inline void UserIDs::clear_userid() {
  userid_.Clear();
}
inline std::string* UserIDs::add_userid() {
  std::string* _s = _internal_add_userid();
  // @@protoc_insertion_point(field_add_mutable:session.UserIDs.userID)
  return _s;
}
inline const std::string& UserIDs::_internal_userid(int index) const {
  return userid_.Get(index);
}
inline const std::string& UserIDs::userid(int index) const {
  // @@protoc_insertion_point(field_get:session.UserIDs.userID)
  return _internal_userid(index);
}
inline std::string* UserIDs::mutable_userid(int index) {
  // @@protoc_insertion_point(field_mutable:session.UserIDs.userID)
  return userid_.Mutable(index);
}
inline void UserIDs::set_userid(int index, const std::string& value) {
  userid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:session.UserIDs.userID)
}
inline void UserIDs::set_userid(int index, std::string&& value) {
  userid_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:session.UserIDs.userID)
}
inline void UserIDs::set_userid(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  userid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:session.UserIDs.userID)
}
inline void UserIDs::set_userid(int index, const char* value, size_t size) {
  userid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:session.UserIDs.userID)
}
inline std::string* UserIDs::_internal_add_userid() {
  return userid_.Add();
}
inline void UserIDs::add_userid(const std::string& value) {
  userid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:session.UserIDs.userID)
}
inline void UserIDs::add_userid(std::string&& value) {
  userid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:session.UserIDs.userID)
}
inline void UserIDs::add_userid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  userid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:session.UserIDs.userID)
}
inline void UserIDs::add_userid(const char* value, size_t size) {
  userid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:session.UserIDs.userID)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UserIDs::userid() const {
  // @@protoc_insertion_point(field_list:session.UserIDs.userID)
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UserIDs::mutable_userid() {
  // @@protoc_insertion_point(field_mutable_list:session.UserIDs.userID)
  return &userid_;
}

// -------------------------------------------------------------------

// Team

// repeated string user_ids = 1 [json_name = "user_ids"];
inline int Team::_internal_user_ids_size() const {
  return user_ids_.size();
}
inline int Team::user_ids_size() const {
  return _internal_user_ids_size();
}
inline void Team::clear_user_ids() {
  user_ids_.Clear();
}
inline std::string* Team::add_user_ids() {
  std::string* _s = _internal_add_user_ids();
  // @@protoc_insertion_point(field_add_mutable:session.Team.user_ids)
  return _s;
}
inline const std::string& Team::_internal_user_ids(int index) const {
  return user_ids_.Get(index);
}
inline const std::string& Team::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:session.Team.user_ids)
  return _internal_user_ids(index);
}
inline std::string* Team::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:session.Team.user_ids)
  return user_ids_.Mutable(index);
}
inline void Team::set_user_ids(int index, const std::string& value) {
  user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:session.Team.user_ids)
}
inline void Team::set_user_ids(int index, std::string&& value) {
  user_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:session.Team.user_ids)
}
inline void Team::set_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:session.Team.user_ids)
}
inline void Team::set_user_ids(int index, const char* value, size_t size) {
  user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:session.Team.user_ids)
}
inline std::string* Team::_internal_add_user_ids() {
  return user_ids_.Add();
}
inline void Team::add_user_ids(const std::string& value) {
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:session.Team.user_ids)
}
inline void Team::add_user_ids(std::string&& value) {
  user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:session.Team.user_ids)
}
inline void Team::add_user_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:session.Team.user_ids)
}
inline void Team::add_user_ids(const char* value, size_t size) {
  user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:session.Team.user_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Team::user_ids() const {
  // @@protoc_insertion_point(field_list:session.Team.user_ids)
  return user_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Team::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:session.Team.user_ids)
  return &user_ids_;
}

// -------------------------------------------------------------------

// GameSessionV1

// string id = 1 [json_name = "_id"];
inline void GameSessionV1::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GameSessionV1::id() const {
  // @@protoc_insertion_point(field_get:session.GameSessionV1.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSessionV1::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameSessionV1.id)
}
inline std::string* GameSessionV1::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:session.GameSessionV1.id)
  return _s;
}
inline const std::string& GameSessionV1::_internal_id() const {
  return id_.Get();
}
inline void GameSessionV1::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameSessionV1::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameSessionV1::release_id() {
  // @@protoc_insertion_point(field_release:session.GameSessionV1.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameSessionV1::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionV1.id)
}

// string namespace = 2 [json_name = "namespace"];
inline void GameSessionV1::clear_namespace_() {
  namespace__.ClearToEmpty();
}
inline const std::string& GameSessionV1::namespace_() const {
  // @@protoc_insertion_point(field_get:session.GameSessionV1.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSessionV1::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameSessionV1.namespace)
}
inline std::string* GameSessionV1::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:session.GameSessionV1.namespace)
  return _s;
}
inline const std::string& GameSessionV1::_internal_namespace_() const {
  return namespace__.Get();
}
inline void GameSessionV1::_internal_set_namespace_(const std::string& value) {
  
  namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameSessionV1::_internal_mutable_namespace_() {
  
  return namespace__.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameSessionV1::release_namespace_() {
  // @@protoc_insertion_point(field_release:session.GameSessionV1.namespace)
  return namespace__.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameSessionV1::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  namespace__.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (namespace__.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    namespace__.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionV1.namespace)
}

// repeated .session.UserV1 members = 3 [json_name = "members"];
inline int GameSessionV1::_internal_members_size() const {
  return members_.size();
}
inline int GameSessionV1::members_size() const {
  return _internal_members_size();
}
inline void GameSessionV1::clear_members() {
  members_.Clear();
}
inline ::session::UserV1* GameSessionV1::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:session.GameSessionV1.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >*
GameSessionV1::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:session.GameSessionV1.members)
  return &members_;
}
inline const ::session::UserV1& GameSessionV1::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::session::UserV1& GameSessionV1::members(int index) const {
  // @@protoc_insertion_point(field_get:session.GameSessionV1.members)
  return _internal_members(index);
}
inline ::session::UserV1* GameSessionV1::_internal_add_members() {
  return members_.Add();
}
inline ::session::UserV1* GameSessionV1::add_members() {
  ::session::UserV1* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:session.GameSessionV1.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::UserV1 >&
GameSessionV1::members() const {
  // @@protoc_insertion_point(field_list:session.GameSessionV1.members)
  return members_;
}

// bytes attributes = 4 [json_name = "attributes"];
inline void GameSessionV1::clear_attributes() {
  attributes_.ClearToEmpty();
}
inline const std::string& GameSessionV1::attributes() const {
  // @@protoc_insertion_point(field_get:session.GameSessionV1.attributes)
  return _internal_attributes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSessionV1::set_attributes(ArgT0&& arg0, ArgT... args) {
 
 attributes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameSessionV1.attributes)
}
inline std::string* GameSessionV1::mutable_attributes() {
  std::string* _s = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:session.GameSessionV1.attributes)
  return _s;
}
inline const std::string& GameSessionV1::_internal_attributes() const {
  return attributes_.Get();
}
inline void GameSessionV1::_internal_set_attributes(const std::string& value) {
  
  attributes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameSessionV1::_internal_mutable_attributes() {
  
  return attributes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameSessionV1::release_attributes() {
  // @@protoc_insertion_point(field_release:session.GameSessionV1.attributes)
  return attributes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameSessionV1::set_allocated_attributes(std::string* attributes) {
  if (attributes != nullptr) {
    
  } else {
    
  }
  attributes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attributes,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (attributes_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    attributes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionV1.attributes)
}

// string join_type = 5 [json_name = "joinType"];
inline void GameSessionV1::clear_join_type() {
  join_type_.ClearToEmpty();
}
inline const std::string& GameSessionV1::join_type() const {
  // @@protoc_insertion_point(field_get:session.GameSessionV1.join_type)
  return _internal_join_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSessionV1::set_join_type(ArgT0&& arg0, ArgT... args) {
 
 join_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameSessionV1.join_type)
}
inline std::string* GameSessionV1::mutable_join_type() {
  std::string* _s = _internal_mutable_join_type();
  // @@protoc_insertion_point(field_mutable:session.GameSessionV1.join_type)
  return _s;
}
inline const std::string& GameSessionV1::_internal_join_type() const {
  return join_type_.Get();
}
inline void GameSessionV1::_internal_set_join_type(const std::string& value) {
  
  join_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameSessionV1::_internal_mutable_join_type() {
  
  return join_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameSessionV1::release_join_type() {
  // @@protoc_insertion_point(field_release:session.GameSessionV1.join_type)
  return join_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameSessionV1::set_allocated_join_type(std::string* join_type) {
  if (join_type != nullptr) {
    
  } else {
    
  }
  join_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), join_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (join_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    join_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionV1.join_type)
}

// string created_at = 6 [json_name = "createdAt"];
inline void GameSessionV1::clear_created_at() {
  created_at_.ClearToEmpty();
}
inline const std::string& GameSessionV1::created_at() const {
  // @@protoc_insertion_point(field_get:session.GameSessionV1.created_at)
  return _internal_created_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSessionV1::set_created_at(ArgT0&& arg0, ArgT... args) {
 
 created_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameSessionV1.created_at)
}
inline std::string* GameSessionV1::mutable_created_at() {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:session.GameSessionV1.created_at)
  return _s;
}
inline const std::string& GameSessionV1::_internal_created_at() const {
  return created_at_.Get();
}
inline void GameSessionV1::_internal_set_created_at(const std::string& value) {
  
  created_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameSessionV1::_internal_mutable_created_at() {
  
  return created_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameSessionV1::release_created_at() {
  // @@protoc_insertion_point(field_release:session.GameSessionV1.created_at)
  return created_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameSessionV1::set_allocated_created_at(std::string* created_at) {
  if (created_at != nullptr) {
    
  } else {
    
  }
  created_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), created_at,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (created_at_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    created_at_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionV1.created_at)
}

// string updated_at = 7 [json_name = "updatedAt"];
inline void GameSessionV1::clear_updated_at() {
  updated_at_.ClearToEmpty();
}
inline const std::string& GameSessionV1::updated_at() const {
  // @@protoc_insertion_point(field_get:session.GameSessionV1.updated_at)
  return _internal_updated_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSessionV1::set_updated_at(ArgT0&& arg0, ArgT... args) {
 
 updated_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameSessionV1.updated_at)
}
inline std::string* GameSessionV1::mutable_updated_at() {
  std::string* _s = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:session.GameSessionV1.updated_at)
  return _s;
}
inline const std::string& GameSessionV1::_internal_updated_at() const {
  return updated_at_.Get();
}
inline void GameSessionV1::_internal_set_updated_at(const std::string& value) {
  
  updated_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameSessionV1::_internal_mutable_updated_at() {
  
  return updated_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameSessionV1::release_updated_at() {
  // @@protoc_insertion_point(field_release:session.GameSessionV1.updated_at)
  return updated_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameSessionV1::set_allocated_updated_at(std::string* updated_at) {
  if (updated_at != nullptr) {
    
  } else {
    
  }
  updated_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), updated_at,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (updated_at_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    updated_at_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionV1.updated_at)
}

// .session.SessionConfigV1 config = 8 [json_name = "config"];
inline bool GameSessionV1::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool GameSessionV1::has_config() const {
  return _internal_has_config();
}
inline void GameSessionV1::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::session::SessionConfigV1& GameSessionV1::_internal_config() const {
  const ::session::SessionConfigV1* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::session::SessionConfigV1&>(
      ::session::_SessionConfigV1_default_instance_);
}
inline const ::session::SessionConfigV1& GameSessionV1::config() const {
  // @@protoc_insertion_point(field_get:session.GameSessionV1.config)
  return _internal_config();
}
inline void GameSessionV1::unsafe_arena_set_allocated_config(
    ::session::SessionConfigV1* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.GameSessionV1.config)
}
inline ::session::SessionConfigV1* GameSessionV1::release_config() {
  
  ::session::SessionConfigV1* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::session::SessionConfigV1* GameSessionV1::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:session.GameSessionV1.config)
  
  ::session::SessionConfigV1* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::session::SessionConfigV1* GameSessionV1::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::session::SessionConfigV1>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::session::SessionConfigV1* GameSessionV1::mutable_config() {
  ::session::SessionConfigV1* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:session.GameSessionV1.config)
  return _msg;
}
inline void GameSessionV1::set_allocated_config(::session::SessionConfigV1* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::session::SessionConfigV1>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionV1.config)
}

// int32 version = 9 [json_name = "_version"];
inline void GameSessionV1::clear_version() {
  version_ = 0;
}
inline int32_t GameSessionV1::_internal_version() const {
  return version_;
}
inline int32_t GameSessionV1::version() const {
  // @@protoc_insertion_point(field_get:session.GameSessionV1.version)
  return _internal_version();
}
inline void GameSessionV1::_internal_set_version(int32_t value) {
  
  version_ = value;
}
inline void GameSessionV1::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:session.GameSessionV1.version)
}

// string match_pool = 10 [json_name = "match_pool"];
inline void GameSessionV1::clear_match_pool() {
  match_pool_.ClearToEmpty();
}
inline const std::string& GameSessionV1::match_pool() const {
  // @@protoc_insertion_point(field_get:session.GameSessionV1.match_pool)
  return _internal_match_pool();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSessionV1::set_match_pool(ArgT0&& arg0, ArgT... args) {
 
 match_pool_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameSessionV1.match_pool)
}
inline std::string* GameSessionV1::mutable_match_pool() {
  std::string* _s = _internal_mutable_match_pool();
  // @@protoc_insertion_point(field_mutable:session.GameSessionV1.match_pool)
  return _s;
}
inline const std::string& GameSessionV1::_internal_match_pool() const {
  return match_pool_.Get();
}
inline void GameSessionV1::_internal_set_match_pool(const std::string& value) {
  
  match_pool_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameSessionV1::_internal_mutable_match_pool() {
  
  return match_pool_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameSessionV1::release_match_pool() {
  // @@protoc_insertion_point(field_release:session.GameSessionV1.match_pool)
  return match_pool_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameSessionV1::set_allocated_match_pool(std::string* match_pool) {
  if (match_pool != nullptr) {
    
  } else {
    
  }
  match_pool_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), match_pool,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (match_pool_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    match_pool_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionV1.match_pool)
}

// string game_mode = 11 [json_name = "game_mode"];
inline void GameSessionV1::clear_game_mode() {
  game_mode_.ClearToEmpty();
}
inline const std::string& GameSessionV1::game_mode() const {
  // @@protoc_insertion_point(field_get:session.GameSessionV1.game_mode)
  return _internal_game_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSessionV1::set_game_mode(ArgT0&& arg0, ArgT... args) {
 
 game_mode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameSessionV1.game_mode)
}
inline std::string* GameSessionV1::mutable_game_mode() {
  std::string* _s = _internal_mutable_game_mode();
  // @@protoc_insertion_point(field_mutable:session.GameSessionV1.game_mode)
  return _s;
}
inline const std::string& GameSessionV1::_internal_game_mode() const {
  return game_mode_.Get();
}
inline void GameSessionV1::_internal_set_game_mode(const std::string& value) {
  
  game_mode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameSessionV1::_internal_mutable_game_mode() {
  
  return game_mode_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameSessionV1::release_game_mode() {
  // @@protoc_insertion_point(field_release:session.GameSessionV1.game_mode)
  return game_mode_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameSessionV1::set_allocated_game_mode(std::string* game_mode) {
  if (game_mode != nullptr) {
    
  } else {
    
  }
  game_mode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_mode,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_mode_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_mode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionV1.game_mode)
}

// string backfill_ticket_id = 12 [json_name = "backfill_ticket_id"];
inline void GameSessionV1::clear_backfill_ticket_id() {
  backfill_ticket_id_.ClearToEmpty();
}
inline const std::string& GameSessionV1::backfill_ticket_id() const {
  // @@protoc_insertion_point(field_get:session.GameSessionV1.backfill_ticket_id)
  return _internal_backfill_ticket_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSessionV1::set_backfill_ticket_id(ArgT0&& arg0, ArgT... args) {
 
 backfill_ticket_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameSessionV1.backfill_ticket_id)
}
inline std::string* GameSessionV1::mutable_backfill_ticket_id() {
  std::string* _s = _internal_mutable_backfill_ticket_id();
  // @@protoc_insertion_point(field_mutable:session.GameSessionV1.backfill_ticket_id)
  return _s;
}
inline const std::string& GameSessionV1::_internal_backfill_ticket_id() const {
  return backfill_ticket_id_.Get();
}
inline void GameSessionV1::_internal_set_backfill_ticket_id(const std::string& value) {
  
  backfill_ticket_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameSessionV1::_internal_mutable_backfill_ticket_id() {
  
  return backfill_ticket_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameSessionV1::release_backfill_ticket_id() {
  // @@protoc_insertion_point(field_release:session.GameSessionV1.backfill_ticket_id)
  return backfill_ticket_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameSessionV1::set_allocated_backfill_ticket_id(std::string* backfill_ticket_id) {
  if (backfill_ticket_id != nullptr) {
    
  } else {
    
  }
  backfill_ticket_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), backfill_ticket_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backfill_ticket_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    backfill_ticket_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionV1.backfill_ticket_id)
}

// repeated .session.Team teams = 13 [json_name = "teams"];
inline int GameSessionV1::_internal_teams_size() const {
  return teams_.size();
}
inline int GameSessionV1::teams_size() const {
  return _internal_teams_size();
}
inline void GameSessionV1::clear_teams() {
  teams_.Clear();
}
inline ::session::Team* GameSessionV1::mutable_teams(int index) {
  // @@protoc_insertion_point(field_mutable:session.GameSessionV1.teams)
  return teams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::Team >*
GameSessionV1::mutable_teams() {
  // @@protoc_insertion_point(field_mutable_list:session.GameSessionV1.teams)
  return &teams_;
}
inline const ::session::Team& GameSessionV1::_internal_teams(int index) const {
  return teams_.Get(index);
}
inline const ::session::Team& GameSessionV1::teams(int index) const {
  // @@protoc_insertion_point(field_get:session.GameSessionV1.teams)
  return _internal_teams(index);
}
inline ::session::Team* GameSessionV1::_internal_add_teams() {
  return teams_.Add();
}
inline ::session::Team* GameSessionV1::add_teams() {
  ::session::Team* _add = _internal_add_teams();
  // @@protoc_insertion_point(field_add:session.GameSessionV1.teams)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::session::Team >&
GameSessionV1::teams() const {
  // @@protoc_insertion_point(field_list:session.GameSessionV1.teams)
  return teams_;
}

// .session.DSInformationV1 DSInformationV1 = 14 [json_name = "ds_information"];
inline bool GameSessionV1::_internal_has_dsinformationv1() const {
  return this != internal_default_instance() && dsinformationv1_ != nullptr;
}
inline bool GameSessionV1::has_dsinformationv1() const {
  return _internal_has_dsinformationv1();
}
inline void GameSessionV1::clear_dsinformationv1() {
  if (GetArenaForAllocation() == nullptr && dsinformationv1_ != nullptr) {
    delete dsinformationv1_;
  }
  dsinformationv1_ = nullptr;
}
inline const ::session::DSInformationV1& GameSessionV1::_internal_dsinformationv1() const {
  const ::session::DSInformationV1* p = dsinformationv1_;
  return p != nullptr ? *p : reinterpret_cast<const ::session::DSInformationV1&>(
      ::session::_DSInformationV1_default_instance_);
}
inline const ::session::DSInformationV1& GameSessionV1::dsinformationv1() const {
  // @@protoc_insertion_point(field_get:session.GameSessionV1.DSInformationV1)
  return _internal_dsinformationv1();
}
inline void GameSessionV1::unsafe_arena_set_allocated_dsinformationv1(
    ::session::DSInformationV1* dsinformationv1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dsinformationv1_);
  }
  dsinformationv1_ = dsinformationv1;
  if (dsinformationv1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.GameSessionV1.DSInformationV1)
}
inline ::session::DSInformationV1* GameSessionV1::release_dsinformationv1() {
  
  ::session::DSInformationV1* temp = dsinformationv1_;
  dsinformationv1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::session::DSInformationV1* GameSessionV1::unsafe_arena_release_dsinformationv1() {
  // @@protoc_insertion_point(field_release:session.GameSessionV1.DSInformationV1)
  
  ::session::DSInformationV1* temp = dsinformationv1_;
  dsinformationv1_ = nullptr;
  return temp;
}
inline ::session::DSInformationV1* GameSessionV1::_internal_mutable_dsinformationv1() {
  
  if (dsinformationv1_ == nullptr) {
    auto* p = CreateMaybeMessage<::session::DSInformationV1>(GetArenaForAllocation());
    dsinformationv1_ = p;
  }
  return dsinformationv1_;
}
inline ::session::DSInformationV1* GameSessionV1::mutable_dsinformationv1() {
  ::session::DSInformationV1* _msg = _internal_mutable_dsinformationv1();
  // @@protoc_insertion_point(field_mutable:session.GameSessionV1.DSInformationV1)
  return _msg;
}
inline void GameSessionV1::set_allocated_dsinformationv1(::session::DSInformationV1* dsinformationv1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dsinformationv1_;
  }
  if (dsinformationv1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::session::DSInformationV1>::GetOwningArena(dsinformationv1);
    if (message_arena != submessage_arena) {
      dsinformationv1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dsinformationv1, submessage_arena);
    }
    
  } else {
    
  }
  dsinformationv1_ = dsinformationv1;
  // @@protoc_insertion_point(field_set_allocated:session.GameSessionV1.DSInformationV1)
}

// -------------------------------------------------------------------

// DSInformationV1

// .session.GameServerV1 GameServer = 1 [json_name = "game_server"];
inline bool DSInformationV1::_internal_has_gameserver() const {
  return this != internal_default_instance() && gameserver_ != nullptr;
}
inline bool DSInformationV1::has_gameserver() const {
  return _internal_has_gameserver();
}
inline void DSInformationV1::clear_gameserver() {
  if (GetArenaForAllocation() == nullptr && gameserver_ != nullptr) {
    delete gameserver_;
  }
  gameserver_ = nullptr;
}
inline const ::session::GameServerV1& DSInformationV1::_internal_gameserver() const {
  const ::session::GameServerV1* p = gameserver_;
  return p != nullptr ? *p : reinterpret_cast<const ::session::GameServerV1&>(
      ::session::_GameServerV1_default_instance_);
}
inline const ::session::GameServerV1& DSInformationV1::gameserver() const {
  // @@protoc_insertion_point(field_get:session.DSInformationV1.GameServer)
  return _internal_gameserver();
}
inline void DSInformationV1::unsafe_arena_set_allocated_gameserver(
    ::session::GameServerV1* gameserver) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gameserver_);
  }
  gameserver_ = gameserver;
  if (gameserver) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:session.DSInformationV1.GameServer)
}
inline ::session::GameServerV1* DSInformationV1::release_gameserver() {
  
  ::session::GameServerV1* temp = gameserver_;
  gameserver_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::session::GameServerV1* DSInformationV1::unsafe_arena_release_gameserver() {
  // @@protoc_insertion_point(field_release:session.DSInformationV1.GameServer)
  
  ::session::GameServerV1* temp = gameserver_;
  gameserver_ = nullptr;
  return temp;
}
inline ::session::GameServerV1* DSInformationV1::_internal_mutable_gameserver() {
  
  if (gameserver_ == nullptr) {
    auto* p = CreateMaybeMessage<::session::GameServerV1>(GetArenaForAllocation());
    gameserver_ = p;
  }
  return gameserver_;
}
inline ::session::GameServerV1* DSInformationV1::mutable_gameserver() {
  ::session::GameServerV1* _msg = _internal_mutable_gameserver();
  // @@protoc_insertion_point(field_mutable:session.DSInformationV1.GameServer)
  return _msg;
}
inline void DSInformationV1::set_allocated_gameserver(::session::GameServerV1* gameserver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gameserver_;
  }
  if (gameserver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::session::GameServerV1>::GetOwningArena(gameserver);
    if (message_arena != submessage_arena) {
      gameserver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gameserver, submessage_arena);
    }
    
  } else {
    
  }
  gameserver_ = gameserver;
  // @@protoc_insertion_point(field_set_allocated:session.DSInformationV1.GameServer)
}

// repeated string requested_regions = 2 [json_name = "requested_regions"];
inline int DSInformationV1::_internal_requested_regions_size() const {
  return requested_regions_.size();
}
inline int DSInformationV1::requested_regions_size() const {
  return _internal_requested_regions_size();
}
inline void DSInformationV1::clear_requested_regions() {
  requested_regions_.Clear();
}
inline std::string* DSInformationV1::add_requested_regions() {
  std::string* _s = _internal_add_requested_regions();
  // @@protoc_insertion_point(field_add_mutable:session.DSInformationV1.requested_regions)
  return _s;
}
inline const std::string& DSInformationV1::_internal_requested_regions(int index) const {
  return requested_regions_.Get(index);
}
inline const std::string& DSInformationV1::requested_regions(int index) const {
  // @@protoc_insertion_point(field_get:session.DSInformationV1.requested_regions)
  return _internal_requested_regions(index);
}
inline std::string* DSInformationV1::mutable_requested_regions(int index) {
  // @@protoc_insertion_point(field_mutable:session.DSInformationV1.requested_regions)
  return requested_regions_.Mutable(index);
}
inline void DSInformationV1::set_requested_regions(int index, const std::string& value) {
  requested_regions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:session.DSInformationV1.requested_regions)
}
inline void DSInformationV1::set_requested_regions(int index, std::string&& value) {
  requested_regions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:session.DSInformationV1.requested_regions)
}
inline void DSInformationV1::set_requested_regions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  requested_regions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:session.DSInformationV1.requested_regions)
}
inline void DSInformationV1::set_requested_regions(int index, const char* value, size_t size) {
  requested_regions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:session.DSInformationV1.requested_regions)
}
inline std::string* DSInformationV1::_internal_add_requested_regions() {
  return requested_regions_.Add();
}
inline void DSInformationV1::add_requested_regions(const std::string& value) {
  requested_regions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:session.DSInformationV1.requested_regions)
}
inline void DSInformationV1::add_requested_regions(std::string&& value) {
  requested_regions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:session.DSInformationV1.requested_regions)
}
inline void DSInformationV1::add_requested_regions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  requested_regions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:session.DSInformationV1.requested_regions)
}
inline void DSInformationV1::add_requested_regions(const char* value, size_t size) {
  requested_regions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:session.DSInformationV1.requested_regions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DSInformationV1::requested_regions() const {
  // @@protoc_insertion_point(field_list:session.DSInformationV1.requested_regions)
  return requested_regions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DSInformationV1::mutable_requested_regions() {
  // @@protoc_insertion_point(field_mutable_list:session.DSInformationV1.requested_regions)
  return &requested_regions_;
}

// string requested_at = 3 [json_name = "requested_at"];
inline void DSInformationV1::clear_requested_at() {
  requested_at_.ClearToEmpty();
}
inline const std::string& DSInformationV1::requested_at() const {
  // @@protoc_insertion_point(field_get:session.DSInformationV1.requested_at)
  return _internal_requested_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DSInformationV1::set_requested_at(ArgT0&& arg0, ArgT... args) {
 
 requested_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.DSInformationV1.requested_at)
}
inline std::string* DSInformationV1::mutable_requested_at() {
  std::string* _s = _internal_mutable_requested_at();
  // @@protoc_insertion_point(field_mutable:session.DSInformationV1.requested_at)
  return _s;
}
inline const std::string& DSInformationV1::_internal_requested_at() const {
  return requested_at_.Get();
}
inline void DSInformationV1::_internal_set_requested_at(const std::string& value) {
  
  requested_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DSInformationV1::_internal_mutable_requested_at() {
  
  return requested_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DSInformationV1::release_requested_at() {
  // @@protoc_insertion_point(field_release:session.DSInformationV1.requested_at)
  return requested_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DSInformationV1::set_allocated_requested_at(std::string* requested_at) {
  if (requested_at != nullptr) {
    
  } else {
    
  }
  requested_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requested_at,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (requested_at_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    requested_at_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.DSInformationV1.requested_at)
}

// int32 min_players = 4 [json_name = "min_players"];
inline void DSInformationV1::clear_min_players() {
  min_players_ = 0;
}
inline int32_t DSInformationV1::_internal_min_players() const {
  return min_players_;
}
inline int32_t DSInformationV1::min_players() const {
  // @@protoc_insertion_point(field_get:session.DSInformationV1.min_players)
  return _internal_min_players();
}
inline void DSInformationV1::_internal_set_min_players(int32_t value) {
  
  min_players_ = value;
}
inline void DSInformationV1::set_min_players(int32_t value) {
  _internal_set_min_players(value);
  // @@protoc_insertion_point(field_set:session.DSInformationV1.min_players)
}

// string status = 5 [json_name = "status"];
inline void DSInformationV1::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& DSInformationV1::status() const {
  // @@protoc_insertion_point(field_get:session.DSInformationV1.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DSInformationV1::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.DSInformationV1.status)
}
inline std::string* DSInformationV1::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:session.DSInformationV1.status)
  return _s;
}
inline const std::string& DSInformationV1::_internal_status() const {
  return status_.Get();
}
inline void DSInformationV1::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DSInformationV1::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DSInformationV1::release_status() {
  // @@protoc_insertion_point(field_release:session.DSInformationV1.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DSInformationV1::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.DSInformationV1.status)
}

// string client_version = 6 [json_name = "client_version"];
inline void DSInformationV1::clear_client_version() {
  client_version_.ClearToEmpty();
}
inline const std::string& DSInformationV1::client_version() const {
  // @@protoc_insertion_point(field_get:session.DSInformationV1.client_version)
  return _internal_client_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DSInformationV1::set_client_version(ArgT0&& arg0, ArgT... args) {
 
 client_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.DSInformationV1.client_version)
}
inline std::string* DSInformationV1::mutable_client_version() {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:session.DSInformationV1.client_version)
  return _s;
}
inline const std::string& DSInformationV1::_internal_client_version() const {
  return client_version_.Get();
}
inline void DSInformationV1::_internal_set_client_version(const std::string& value) {
  
  client_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DSInformationV1::_internal_mutable_client_version() {
  
  return client_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DSInformationV1::release_client_version() {
  // @@protoc_insertion_point(field_release:session.DSInformationV1.client_version)
  return client_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DSInformationV1::set_allocated_client_version(std::string* client_version) {
  if (client_version != nullptr) {
    
  } else {
    
  }
  client_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    client_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.DSInformationV1.client_version)
}

// string deployment = 7 [json_name = "deployment"];
inline void DSInformationV1::clear_deployment() {
  deployment_.ClearToEmpty();
}
inline const std::string& DSInformationV1::deployment() const {
  // @@protoc_insertion_point(field_get:session.DSInformationV1.deployment)
  return _internal_deployment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DSInformationV1::set_deployment(ArgT0&& arg0, ArgT... args) {
 
 deployment_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.DSInformationV1.deployment)
}
inline std::string* DSInformationV1::mutable_deployment() {
  std::string* _s = _internal_mutable_deployment();
  // @@protoc_insertion_point(field_mutable:session.DSInformationV1.deployment)
  return _s;
}
inline const std::string& DSInformationV1::_internal_deployment() const {
  return deployment_.Get();
}
inline void DSInformationV1::_internal_set_deployment(const std::string& value) {
  
  deployment_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DSInformationV1::_internal_mutable_deployment() {
  
  return deployment_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DSInformationV1::release_deployment() {
  // @@protoc_insertion_point(field_release:session.DSInformationV1.deployment)
  return deployment_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DSInformationV1::set_allocated_deployment(std::string* deployment) {
  if (deployment != nullptr) {
    
  } else {
    
  }
  deployment_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deployment,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (deployment_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    deployment_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.DSInformationV1.deployment)
}

// -------------------------------------------------------------------

// GameServerV1

// string pod_name = 1 [json_name = "pod_name"];
inline void GameServerV1::clear_pod_name() {
  pod_name_.ClearToEmpty();
}
inline const std::string& GameServerV1::pod_name() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.pod_name)
  return _internal_pod_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerV1::set_pod_name(ArgT0&& arg0, ArgT... args) {
 
 pod_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameServerV1.pod_name)
}
inline std::string* GameServerV1::mutable_pod_name() {
  std::string* _s = _internal_mutable_pod_name();
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.pod_name)
  return _s;
}
inline const std::string& GameServerV1::_internal_pod_name() const {
  return pod_name_.Get();
}
inline void GameServerV1::_internal_set_pod_name(const std::string& value) {
  
  pod_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerV1::_internal_mutable_pod_name() {
  
  return pod_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerV1::release_pod_name() {
  // @@protoc_insertion_point(field_release:session.GameServerV1.pod_name)
  return pod_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerV1::set_allocated_pod_name(std::string* pod_name) {
  if (pod_name != nullptr) {
    
  } else {
    
  }
  pod_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pod_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pod_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pod_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameServerV1.pod_name)
}

// string image_version = 2 [json_name = "image_version"];
inline void GameServerV1::clear_image_version() {
  image_version_.ClearToEmpty();
}
inline const std::string& GameServerV1::image_version() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.image_version)
  return _internal_image_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerV1::set_image_version(ArgT0&& arg0, ArgT... args) {
 
 image_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameServerV1.image_version)
}
inline std::string* GameServerV1::mutable_image_version() {
  std::string* _s = _internal_mutable_image_version();
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.image_version)
  return _s;
}
inline const std::string& GameServerV1::_internal_image_version() const {
  return image_version_.Get();
}
inline void GameServerV1::_internal_set_image_version(const std::string& value) {
  
  image_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerV1::_internal_mutable_image_version() {
  
  return image_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerV1::release_image_version() {
  // @@protoc_insertion_point(field_release:session.GameServerV1.image_version)
  return image_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerV1::set_allocated_image_version(std::string* image_version) {
  if (image_version != nullptr) {
    
  } else {
    
  }
  image_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameServerV1.image_version)
}

// string namespace = 3 [json_name = "namespace"];
inline void GameServerV1::clear_namespace_() {
  namespace__.ClearToEmpty();
}
inline const std::string& GameServerV1::namespace_() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerV1::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameServerV1.namespace)
}
inline std::string* GameServerV1::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.namespace)
  return _s;
}
inline const std::string& GameServerV1::_internal_namespace_() const {
  return namespace__.Get();
}
inline void GameServerV1::_internal_set_namespace_(const std::string& value) {
  
  namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerV1::_internal_mutable_namespace_() {
  
  return namespace__.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerV1::release_namespace_() {
  // @@protoc_insertion_point(field_release:session.GameServerV1.namespace)
  return namespace__.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerV1::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  namespace__.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (namespace__.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    namespace__.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameServerV1.namespace)
}

// string ip = 4 [json_name = "ip"];
inline void GameServerV1::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& GameServerV1::ip() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerV1::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameServerV1.ip)
}
inline std::string* GameServerV1::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.ip)
  return _s;
}
inline const std::string& GameServerV1::_internal_ip() const {
  return ip_.Get();
}
inline void GameServerV1::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerV1::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerV1::release_ip() {
  // @@protoc_insertion_point(field_release:session.GameServerV1.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerV1::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameServerV1.ip)
}

// repeated string alternate_ips = 5 [json_name = "alternate_ips"];
inline int GameServerV1::_internal_alternate_ips_size() const {
  return alternate_ips_.size();
}
inline int GameServerV1::alternate_ips_size() const {
  return _internal_alternate_ips_size();
}
inline void GameServerV1::clear_alternate_ips() {
  alternate_ips_.Clear();
}
inline std::string* GameServerV1::add_alternate_ips() {
  std::string* _s = _internal_add_alternate_ips();
  // @@protoc_insertion_point(field_add_mutable:session.GameServerV1.alternate_ips)
  return _s;
}
inline const std::string& GameServerV1::_internal_alternate_ips(int index) const {
  return alternate_ips_.Get(index);
}
inline const std::string& GameServerV1::alternate_ips(int index) const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.alternate_ips)
  return _internal_alternate_ips(index);
}
inline std::string* GameServerV1::mutable_alternate_ips(int index) {
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.alternate_ips)
  return alternate_ips_.Mutable(index);
}
inline void GameServerV1::set_alternate_ips(int index, const std::string& value) {
  alternate_ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:session.GameServerV1.alternate_ips)
}
inline void GameServerV1::set_alternate_ips(int index, std::string&& value) {
  alternate_ips_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:session.GameServerV1.alternate_ips)
}
inline void GameServerV1::set_alternate_ips(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  alternate_ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:session.GameServerV1.alternate_ips)
}
inline void GameServerV1::set_alternate_ips(int index, const char* value, size_t size) {
  alternate_ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:session.GameServerV1.alternate_ips)
}
inline std::string* GameServerV1::_internal_add_alternate_ips() {
  return alternate_ips_.Add();
}
inline void GameServerV1::add_alternate_ips(const std::string& value) {
  alternate_ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:session.GameServerV1.alternate_ips)
}
inline void GameServerV1::add_alternate_ips(std::string&& value) {
  alternate_ips_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:session.GameServerV1.alternate_ips)
}
inline void GameServerV1::add_alternate_ips(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  alternate_ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:session.GameServerV1.alternate_ips)
}
inline void GameServerV1::add_alternate_ips(const char* value, size_t size) {
  alternate_ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:session.GameServerV1.alternate_ips)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GameServerV1::alternate_ips() const {
  // @@protoc_insertion_point(field_list:session.GameServerV1.alternate_ips)
  return alternate_ips_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GameServerV1::mutable_alternate_ips() {
  // @@protoc_insertion_point(field_mutable_list:session.GameServerV1.alternate_ips)
  return &alternate_ips_;
}

// int32 port = 6 [json_name = "port"];
inline void GameServerV1::clear_port() {
  port_ = 0;
}
inline int32_t GameServerV1::_internal_port() const {
  return port_;
}
inline int32_t GameServerV1::port() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.port)
  return _internal_port();
}
inline void GameServerV1::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void GameServerV1::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:session.GameServerV1.port)
}

// string protocol = 7 [json_name = "protocol"];
inline void GameServerV1::clear_protocol() {
  protocol_.ClearToEmpty();
}
inline const std::string& GameServerV1::protocol() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.protocol)
  return _internal_protocol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerV1::set_protocol(ArgT0&& arg0, ArgT... args) {
 
 protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameServerV1.protocol)
}
inline std::string* GameServerV1::mutable_protocol() {
  std::string* _s = _internal_mutable_protocol();
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.protocol)
  return _s;
}
inline const std::string& GameServerV1::_internal_protocol() const {
  return protocol_.Get();
}
inline void GameServerV1::_internal_set_protocol(const std::string& value) {
  
  protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerV1::_internal_mutable_protocol() {
  
  return protocol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerV1::release_protocol() {
  // @@protoc_insertion_point(field_release:session.GameServerV1.protocol)
  return protocol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerV1::set_allocated_protocol(std::string* protocol) {
  if (protocol != nullptr) {
    
  } else {
    
  }
  protocol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), protocol,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (protocol_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    protocol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameServerV1.protocol)
}

// bytes ports = 8 [json_name = "ports"];
inline void GameServerV1::clear_ports() {
  ports_.ClearToEmpty();
}
inline const std::string& GameServerV1::ports() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.ports)
  return _internal_ports();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerV1::set_ports(ArgT0&& arg0, ArgT... args) {
 
 ports_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameServerV1.ports)
}
inline std::string* GameServerV1::mutable_ports() {
  std::string* _s = _internal_mutable_ports();
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.ports)
  return _s;
}
inline const std::string& GameServerV1::_internal_ports() const {
  return ports_.Get();
}
inline void GameServerV1::_internal_set_ports(const std::string& value) {
  
  ports_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerV1::_internal_mutable_ports() {
  
  return ports_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerV1::release_ports() {
  // @@protoc_insertion_point(field_release:session.GameServerV1.ports)
  return ports_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerV1::set_allocated_ports(std::string* ports) {
  if (ports != nullptr) {
    
  } else {
    
  }
  ports_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ports,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ports_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ports_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameServerV1.ports)
}

// string provider = 9 [json_name = "provider"];
inline void GameServerV1::clear_provider() {
  provider_.ClearToEmpty();
}
inline const std::string& GameServerV1::provider() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.provider)
  return _internal_provider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerV1::set_provider(ArgT0&& arg0, ArgT... args) {
 
 provider_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameServerV1.provider)
}
inline std::string* GameServerV1::mutable_provider() {
  std::string* _s = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.provider)
  return _s;
}
inline const std::string& GameServerV1::_internal_provider() const {
  return provider_.Get();
}
inline void GameServerV1::_internal_set_provider(const std::string& value) {
  
  provider_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerV1::_internal_mutable_provider() {
  
  return provider_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerV1::release_provider() {
  // @@protoc_insertion_point(field_release:session.GameServerV1.provider)
  return provider_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerV1::set_allocated_provider(std::string* provider) {
  if (provider != nullptr) {
    
  } else {
    
  }
  provider_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), provider,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (provider_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    provider_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameServerV1.provider)
}

// string game_version = 10 [json_name = "game_version"];
inline void GameServerV1::clear_game_version() {
  game_version_.ClearToEmpty();
}
inline const std::string& GameServerV1::game_version() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.game_version)
  return _internal_game_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerV1::set_game_version(ArgT0&& arg0, ArgT... args) {
 
 game_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameServerV1.game_version)
}
inline std::string* GameServerV1::mutable_game_version() {
  std::string* _s = _internal_mutable_game_version();
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.game_version)
  return _s;
}
inline const std::string& GameServerV1::_internal_game_version() const {
  return game_version_.Get();
}
inline void GameServerV1::_internal_set_game_version(const std::string& value) {
  
  game_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerV1::_internal_mutable_game_version() {
  
  return game_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerV1::release_game_version() {
  // @@protoc_insertion_point(field_release:session.GameServerV1.game_version)
  return game_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerV1::set_allocated_game_version(std::string* game_version) {
  if (game_version != nullptr) {
    
  } else {
    
  }
  game_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameServerV1.game_version)
}

// string status = 11 [json_name = "status"];
inline void GameServerV1::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& GameServerV1::status() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerV1::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameServerV1.status)
}
inline std::string* GameServerV1::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.status)
  return _s;
}
inline const std::string& GameServerV1::_internal_status() const {
  return status_.Get();
}
inline void GameServerV1::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerV1::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerV1::release_status() {
  // @@protoc_insertion_point(field_release:session.GameServerV1.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerV1::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameServerV1.status)
}

// string session_id = 12 [json_name = "session_id"];
inline void GameServerV1::clear_session_id() {
  session_id_.ClearToEmpty();
}
inline const std::string& GameServerV1::session_id() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerV1::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameServerV1.session_id)
}
inline std::string* GameServerV1::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.session_id)
  return _s;
}
inline const std::string& GameServerV1::_internal_session_id() const {
  return session_id_.Get();
}
inline void GameServerV1::_internal_set_session_id(const std::string& value) {
  
  session_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerV1::_internal_mutable_session_id() {
  
  return session_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerV1::release_session_id() {
  // @@protoc_insertion_point(field_release:session.GameServerV1.session_id)
  return session_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerV1::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  session_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (session_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    session_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameServerV1.session_id)
}

// string deployment = 13 [json_name = "deployment"];
inline void GameServerV1::clear_deployment() {
  deployment_.ClearToEmpty();
}
inline const std::string& GameServerV1::deployment() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.deployment)
  return _internal_deployment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerV1::set_deployment(ArgT0&& arg0, ArgT... args) {
 
 deployment_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameServerV1.deployment)
}
inline std::string* GameServerV1::mutable_deployment() {
  std::string* _s = _internal_mutable_deployment();
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.deployment)
  return _s;
}
inline const std::string& GameServerV1::_internal_deployment() const {
  return deployment_.Get();
}
inline void GameServerV1::_internal_set_deployment(const std::string& value) {
  
  deployment_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerV1::_internal_mutable_deployment() {
  
  return deployment_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerV1::release_deployment() {
  // @@protoc_insertion_point(field_release:session.GameServerV1.deployment)
  return deployment_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerV1::set_allocated_deployment(std::string* deployment) {
  if (deployment != nullptr) {
    
  } else {
    
  }
  deployment_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deployment,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (deployment_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    deployment_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameServerV1.deployment)
}

// string region = 14 [json_name = "region"];
inline void GameServerV1::clear_region() {
  region_.ClearToEmpty();
}
inline const std::string& GameServerV1::region() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerV1::set_region(ArgT0&& arg0, ArgT... args) {
 
 region_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameServerV1.region)
}
inline std::string* GameServerV1::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.region)
  return _s;
}
inline const std::string& GameServerV1::_internal_region() const {
  return region_.Get();
}
inline void GameServerV1::_internal_set_region(const std::string& value) {
  
  region_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerV1::_internal_mutable_region() {
  
  return region_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerV1::release_region() {
  // @@protoc_insertion_point(field_release:session.GameServerV1.region)
  return region_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerV1::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  region_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameServerV1.region)
}

// string custom_attribute = 15 [json_name = "custom_attribute"];
inline void GameServerV1::clear_custom_attribute() {
  custom_attribute_.ClearToEmpty();
}
inline const std::string& GameServerV1::custom_attribute() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.custom_attribute)
  return _internal_custom_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerV1::set_custom_attribute(ArgT0&& arg0, ArgT... args) {
 
 custom_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameServerV1.custom_attribute)
}
inline std::string* GameServerV1::mutable_custom_attribute() {
  std::string* _s = _internal_mutable_custom_attribute();
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.custom_attribute)
  return _s;
}
inline const std::string& GameServerV1::_internal_custom_attribute() const {
  return custom_attribute_.Get();
}
inline void GameServerV1::_internal_set_custom_attribute(const std::string& value) {
  
  custom_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerV1::_internal_mutable_custom_attribute() {
  
  return custom_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerV1::release_custom_attribute() {
  // @@protoc_insertion_point(field_release:session.GameServerV1.custom_attribute)
  return custom_attribute_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerV1::set_allocated_custom_attribute(std::string* custom_attribute) {
  if (custom_attribute != nullptr) {
    
  } else {
    
  }
  custom_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), custom_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (custom_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    custom_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameServerV1.custom_attribute)
}

// bool is_override_game_version = 16 [json_name = "is_override_game_version"];
inline void GameServerV1::clear_is_override_game_version() {
  is_override_game_version_ = false;
}
inline bool GameServerV1::_internal_is_override_game_version() const {
  return is_override_game_version_;
}
inline bool GameServerV1::is_override_game_version() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.is_override_game_version)
  return _internal_is_override_game_version();
}
inline void GameServerV1::_internal_set_is_override_game_version(bool value) {
  
  is_override_game_version_ = value;
}
inline void GameServerV1::set_is_override_game_version(bool value) {
  _internal_set_is_override_game_version(value);
  // @@protoc_insertion_point(field_set:session.GameServerV1.is_override_game_version)
}

// string last_update = 17 [json_name = "last_update"];
inline void GameServerV1::clear_last_update() {
  last_update_.ClearToEmpty();
}
inline const std::string& GameServerV1::last_update() const {
  // @@protoc_insertion_point(field_get:session.GameServerV1.last_update)
  return _internal_last_update();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameServerV1::set_last_update(ArgT0&& arg0, ArgT... args) {
 
 last_update_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:session.GameServerV1.last_update)
}
inline std::string* GameServerV1::mutable_last_update() {
  std::string* _s = _internal_mutable_last_update();
  // @@protoc_insertion_point(field_mutable:session.GameServerV1.last_update)
  return _s;
}
inline const std::string& GameServerV1::_internal_last_update() const {
  return last_update_.Get();
}
inline void GameServerV1::_internal_set_last_update(const std::string& value) {
  
  last_update_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameServerV1::_internal_mutable_last_update() {
  
  return last_update_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameServerV1::release_last_update() {
  // @@protoc_insertion_point(field_release:session.GameServerV1.last_update)
  return last_update_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GameServerV1::set_allocated_last_update(std::string* last_update) {
  if (last_update != nullptr) {
    
  } else {
    
  }
  last_update_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_update,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_update_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    last_update_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:session.GameServerV1.last_update)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace session

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_notification_2eproto
