/*@ fixed */

#if defined(_MSC_VER)
  #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
#endif
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: matchmaking_notification.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_matchmaking_5fnotification_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_matchmaking_5fnotification_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_matchmaking_5fnotification_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_matchmaking_5fnotification_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_matchmaking_5fnotification_2eproto;
namespace matchmaking {
class MatchFoundNotifV1;
struct MatchFoundNotifV1DefaultTypeInternal;
extern MatchFoundNotifV1DefaultTypeInternal _MatchFoundNotifV1_default_instance_;
class NotificationEventEnvelope;
struct NotificationEventEnvelopeDefaultTypeInternal;
extern NotificationEventEnvelopeDefaultTypeInternal _NotificationEventEnvelope_default_instance_;
class Team;
struct TeamDefaultTypeInternal;
extern TeamDefaultTypeInternal _Team_default_instance_;
class Ticket;
struct TicketDefaultTypeInternal;
extern TicketDefaultTypeInternal _Ticket_default_instance_;
}  // namespace matchmaking
PROTOBUF_NAMESPACE_OPEN
template<> ::matchmaking::MatchFoundNotifV1* Arena::CreateMaybeMessage<::matchmaking::MatchFoundNotifV1>(Arena*);
template<> ::matchmaking::NotificationEventEnvelope* Arena::CreateMaybeMessage<::matchmaking::NotificationEventEnvelope>(Arena*);
template<> ::matchmaking::Team* Arena::CreateMaybeMessage<::matchmaking::Team>(Arena*);
template<> ::matchmaking::Ticket* Arena::CreateMaybeMessage<::matchmaking::Ticket>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace matchmaking {

// ===================================================================

class NotificationEventEnvelope final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:matchmaking.NotificationEventEnvelope) */ {
 public:
  inline NotificationEventEnvelope() : NotificationEventEnvelope(nullptr) {}
  ~NotificationEventEnvelope() override;
  explicit constexpr NotificationEventEnvelope(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotificationEventEnvelope(const NotificationEventEnvelope& from);
  NotificationEventEnvelope(NotificationEventEnvelope&& from) noexcept
    : NotificationEventEnvelope() {
    *this = ::std::move(from);
  }

  inline NotificationEventEnvelope& operator=(const NotificationEventEnvelope& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotificationEventEnvelope& operator=(NotificationEventEnvelope&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotificationEventEnvelope& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kMatchFoundNotifV1 = 1,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const NotificationEventEnvelope* internal_default_instance() {
    return reinterpret_cast<const NotificationEventEnvelope*>(
               &_NotificationEventEnvelope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NotificationEventEnvelope& a, NotificationEventEnvelope& b) {
    a.Swap(&b);
  }
  inline void Swap(NotificationEventEnvelope* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotificationEventEnvelope* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotificationEventEnvelope* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotificationEventEnvelope>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotificationEventEnvelope& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NotificationEventEnvelope& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotificationEventEnvelope* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "matchmaking.NotificationEventEnvelope";
  }
  protected:
  explicit NotificationEventEnvelope(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchFoundNotifV1FieldNumber = 1,
  };
  // .matchmaking.MatchFoundNotifV1 MatchFoundNotifV1 = 1;
  bool has_matchfoundnotifv1() const;
  private:
  bool _internal_has_matchfoundnotifv1() const;
  public:
  void clear_matchfoundnotifv1();
  const ::matchmaking::MatchFoundNotifV1& matchfoundnotifv1() const;
  PROTOBUF_NODISCARD ::matchmaking::MatchFoundNotifV1* release_matchfoundnotifv1();
  ::matchmaking::MatchFoundNotifV1* mutable_matchfoundnotifv1();
  void set_allocated_matchfoundnotifv1(::matchmaking::MatchFoundNotifV1* matchfoundnotifv1);
  private:
  const ::matchmaking::MatchFoundNotifV1& _internal_matchfoundnotifv1() const;
  ::matchmaking::MatchFoundNotifV1* _internal_mutable_matchfoundnotifv1();
  public:
  void unsafe_arena_set_allocated_matchfoundnotifv1(
      ::matchmaking::MatchFoundNotifV1* matchfoundnotifv1);
  ::matchmaking::MatchFoundNotifV1* unsafe_arena_release_matchfoundnotifv1();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:matchmaking.NotificationEventEnvelope)
 private:
  class _Internal;
  void set_has_matchfoundnotifv1();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PayloadUnion {
    constexpr PayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::matchmaking::MatchFoundNotifV1* matchfoundnotifv1_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_matchmaking_5fnotification_2eproto;
};
// -------------------------------------------------------------------

class Team final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:matchmaking.Team) */ {
 public:
  inline Team() : Team(nullptr) {}
  ~Team() override;
  explicit constexpr Team(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Team(const Team& from);
  Team(Team&& from) noexcept
    : Team() {
    *this = ::std::move(from);
  }

  inline Team& operator=(const Team& from) {
    CopyFrom(from);
    return *this;
  }
  inline Team& operator=(Team&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Team& default_instance() {
    return *internal_default_instance();
  }
  static inline const Team* internal_default_instance() {
    return reinterpret_cast<const Team*>(
               &_Team_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Team& a, Team& b) {
    a.Swap(&b);
  }
  inline void Swap(Team* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Team* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Team* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Team>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Team& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Team& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Team* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "matchmaking.Team";
  }
  protected:
  explicit Team(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdsFieldNumber = 1,
  };
  // repeated string user_ids = 1;
  int user_ids_size() const;
  private:
  int _internal_user_ids_size() const;
  public:
  void clear_user_ids();
  const std::string& user_ids(int index) const;
  std::string* mutable_user_ids(int index);
  void set_user_ids(int index, const std::string& value);
  void set_user_ids(int index, std::string&& value);
  void set_user_ids(int index, const char* value);
  void set_user_ids(int index, const char* value, size_t size);
  std::string* add_user_ids();
  void add_user_ids(const std::string& value);
  void add_user_ids(std::string&& value);
  void add_user_ids(const char* value);
  void add_user_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_ids();
  private:
  const std::string& _internal_user_ids(int index) const;
  std::string* _internal_add_user_ids();
  public:

  // @@protoc_insertion_point(class_scope:matchmaking.Team)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_matchmaking_5fnotification_2eproto;
};
// -------------------------------------------------------------------

class Ticket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:matchmaking.Ticket) */ {
 public:
  inline Ticket() : Ticket(nullptr) {}
  ~Ticket() override;
  explicit constexpr Ticket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ticket(const Ticket& from);
  Ticket(Ticket&& from) noexcept
    : Ticket() {
    *this = ::std::move(from);
  }

  inline Ticket& operator=(const Ticket& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ticket& operator=(Ticket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ticket& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ticket* internal_default_instance() {
    return reinterpret_cast<const Ticket*>(
               &_Ticket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Ticket& a, Ticket& b) {
    a.Swap(&b);
  }
  inline void Swap(Ticket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ticket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ticket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ticket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ticket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Ticket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ticket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "matchmaking.Ticket";
  }
  protected:
  explicit Ticket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketIdFieldNumber = 1,
  };
  // string ticket_id = 1;
  void clear_ticket_id();
  const std::string& ticket_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ticket_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ticket_id();
  PROTOBUF_NODISCARD std::string* release_ticket_id();
  void set_allocated_ticket_id(std::string* ticket_id);
  private:
  const std::string& _internal_ticket_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticket_id(const std::string& value);
  std::string* _internal_mutable_ticket_id();
  public:

  // @@protoc_insertion_point(class_scope:matchmaking.Ticket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticket_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_matchmaking_5fnotification_2eproto;
};
// -------------------------------------------------------------------

class MatchFoundNotifV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:matchmaking.MatchFoundNotifV1) */ {
 public:
  inline MatchFoundNotifV1() : MatchFoundNotifV1(nullptr) {}
  ~MatchFoundNotifV1() override;
  explicit constexpr MatchFoundNotifV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchFoundNotifV1(const MatchFoundNotifV1& from);
  MatchFoundNotifV1(MatchFoundNotifV1&& from) noexcept
    : MatchFoundNotifV1() {
    *this = ::std::move(from);
  }

  inline MatchFoundNotifV1& operator=(const MatchFoundNotifV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchFoundNotifV1& operator=(MatchFoundNotifV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchFoundNotifV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchFoundNotifV1* internal_default_instance() {
    return reinterpret_cast<const MatchFoundNotifV1*>(
               &_MatchFoundNotifV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MatchFoundNotifV1& a, MatchFoundNotifV1& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchFoundNotifV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchFoundNotifV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchFoundNotifV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchFoundNotifV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchFoundNotifV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchFoundNotifV1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchFoundNotifV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "matchmaking.MatchFoundNotifV1";
  }
  protected:
  explicit MatchFoundNotifV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamsFieldNumber = 5,
    kTicketsFieldNumber = 6,
    kIdFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kCreatedAtFieldNumber = 3,
    kMatchPoolFieldNumber = 4,
  };
  // repeated .matchmaking.Team teams = 5;
  int teams_size() const;
  private:
  int _internal_teams_size() const;
  public:
  void clear_teams();
  ::matchmaking::Team* mutable_teams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::matchmaking::Team >*
      mutable_teams();
  private:
  const ::matchmaking::Team& _internal_teams(int index) const;
  ::matchmaking::Team* _internal_add_teams();
  public:
  const ::matchmaking::Team& teams(int index) const;
  ::matchmaking::Team* add_teams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::matchmaking::Team >&
      teams() const;

  // repeated .matchmaking.Ticket tickets = 6;
  int tickets_size() const;
  private:
  int _internal_tickets_size() const;
  public:
  void clear_tickets();
  ::matchmaking::Ticket* mutable_tickets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::matchmaking::Ticket >*
      mutable_tickets();
  private:
  const ::matchmaking::Ticket& _internal_tickets(int index) const;
  ::matchmaking::Ticket* _internal_add_tickets();
  public:
  const ::matchmaking::Ticket& tickets(int index) const;
  ::matchmaking::Ticket* add_tickets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::matchmaking::Ticket >&
      tickets() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string namespace = 2;
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // string created_at = 3;
  void clear_created_at();
  const std::string& created_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* created_at);
  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(const std::string& value);
  std::string* _internal_mutable_created_at();
  public:

  // string match_pool = 4;
  void clear_match_pool();
  const std::string& match_pool() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_match_pool(ArgT0&& arg0, ArgT... args);
  std::string* mutable_match_pool();
  PROTOBUF_NODISCARD std::string* release_match_pool();
  void set_allocated_match_pool(std::string* match_pool);
  private:
  const std::string& _internal_match_pool() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_match_pool(const std::string& value);
  std::string* _internal_mutable_match_pool();
  public:

  // @@protoc_insertion_point(class_scope:matchmaking.MatchFoundNotifV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::matchmaking::Team > teams_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::matchmaking::Ticket > tickets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_at_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr match_pool_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_matchmaking_5fnotification_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NotificationEventEnvelope

// .matchmaking.MatchFoundNotifV1 MatchFoundNotifV1 = 1;
inline bool NotificationEventEnvelope::_internal_has_matchfoundnotifv1() const {
  return payload_case() == kMatchFoundNotifV1;
}
inline bool NotificationEventEnvelope::has_matchfoundnotifv1() const {
  return _internal_has_matchfoundnotifv1();
}
inline void NotificationEventEnvelope::set_has_matchfoundnotifv1() {
  _oneof_case_[0] = kMatchFoundNotifV1;
}
inline void NotificationEventEnvelope::clear_matchfoundnotifv1() {
  if (_internal_has_matchfoundnotifv1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.matchfoundnotifv1_;
    }
    clear_has_payload();
  }
}
inline ::matchmaking::MatchFoundNotifV1* NotificationEventEnvelope::release_matchfoundnotifv1() {
  // @@protoc_insertion_point(field_release:matchmaking.NotificationEventEnvelope.MatchFoundNotifV1)
  if (_internal_has_matchfoundnotifv1()) {
    clear_has_payload();
      ::matchmaking::MatchFoundNotifV1* temp = payload_.matchfoundnotifv1_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.matchfoundnotifv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::matchmaking::MatchFoundNotifV1& NotificationEventEnvelope::_internal_matchfoundnotifv1() const {
  return _internal_has_matchfoundnotifv1()
      ? *payload_.matchfoundnotifv1_
      : reinterpret_cast< ::matchmaking::MatchFoundNotifV1&>(::matchmaking::_MatchFoundNotifV1_default_instance_);
}
inline const ::matchmaking::MatchFoundNotifV1& NotificationEventEnvelope::matchfoundnotifv1() const {
  // @@protoc_insertion_point(field_get:matchmaking.NotificationEventEnvelope.MatchFoundNotifV1)
  return _internal_matchfoundnotifv1();
}
inline ::matchmaking::MatchFoundNotifV1* NotificationEventEnvelope::unsafe_arena_release_matchfoundnotifv1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:matchmaking.NotificationEventEnvelope.MatchFoundNotifV1)
  if (_internal_has_matchfoundnotifv1()) {
    clear_has_payload();
    ::matchmaking::MatchFoundNotifV1* temp = payload_.matchfoundnotifv1_;
    payload_.matchfoundnotifv1_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotificationEventEnvelope::unsafe_arena_set_allocated_matchfoundnotifv1(::matchmaking::MatchFoundNotifV1* matchfoundnotifv1) {
  clear_payload();
  if (matchfoundnotifv1) {
    set_has_matchfoundnotifv1();
    payload_.matchfoundnotifv1_ = matchfoundnotifv1;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:matchmaking.NotificationEventEnvelope.MatchFoundNotifV1)
}
inline ::matchmaking::MatchFoundNotifV1* NotificationEventEnvelope::_internal_mutable_matchfoundnotifv1() {
  if (!_internal_has_matchfoundnotifv1()) {
    clear_payload();
    set_has_matchfoundnotifv1();
    payload_.matchfoundnotifv1_ = CreateMaybeMessage< ::matchmaking::MatchFoundNotifV1 >(GetArenaForAllocation());
  }
  return payload_.matchfoundnotifv1_;
}
inline ::matchmaking::MatchFoundNotifV1* NotificationEventEnvelope::mutable_matchfoundnotifv1() {
  ::matchmaking::MatchFoundNotifV1* _msg = _internal_mutable_matchfoundnotifv1();
  // @@protoc_insertion_point(field_mutable:matchmaking.NotificationEventEnvelope.MatchFoundNotifV1)
  return _msg;
}

inline bool NotificationEventEnvelope::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void NotificationEventEnvelope::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline NotificationEventEnvelope::PayloadCase NotificationEventEnvelope::payload_case() const {
  return NotificationEventEnvelope::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Team

// repeated string user_ids = 1;
inline int Team::_internal_user_ids_size() const {
  return user_ids_.size();
}
inline int Team::user_ids_size() const {
  return _internal_user_ids_size();
}
inline void Team::clear_user_ids() {
  user_ids_.Clear();
}
inline std::string* Team::add_user_ids() {
  std::string* _s = _internal_add_user_ids();
  // @@protoc_insertion_point(field_add_mutable:matchmaking.Team.user_ids)
  return _s;
}
inline const std::string& Team::_internal_user_ids(int index) const {
  return user_ids_.Get(index);
}
inline const std::string& Team::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:matchmaking.Team.user_ids)
  return _internal_user_ids(index);
}
inline std::string* Team::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:matchmaking.Team.user_ids)
  return user_ids_.Mutable(index);
}
inline void Team::set_user_ids(int index, const std::string& value) {
  user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:matchmaking.Team.user_ids)
}
inline void Team::set_user_ids(int index, std::string&& value) {
  user_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:matchmaking.Team.user_ids)
}
inline void Team::set_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:matchmaking.Team.user_ids)
}
inline void Team::set_user_ids(int index, const char* value, size_t size) {
  user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:matchmaking.Team.user_ids)
}
inline std::string* Team::_internal_add_user_ids() {
  return user_ids_.Add();
}
inline void Team::add_user_ids(const std::string& value) {
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:matchmaking.Team.user_ids)
}
inline void Team::add_user_ids(std::string&& value) {
  user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:matchmaking.Team.user_ids)
}
inline void Team::add_user_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:matchmaking.Team.user_ids)
}
inline void Team::add_user_ids(const char* value, size_t size) {
  user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:matchmaking.Team.user_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Team::user_ids() const {
  // @@protoc_insertion_point(field_list:matchmaking.Team.user_ids)
  return user_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Team::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:matchmaking.Team.user_ids)
  return &user_ids_;
}

// -------------------------------------------------------------------

// Ticket

// string ticket_id = 1;
inline void Ticket::clear_ticket_id() {
  ticket_id_.ClearToEmpty();
}
inline const std::string& Ticket::ticket_id() const {
  // @@protoc_insertion_point(field_get:matchmaking.Ticket.ticket_id)
  return _internal_ticket_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ticket::set_ticket_id(ArgT0&& arg0, ArgT... args) {
 
 ticket_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:matchmaking.Ticket.ticket_id)
}
inline std::string* Ticket::mutable_ticket_id() {
  std::string* _s = _internal_mutable_ticket_id();
  // @@protoc_insertion_point(field_mutable:matchmaking.Ticket.ticket_id)
  return _s;
}
inline const std::string& Ticket::_internal_ticket_id() const {
  return ticket_id_.Get();
}
inline void Ticket::_internal_set_ticket_id(const std::string& value) {
  
  ticket_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Ticket::_internal_mutable_ticket_id() {
  
  return ticket_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Ticket::release_ticket_id() {
  // @@protoc_insertion_point(field_release:matchmaking.Ticket.ticket_id)
  return ticket_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Ticket::set_allocated_ticket_id(std::string* ticket_id) {
  if (ticket_id != nullptr) {
    
  } else {
    
  }
  ticket_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ticket_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ticket_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ticket_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:matchmaking.Ticket.ticket_id)
}

// -------------------------------------------------------------------

// MatchFoundNotifV1

// string id = 1;
inline void MatchFoundNotifV1::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& MatchFoundNotifV1::id() const {
  // @@protoc_insertion_point(field_get:matchmaking.MatchFoundNotifV1.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchFoundNotifV1::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:matchmaking.MatchFoundNotifV1.id)
}
inline std::string* MatchFoundNotifV1::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:matchmaking.MatchFoundNotifV1.id)
  return _s;
}
inline const std::string& MatchFoundNotifV1::_internal_id() const {
  return id_.Get();
}
inline void MatchFoundNotifV1::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MatchFoundNotifV1::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MatchFoundNotifV1::release_id() {
  // @@protoc_insertion_point(field_release:matchmaking.MatchFoundNotifV1.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MatchFoundNotifV1::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:matchmaking.MatchFoundNotifV1.id)
}

// string namespace = 2;
inline void MatchFoundNotifV1::clear_namespace_() {
  namespace__.ClearToEmpty();
}
inline const std::string& MatchFoundNotifV1::namespace_() const {
  // @@protoc_insertion_point(field_get:matchmaking.MatchFoundNotifV1.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchFoundNotifV1::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:matchmaking.MatchFoundNotifV1.namespace)
}
inline std::string* MatchFoundNotifV1::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:matchmaking.MatchFoundNotifV1.namespace)
  return _s;
}
inline const std::string& MatchFoundNotifV1::_internal_namespace_() const {
  return namespace__.Get();
}
inline void MatchFoundNotifV1::_internal_set_namespace_(const std::string& value) {
  
  namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MatchFoundNotifV1::_internal_mutable_namespace_() {
  
  return namespace__.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MatchFoundNotifV1::release_namespace_() {
  // @@protoc_insertion_point(field_release:matchmaking.MatchFoundNotifV1.namespace)
  return namespace__.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MatchFoundNotifV1::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  namespace__.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (namespace__.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    namespace__.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:matchmaking.MatchFoundNotifV1.namespace)
}

// string created_at = 3;
inline void MatchFoundNotifV1::clear_created_at() {
  created_at_.ClearToEmpty();
}
inline const std::string& MatchFoundNotifV1::created_at() const {
  // @@protoc_insertion_point(field_get:matchmaking.MatchFoundNotifV1.created_at)
  return _internal_created_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchFoundNotifV1::set_created_at(ArgT0&& arg0, ArgT... args) {
 
 created_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:matchmaking.MatchFoundNotifV1.created_at)
}
inline std::string* MatchFoundNotifV1::mutable_created_at() {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:matchmaking.MatchFoundNotifV1.created_at)
  return _s;
}
inline const std::string& MatchFoundNotifV1::_internal_created_at() const {
  return created_at_.Get();
}
inline void MatchFoundNotifV1::_internal_set_created_at(const std::string& value) {
  
  created_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MatchFoundNotifV1::_internal_mutable_created_at() {
  
  return created_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MatchFoundNotifV1::release_created_at() {
  // @@protoc_insertion_point(field_release:matchmaking.MatchFoundNotifV1.created_at)
  return created_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MatchFoundNotifV1::set_allocated_created_at(std::string* created_at) {
  if (created_at != nullptr) {
    
  } else {
    
  }
  created_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), created_at,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (created_at_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    created_at_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:matchmaking.MatchFoundNotifV1.created_at)
}

// string match_pool = 4;
inline void MatchFoundNotifV1::clear_match_pool() {
  match_pool_.ClearToEmpty();
}
inline const std::string& MatchFoundNotifV1::match_pool() const {
  // @@protoc_insertion_point(field_get:matchmaking.MatchFoundNotifV1.match_pool)
  return _internal_match_pool();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchFoundNotifV1::set_match_pool(ArgT0&& arg0, ArgT... args) {
 
 match_pool_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:matchmaking.MatchFoundNotifV1.match_pool)
}
inline std::string* MatchFoundNotifV1::mutable_match_pool() {
  std::string* _s = _internal_mutable_match_pool();
  // @@protoc_insertion_point(field_mutable:matchmaking.MatchFoundNotifV1.match_pool)
  return _s;
}
inline const std::string& MatchFoundNotifV1::_internal_match_pool() const {
  return match_pool_.Get();
}
inline void MatchFoundNotifV1::_internal_set_match_pool(const std::string& value) {
  
  match_pool_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MatchFoundNotifV1::_internal_mutable_match_pool() {
  
  return match_pool_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MatchFoundNotifV1::release_match_pool() {
  // @@protoc_insertion_point(field_release:matchmaking.MatchFoundNotifV1.match_pool)
  return match_pool_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MatchFoundNotifV1::set_allocated_match_pool(std::string* match_pool) {
  if (match_pool != nullptr) {
    
  } else {
    
  }
  match_pool_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), match_pool,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (match_pool_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    match_pool_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:matchmaking.MatchFoundNotifV1.match_pool)
}

// repeated .matchmaking.Team teams = 5;
inline int MatchFoundNotifV1::_internal_teams_size() const {
  return teams_.size();
}
inline int MatchFoundNotifV1::teams_size() const {
  return _internal_teams_size();
}
inline void MatchFoundNotifV1::clear_teams() {
  teams_.Clear();
}
inline ::matchmaking::Team* MatchFoundNotifV1::mutable_teams(int index) {
  // @@protoc_insertion_point(field_mutable:matchmaking.MatchFoundNotifV1.teams)
  return teams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::matchmaking::Team >*
MatchFoundNotifV1::mutable_teams() {
  // @@protoc_insertion_point(field_mutable_list:matchmaking.MatchFoundNotifV1.teams)
  return &teams_;
}
inline const ::matchmaking::Team& MatchFoundNotifV1::_internal_teams(int index) const {
  return teams_.Get(index);
}
inline const ::matchmaking::Team& MatchFoundNotifV1::teams(int index) const {
  // @@protoc_insertion_point(field_get:matchmaking.MatchFoundNotifV1.teams)
  return _internal_teams(index);
}
inline ::matchmaking::Team* MatchFoundNotifV1::_internal_add_teams() {
  return teams_.Add();
}
inline ::matchmaking::Team* MatchFoundNotifV1::add_teams() {
  ::matchmaking::Team* _add = _internal_add_teams();
  // @@protoc_insertion_point(field_add:matchmaking.MatchFoundNotifV1.teams)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::matchmaking::Team >&
MatchFoundNotifV1::teams() const {
  // @@protoc_insertion_point(field_list:matchmaking.MatchFoundNotifV1.teams)
  return teams_;
}

// repeated .matchmaking.Ticket tickets = 6;
inline int MatchFoundNotifV1::_internal_tickets_size() const {
  return tickets_.size();
}
inline int MatchFoundNotifV1::tickets_size() const {
  return _internal_tickets_size();
}
inline void MatchFoundNotifV1::clear_tickets() {
  tickets_.Clear();
}
inline ::matchmaking::Ticket* MatchFoundNotifV1::mutable_tickets(int index) {
  // @@protoc_insertion_point(field_mutable:matchmaking.MatchFoundNotifV1.tickets)
  return tickets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::matchmaking::Ticket >*
MatchFoundNotifV1::mutable_tickets() {
  // @@protoc_insertion_point(field_mutable_list:matchmaking.MatchFoundNotifV1.tickets)
  return &tickets_;
}
inline const ::matchmaking::Ticket& MatchFoundNotifV1::_internal_tickets(int index) const {
  return tickets_.Get(index);
}
inline const ::matchmaking::Ticket& MatchFoundNotifV1::tickets(int index) const {
  // @@protoc_insertion_point(field_get:matchmaking.MatchFoundNotifV1.tickets)
  return _internal_tickets(index);
}
inline ::matchmaking::Ticket* MatchFoundNotifV1::_internal_add_tickets() {
  return tickets_.Add();
}
inline ::matchmaking::Ticket* MatchFoundNotifV1::add_tickets() {
  ::matchmaking::Ticket* _add = _internal_add_tickets();
  // @@protoc_insertion_point(field_add:matchmaking.MatchFoundNotifV1.tickets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::matchmaking::Ticket >&
MatchFoundNotifV1::tickets() const {
  // @@protoc_insertion_point(field_list:matchmaking.MatchFoundNotifV1.tickets)
  return tickets_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace matchmaking

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_matchmaking_5fnotification_2eproto
